개발자들은 코드 작성보다 코드를 읽는 것에 훨씬 더 많은 시간을 소비하며, 이는 프로그래밍 분야에서 널리 알려진 사실 중 하나이다. 
'로버트 마틴의 클린 코드' 책에서 코드 작성 시간 대비 코드를 읽는 시간이 10배 정도 더 소비된다고 한다.

이러한 주장은 개발자들이 오류를 찾기 위해 코드를 읽는 시간을 생각해보면, 이 비율이 그리 놀랍지 않을 수 있다.
또한, 새로운 API를 배우는 과정에서도 주로 코드를 통해 학습을 하며, 로직과 구현 방법을 이해하기 위해 코드를 읽는다.

즉, 프로그래밍은 주로 코드 작성보다 읽는것을 더 중요하게 볼 수 있으므로, 가독성을 고려하여 명확하게 코드를 작성 해야한다.

## Reducing cognitive load

'Readability'는 사람마다 다르게 해석될 수 있다. 그러나, '실제 경험' 또는 '인지 과학'에서 나온 몇 가지 규칙들이 존재한다.  
아래에 제시된 두 가지 코드를 비교하면 이 차이점을 명확하게 알 수 있다.

```kotlin
// impl A
if (person != null && person.isAdult) {
    view.showPerson(person)
} else {
    view.showError()
}

// impl B
person?.takeIf { it.isAdult }
  ?.let(view::showPerson)
  ?: view.showError()
```

A와 B 중 어느 구현이 더 가독성이 좋은지는 사람마다 다르게 해석될 수 있다.  
Kotlin 초보자는 단순하고 일반적인 구문을 사용하는 A 구현이 훨씬 더 읽기 쉬울 것이다.  
반면, B 구현은 Kotlin 특유의 구문들을 사용하기에 경험 많은 Kotlin 개발자들에게 익숙할 수 있다.  
이처럼 각 구현의 가독성은 개발자들의 뇌가 각 구문(구조, 함수, 패턴)을 인식하고 이해하는데 얼마나 훈련되어 있는지에 따라 달라진다.

개발자들은 경험이 많은 개발자만을 위해 코드를 작성하지 않는다. 주니어 개발자는 Kotlin의 특정 구문들을 이해하지 못할 수 있으며, 이로 인해 단 하나의 코드 블록을 이해하는데 하루 종일 고민할 수 있다. 
게다가, 모든 Kotlin 개발자들도 Kotlin이 유일한 프로그래밍 언어가 아닐 수 있으므로, Kotlin 특유의 구문을 인식하는데 시간이 걸릴 수 있다. 
또한 Kotlin을 오랫동안 사용했더라도, A 구현을 이해하는 것이 더 빠를 수 있다.
즉, 덜 알려진 구문은 복잡성을 더함과 동시에 단일 문장에서 모든 것을 이해해야 할 때 복잡성을 더욱 증가시킨다.

추가로 'if' 블록에 추가 연산을 삽입해야 하는 경우, A 구현이 변경하기 더 용이함을 확인할 수 있다.
반면, B 구현에서는 함수 참조를 더 이상 활용할 수 없게되며, 엘비스 연산자의 오른쪽 항에 여러 표현을 포함하기 위해 특정 함수를 사용 해야한다.

```kotlin
if (person != null && person.isAdult) {
    view.showPerson(person)
    view.hideProgressWithSuccess()
} else {
    view.showError()
    view.hideProgressBar()
}

person?.takeIf { it.isAdult }
  ?.let {
    view.showPerson(it)
    view.hideProgressWithSuccess()
  } ?: run {
    view.showError()
    view.hideProgressBar()
  }
```

디버깅 도구는 A 구현과 같은 기본적인 구조에 맞춰 설계되었기 때문에 A 구현을 디버깅하는 것도 훨씬 더 간단하다.

또한, 흔하지 않고 '창의적인' 구조는 유연성이 떨어지고 지원이 잘 되지 않는 것이 일반적인 규칙이다.
예를 들어, 'person' 변수가 'null'일 때와 'isAdult'가 'true'일 때 다른 오류 메시지를 표시하는 또 다른 상황을 추가해야 한다고 가정해보면,
'if/else' 구문을 사용하는 A 구현에서는 'when' 구문으로 쉽게 전환하고 추가적인 분기를 쉽게 추가할 수 있다.
반면, B 구현은 이와같은 변경이 매우 어려워, 코드를 전면적으로 다시 작성해야 할 수 있다.

실제로 구현 A와 B는 동일하게 동작하지 않는다.
차이점은 'let' 함수가 람다 표현식으로부터 결과를 반환하는 데 있다. 만약 'showPerson'이 'null'을 반환하는 경우에 'showError'가 호출될 수 있음을 의미한다.
이러한 차이는 코드 리뷰나 디버깅 시에 쉽게 간과될 수 있으며, 특히 개발자가 사용하는 구조나 패턴에 대해 익숙하지 않은 경우에 더욱 그렇다.

개발자의 목표는 'reducing cognitive'를 최소화하는 것이다.
프로그램 작동 방식을 이해하는 과정에서 우리의 뇌는 패턴을 인식하고, 이 패턴을 통해 지식을 구축한다.
따라서, 가독성이 높은 코드는 이런 패턴을 쉽게 인식할 수 있기에 프로그램 동작 원리를 더 빠르게 이해할 수 있게 한다.
이 때문에 코드 작성 시, 가능한 일반적이고 친숙한 구조를 사용하는 것이 좋다. 
또한 다른 분야에서 익숙한 구조를 코드에 적용하는 것은 새로운 프로그래밍 언어나 패러다임을 학습할 때 유리하다. 
친숙한 패턴과 구조를 사용함으로써, 새로운 정보를 기존 지식에 더 쉽게 연결할 수 있고, 이는 학습 과정을 가속화하고 프로그래밍 능력을 향상시킨다.

---

## Do not get extreme

'let'이 잘못 사용될 수 있다는 예제를 보았지만, 이는 'let'을 항상 사용하지 말아야 한다는 아니다.  
실제로 'let'은 다양한 상황에서 합리적으로 코드를 향상시킬 수 있는 인기 있는 구문이다.

예를 들어, 'nullable 가변 프로퍼티'가 'null'이 아닐 경우에만 어떤 연산을 실행해야 하는 상황에서 
가변 프로퍼티는 다른 스레드에 변경될 수 있어 'smart-casting'이 불가능하다. 
이 때 'safe-call'과 'let'을 함께 사용하여 이런 상황을 해결할 수 있다.

```kotlin
class Person(val name: String)

var person: Person? = null

fun printName() {
    person?.let { print(it.name) }
}
```

'let'과 같은 구문은 인기가 있고 널리 알려져 있으며, 'let'을 합리적으로 사용하는 사례들이 있다.

- 'argument' 계산이 끝난 후 연산을 수행하고 싶을 때
- 객체를 decorator 패턴으로 래핑하고 싶을 때

```kotlin
students
  .filter { it.pointesInSemester > 15 && it.result >= 50 }
  .sortedWith(compareBy({ it.surname }, { it.name }))
  .joinToString(separator = "\n") { "${it.surname} ${it.name}, ${it.result}" }
  .let(::print)

val obj = FileInputStream("/file.gz")
  .let(::BufferedInputStream)
  .let(::ZipInputStream)
  .let(::ObjectInputStream)
  .readObject() as SomeObject
```

코드 복잡성과 가독성 사이의 균형을 잘 찾는 것이 중요하다.  
위와 같은 코드는 디버깅이 어렵고, Kotlin 경험이 부족한 개발자들이 이해하기 어려운 코드가 될 수 있다.
하지만, 이러한 기능과 구조가 제공하는 이점으로 인해, 위와 같이 코드를 작성하는 것은 합리적일 수 있다.

이처럼 합의점은 개발자가 코드를 작성하고 설계할 때 항상 고려해야 한다.  
복잡성을 도입하는 것은 코드의 이해와 유지 관리를 어렵게 만들 수 있지만, 동시에 특정 상황에서 코드 효율성이나 표현력을 높일 수 있다.
따라서, 언제 복잡한 구조를 사용할 것인가는 개발자 판단에 달렸으며, 이는 항상 합리적인 이유가 있어야 한다.

---

## Conventions

위 내용을 통해 가독성에 대한 정의는 사람마다 다를 수 있다는 점을 확인하였다.
추가로, 개발자들은 함수 이름, 어떤 부분을 명시적으로 표현하는지, 어떤 것은 암시적으로 표현하는지, 어떤 프로그래밍 구문을 사용해야 하는지에 대해 지속적으로 논쟁을 하고 있다.

아래는 Kotlin에서 할 수 있는 최악의 일 중 하나이다. 

```kotlin
val abc = "A" { "B" } and "C"
print(abc) //ABC
```

위와 같이 좋지 않은 구문을 가능하게 하려면 다음과 같은 코드들이 있어야 한다.

```kotlin 
operator fun String.invoke(f: ()-> String): String = this + f()
infix fun String.and(s:String) = this + s
```

위 코드는 다음과 같은 여러 규칙을 위반하고 있다.

'invoke' 연산자는 특정 객체를 함수처럼 호출할 수 있게 해주는 기능으로써, 문자열에 대해 이 연산자를 사용하는 것은 맥락에 맞지 않다. 
또한 문자열은 기본적으로 호출 가능한 객체가 아니기에, Kotlin 타입 시스템과 객체 모델에 어긋난다.

함수의 마지막 인자가 람다 표현식 일 경우, 괄호 밖에 람다를 작성할 수 있는 문법적 편의를 제공한다.
이는 코드 가독성을 높이고, DSL 타입을 구현할 때 유용하다.
그러나 위 코드에서는 'invoke' 연산자와 결합하여 사용됨으로써, 의도가 명확하지 않고 혼란을 준다.

'infix' 메서드 'and'라는 이름의 의미가 명확하지 않으며, 기능을 직관적으로 이해하기 어렵게 만든다.
'append' or 'plus'와 같은 더 명확한 이름을 사용하면 메서드의 의도와 기능을 쉽게 파악할 수 있었을 것이다.

마지막으로, 문자열 연결에 대해 이미 언어에서 제공하는 기능이 있으므로 불필요하게 새로운 방법을 만들기보단,
기존의 기능을 사용하는 것이 바람직하다.