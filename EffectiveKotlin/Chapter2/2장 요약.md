# 목차

- [Item 11 : 가독성을 위한 설계](#item-11--가독성을-위한-설계)
- [Item 12 : 연산자 의미 == 함수 이름](#item-12--연산자의-의미--함수-이름)
- [Item 13 : Unit? 반환 대신 Boolean 사용](#item-13-unit-반환-대신-boolean-사용)
- [Item 14 : 변수 타입이 명확하지 않은 경우 지정하자](#item-14--변수-타입이-명확하지-않은-경우-지정하자)
- [Item 15 : Receiver의 명시적 참조 중요성](#item-15--receiver의-명시적-참조-중요성)
- [Item 16 : Property는 행동이 아닌 상태를 나타내야한다](#item-16--property는-행동이-아닌-상태를-나타내야한다)
- [Item 17 : 명명된 인수 활용 가이드](#item-17--명명된-인수-활용-가이드)
- [Item 18 : Coding Convention 준수](#item-18--coding-convention-준수)
---

# Item 11 : 가독성을 위한 설계

### 인지 부하 줄이기

- 복잡한 코드는 인지 부하를 증가시키므로, 익숙한 패턴을 사용해 가독성을 높이는 것이 좋습니다.
- 모든 개발자들에게 익숙한 `if/else` 문법을 통한 예시와 Kotlin `scope` 함수에 대한 문법을 비교

### 극단적인 접근 피하기

- 불필요한 복잡성은 피하되, 때로는 코드를 개선하기 위해 복잡성이 필요할 수 있습니다. 이 때는 균형을 잘 유지해야 합니다.
- 너무 복잡한 함수 체이닝은 피하되, 적절하게 사용하면 가독성을 높일 수 있습니다.

### Conventions (관습)

- 코드 가독성과 유지보수를 위해 코틀린의 관습을 따르는 것이 중요합니다.
- 연산자들의 약속된 사용방식을 지킵니다.
- 함수 이름을 정할 때 적절한 함수 이름인지 확인합니다.
- 이미 있는 Kotlin에서 지원하는 기능이 있는 경우 최대한 활용합니다.

# Item 12 : 연산자의 의미 == 함수 이름

### 연산자 오버로딩
연산자 오버로딩은 강력하지만 잘못 사용되면 혼동을 야기할 수 있습니다. 이는 함수의 이름이 그 기능과 일치하지 않을 때 발생합니다.   
예를 들어, 논리적 'not' 연산자를 팩토리얼 계산에 사용하는 것은 혼란스러울 수 있습니다.

### 연산자의 의미
Kotlin에서는 각 연산자가 구체적인 의미를 가집니다.   
연산자의 의미가 불분명할 경우, 명확한 이름을 가진 일반 함수를 사용하거나, 연산자처럼 보이는 구문을 원한다면 `infix` 또는 상위 수준의 함수를 사용하면 됩니다. 

위 '연산자의 의미와 함수 이름이 같아야 한다'는 규칙을 깨도 되는 경우는 `DSL`를 설계할 때입니다.

---

# Item 13: Unit? 반환 대신 Boolean 사용

### Unit?과 Boolean 동치성
Kotlin에서 `Unit?`은 `Boolean`과 동치성을 가지며 대신하여 로직을 표현하는데 사용할 수 있습니다.

### Unit?의 잘못된 사용
그러나, 잘못 사용될 경우 로직을 이해하는데 혼동을 줄 수 있습니다.

    getData()?.let { view.showData(it) } ?: view.showError()

위와 같이 `view.ShowData()`에서 `null`이 반환되는 경우를 가정하면 `view.ShowError()`가 실행될 수 있으므로
`getData()`의 `null` 상황과 `view.ShowData()`의 `null` 상황을 구분하기 어렵습니다.

위와 같은 경우 `Unit?` 대신 표준적인 `if-else` 구문을 사용하는 것이 가독성을 향상시키며 혼란을 줄일 수 있습니다.

### Unit? 대신 Boolean 사용 권장
일반적으로 `Unit?`을 `return` 하거나 연산하는 작업을 피하도록하고, 만약 그렇게 되어 있다면 `Boolean`으로 대체하는 것이 좋습니다.

---

# Item 14 : 변수 타입이 명확하지 않은 경우 지정하자

### 타입 추론과 가독성
Kotlin은 타입 추론 시스템이 잘 발달해 있어, 문맥상 타입이 명확한 경우에는 생략할 수 있습니다. 
이는 개발 시간과 가독성 향상에 도움이 됩니다.

### 타입 명시의 중요성
그러나, 타입이 명확하지 않은 경우 이러한 방식을 과도하게 사용하면 문제가 발생할 수 있습니다. 
함수 세부사항을 확인하려는 독자에게 필요한 정보를 숨기는 것은 좋지 않습니다.

### 안전성과 타입 명시
가독성 향상 뿐 아니라, 타입 명시는 컴파일러에게도 중요한 정보를 제공하며 코드의 안전성을 높이는데 기여합니다. 
타입은 중요한 정보이므로, 명확하지 않을 경우에는 명시하는것이 좋습니다.

---

# Item 15 : Receiver의 명시적 참조 중요성

### 리시버의 사용과 가독성
Kotlin에서 함수나 속성이 객체로부터 가져오는 것을 명확하게 나타내기 위해 리시버를 명시적으로 참조할 수 있습니다. 이는 코드의 가독성을 높이는 데 도움이 됩니다.

```kotlin
class User: Person() {
    private var beersDrunk: Int = 0
    
    fun drinkBeers(num: Int) {
        this.beersDrunk += num
    }
}
```

### 확장 리시버의 명시적 사용
확장 리시버를 명시적으로 참조하여 코드를 작성하면, 작성하려는 의도를 더 명확하게 표현할 수 있습니다.

```kotlin
fun <T: Comparable<T>> List<T>.quicksort(): List<T> {
    if (size < 2) return this
    val pivot = this.first()
    val (smaller, bigger) = drop(1).partition { it < pivot }
    return smaller.quickSort() + pivot + bigger.quickSort()
}
```

### 여러 리시버와의 상호작용
여러 리시버의 범위를 갖는 상황에 놓일 수 있는 `apply`, `with`, `run` 함수를 사용할 때에는, 명시적 리시버를 사용하여 안전하게 코드를 작성하는 것이 좋습니다.

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName").apply { print("Created ${this?.name}") }
        
    fun create(name: String): Node? = Node(name)
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // "Created parent.child" 출력
}
```

### 라벨을 이용한 리시버 명시
리시버가 어떤 것을 가리키는지 명확하지 않은 경우에는, 리시버를 피하거나 명시적으로 리시버를 사용해 명확하게 표현해야 합니다. 라벨을 사용하면 원하는 리시버를 정확히 참조할 수 있습니다.

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName").apply { 
            print("Created ${this.name} in ${this@Node.name}")
        }
        
    fun create(name: String): Node? = Node(name)
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // "Created parent.child in parent" 출력
}
```

# Item 16 : Property는 행동이 아닌 상태를 나타내야한다.

### 속성과 백업 필드
Kotlin의 속성(Property)은 데이터를 보유하는 방식이 Java의 필드(Field)와 비슷하며, 추가적으로 사용자 정의 `setter`와 `getter`를 제공합니다.  
컴파일러는 속성에 대한 `백업 필드`를 자동으로 생성하게 됩니다. 이 백업 필드는 `field` 키워드를 통해 접근할 수 있습니다.

### 파생 속성
파생 속성(Derived Properties)은 다른 속성이나 변수, 연산에 기반한 속성을 말합니다.   
이는 코드의 가독성을 향상시키고, 캡슐화를 쉽게하며, 데이터 타입의 변경에 쉽게 대응할 수 있게 합니다.

### 속성 사용 주의점
속성 접근자는 속성에 접근하는 함수로, 이를 통해 속성을 재정의하거나 다른 객체에게 위임할 수 있습니다.   
하지만, 속성은 알고리즘적인 행동을 나타내는 데 사용되어서는 안되며, 복잡한 로직이나 계산이 포함되어서도 안됩니다.

또한 **속성 사용을 피해야하는** 몇가지 상황은 다음과 같습니다.
- 비용이 많이 드는 연산을 수행해야 하는 상황
- 비지니스 로직이 포함되어 있는 상황
- 결과가 변하는 상황
- 실생순서가 중요한 로직을 수행하는 상황
- 형변환이 필요한 상황
- Getter가 상태를 변경하는 상황


# Item 17 : 명명된 인수 활용 가이드

### 명명된 인수(named Arguments)의 중요성
코드를 작성하거나 읽을 때, 인수의 역할이 불분명할 수 있습니다. 
Kotlin에서는 이를 명명된 인수(named arguments)를 사용해 해결할 수 있습니다. 
명명된 인수는 값의 의미를 명확히 표현하고, 인수의 순서에 독립적으로 안전하게 코드를 작성할 수 있게 합니다.

### 명명된 인수 활용
기본값을 가진 인수, 같은 타입의 인수, 함수가 아닌 타입이면서 마지막 매개변수가 아닌 경우에는 명명된 인수를 사용하는 것이 바람직합니다.
이는 코드의 안정성을 보장하고, 잘못된 인수의 배치나 순서 변경으로 인한 문제를 방지해줍니다.

함수형 매개변수의 경우, 혼동을 줄이기 위해 이름을 붙이는 것이 좋습니다. 마지막에 위치한 함수형 매개변수만이 이름 없이 사용될 수 있으며, 그 외에는 이름을 붙여서 사용해야 합니다.

따라서, 명명된 인수의 사용은 코드의 명확성, 안전성, 신뢰성을 높일 수 있습니다.


# Item 18 : Coding Convention 준수

### Coding Convention 이해와 적용: 효율적인 코드 가독성과 협업
Kotlin의 Coding Convention은 코드 이해도 향상과 효율적인 협업을 가능하게 합니다.   
이는 프로젝트 간 이동을 용이하게 하며, 코드의 작동 방식을 추론하는 데 도움이 됩니다. 이러한 규칙을 준수하면 외부 개발자도 코드를 쉽게 읽을 수 있습니다.

### 클래스와 함수의 포맷팅 규칙
클래스와 함수의 매개변수를 적절하게 줄 바꿈하여 표현하는 것이 중요합니다. 이는 코드의 일관성을 유지하고, 가독성을 높이는 데 도움이 됩니다.   
들여쓰기의 불일관성과 코드 가독성 저하를 방지하기 위해, Kotlin Coding Convention에 따라 첫 번째 매개변수를 같은 줄에 두는 것을 피해야 합니다.