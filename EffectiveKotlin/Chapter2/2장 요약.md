# Item 11 : Design for readability

개발자들은 오류를 찾기 위해 코드를 추적하고 읽는 시간과 새로운 API의 로직과 구현 방법을 이해하기 위해 코드를 읽는 시간을 생각해보면,
프로그래밍은 주로 코드를 작성하는 시간보다 코드를 읽는 시간이 더 많다는 것을 알 수 있다.
따라서 코드 작성 시, 'Readability'를 고려하여 명확하게 코드를 작성하는 것이 중요하다.

## Reducing cognitive load

'Readability'는 개발자마다 다르게 해석될 수 있다. 아래 예시를 보자.

```kotlin
// impl A
if (person != null && person.isAdult) {
    view.showPerson(person)
} else {
    view.showError()
}

// impl B
person?.takeIf { it.isAdult }
    ?.let(view::showPerson)
    ?: view.showError()
```

경험이 적은 Kotlin 개발자는 A 구현이 훨씬 더 읽기 쉬울 것이고, 경험이 많은 Kotlin 개발자들은 B 구현이 더 익숙할 수 있다.
이처럼 두 구현의 'Readability'는 개발자들이 구문을 인식하고 이해하는데 얼마나 훈련되어 있는지에 따라 달라진다.

이처럼 'Readability' 관점에서는 A 구현이 더 장점이 많으며, 그 이유는 아래와 같다.

1. 프로젝트 협업 시, 주니어 개발자는 B 구현을 이해하는데 비효율적인 시간을 보낼 수 있으며, Kotlin을 오랫동안 사용했더라도 일반적으로 사용되는 A 구현을 이해하는 것이 더 쉽다.
2.  디버깅 도구는 A 구현과 같이 기본적인 구조에 맞춰서 설계되었기에 디버깅 과정도 B 구현에 비해 더 간단하다.
3. 추가적인 조건을 분기해야 하는 경우, A 구현에서는 'when' 구문으로 전환하여 추가적인 분기를 쉽게 추가할 수 있다.
   반면, B 구현은 이와 같은 변경이 매우 어려워, 코드를 전면적으로 다시 작성해야 할 수 있다.
4. 'if' 블록에 추가적인 구현이 필요한 경우, A 구현의 변경이 더 용이하다.
   반면, B 구현의 경우에 '함수 참조'를 사용이 불가능하며, 엘비스 연산자의 오른쪽 항에 특정 함수('run')를 사용 해야한다.

```kotlin
if (person != null && person.isAdult) {
    view.showPerson(person)
    view.hideProgressWithSuccess()
} else {
    view.showError()
    view.hideProgressBar()
}

person?.takeIf { it.isAdult }
  ?.let {
    view.showPerson(it)
    view.hideProgressWithSuccess()
  } ?: run {
    view.showError()
    view.hideProgressBar()
  }
```

5. B 구현의 경우 'showPerson'이 'null'을 반환하는 경우에 'let' 함수가 결과를 반환함으로, 'showError'가 호출될 수 있어 원하지 않는 동작이 실행될 수 있고,
  코드 리뷰나 디버깅 시 쉽게 간과될 수 있다.

## Do not get extreme

위 극단적인 경우와 반대로, 'let'은 다양한 상황에서 합리적으로 코드를 간결하게 만들 수 있는 인기 있는 구문이다.

예를 들어, 'Nullable 가변 프로퍼티'가 'null'이 아닐 때 어떤 연산을 실행해야 상황에서 가변 프로퍼티는 다른 스레드에 의해 변경될 수 있기에 'smart-casting'이 불가능하다.
이 때 'Safe-call'과 'let'을 함께 사용하여 해당 상황을 간결하게 실행할 수 있다.

```kotlin
var name: String? = null

fun printName() {
    name?.let { println(it) }
}
```

위와 같이 'let'은 아래와 같은 상황에서 코드를 간결하게 만들 수 있다.

1. 'Argument'에 대한 계산을 끝낸 후, 특정 연산을 수행하고 싶은 경우

```kotlin
students
    .filter { it.pointesInSemester > 15 && it.result >= 50 }
    .sortedWith(compareBy({ it.surname }, { it.name }))
    .joinToString(separator = "\n") { "${it.surname} ${it.name}, ${it.result}" }
    .let(::print)
```

2. 객체를 Decorator 패턴으로 래핑하고 싶은 경우

```kotlin
val obj = FileInputStream("/file.gz")
  .let(::BufferedInputStream)
  .let(::ZipInputStream)
  .let(::ObjectInputStream)
  .readObject() as SomeObject
```

위와 같은 코드들은 디버깅이 어렵고, Kotlin 경험이 부족한 개발자들이 이해하기에 어려운 코드일 수 있다.
하지만, Kotlin에 익숙한 개발자들은 이런 기능과 구조가 가독성이 높고, 프로그램 동작 원리를 더 빠르게 이해할 수 있다.

이처럼 코드 복잡성과 가독성 사이의 균형은 개발자가 설계할 때 항상 고려해야하는 부분이다.
복잡성을 도입하는 것은 코드 이해와 유지 관리를 어렵게 만들 수 있지만, 동시에 특정 상황에서 코드 효율성과 표현력을 높일 수 있다.
따라서 복잡한 구조를 사용하는 것은 개발자 판단에 달렸으며, 항상 합리적인 이유를 가지고 사용해야 한다.

## Convention

위에서 'Readability'는 개발자마다 다를 수 있음을 확인하였고, 이러한 차이를 최소화하기 위해 'Convention'을 정하여 이를 따르는 것이 좋다.

아래는 Kotlin에서 좋지 않은 'Convention'을 사용한 예시이다.

```kotlin
operator fun String.invoke(f: ()-> String): String = this + f()
infix fun String.and(s:String) = this + s

val abc = "A" { "B" } and "C"
print(abc) // ABC
```

위와 같은 코드는 다음과 같은 규칙을 위반한다.

- 'invoke' 연산자는 객체를 함수처럼 호출하는 연산자로써, 문자열에서 이 연산자를 사용하는 것은 맥락에 맞지 않다.
- 함수 마지막 'Argument'가 'lambda expressions'인 경우, 괄호 밖에 람다를 작성할 수 있는 문법적 편의를 제공하는데, 위 코드에서는 'invoke'와 함께 사용되어 의도가 명확하지 않고 혼란을 줄 수 있다.
- 'and'라는 이름의 의미가 명확하지 않으며 기능을 직관적으로 이해하기 어렵다.
  - 'append' or 'plus'와 같이 더 명확한 이름을 통해 메서드의 의도와 기능을 명확하게 표현할 수 있었을 것이다.
- 문자열 연결에 관한 기능은 이미 언어에서 제공하기에 새로운 방법을 만들기 보단, 기존의 방법을 사용하는 것이 좋다.

---

# Item 12 : 연산자의 의미 == 함수 이름

### 연산자 오버로딩
연산자 오버로딩은 강력하지만 잘못 사용되면 혼동을 야기할 수 있습니다. 이는 함수의 이름이 그 기능과 일치하지 않을 때 발생합니다.   
예를 들어, 논리적 'not' 연산자를 팩토리얼 계산에 사용하는 것은 혼란스러울 수 있습니다.

### 연산자의 의미
Kotlin에서는 각 연산자가 구체적인 의미를 가집니다.   
연산자의 의미가 불분명할 경우, 명확한 이름을 가진 일반 함수를 사용하거나, 연산자처럼 보이는 구문을 원한다면 `infix` 또는 상위 수준의 함수를 사용하면 됩니다. 

위 '연산자의 의미와 함수 이름이 같아야 한다'는 규칙을 깨도 되는 경우는 `DSL`를 설계할 때입니다.

---

# Item 13: Unit? 반환 대신 Boolean 사용

### Unit?과 Boolean 동치성
Kotlin에서 `Unit?`은 `Boolean`과 동치성을 가지며 대신하여 로직을 표현하는데 사용할 수 있습니다.

### Unit?의 잘못된 사용
그러나, 잘못 사용될 경우 로직을 이해하는데 혼동을 줄 수 있습니다.

    getData()?.let { view.showData(it) } ?: view.showError()

위와 같이 `view.ShowData()`에서 `null`이 반환되는 경우를 가정하면 `view.ShowError()`가 실행될 수 있으므로
`getData()`의 `null` 상황과 `view.ShowData()`의 `null` 상황을 구분하기 어렵습니다.

위와 같은 경우 `Unit?` 대신 표준적인 `if-else` 구문을 사용하는 것이 가독성을 향상시키며 혼란을 줄일 수 있습니다.

### Unit? 대신 Boolean 사용 권장
일반적으로 `Unit?`을 `return` 하거나 연산하는 작업을 피하도록하고, 만약 그렇게 되어 있다면 `Boolean`으로 대체하는 것이 좋습니다.

---

# Item 14 : 변수 타입이 명확하지 않은 경우 지정하자

### 타입 추론과 가독성
Kotlin은 타입 추론 시스템이 잘 발달해 있어, 문맥상 타입이 명확한 경우에는 생략할 수 있습니다. 
이는 개발 시간과 가독성 향상에 도움이 됩니다.

### 타입 명시의 중요성
그러나, 타입이 명확하지 않은 경우 이러한 방식을 과도하게 사용하면 문제가 발생할 수 있습니다. 
함수 세부사항을 확인하려는 독자에게 필요한 정보를 숨기는 것은 좋지 않습니다.

### 안전성과 타입 명시
가독성 향상 뿐 아니라, 타입 명시는 컴파일러에게도 중요한 정보를 제공하며 코드의 안전성을 높이는데 기여합니다. 
타입은 중요한 정보이므로, 명확하지 않을 경우에는 명시하는것이 좋습니다.

---

# Item 15 : Receiver의 명시적 참조 중요성

### 리시버의 사용과 가독성
Kotlin에서 함수나 속성이 객체로부터 가져오는 것을 명확하게 나타내기 위해 리시버를 명시적으로 참조할 수 있습니다. 이는 코드의 가독성을 높이는 데 도움이 됩니다.

```kotlin
class User: Person() {
    private var beersDrunk: Int = 0
    
    fun drinkBeers(num: Int) {
        this.beersDrunk += num
    }
}
```

### 확장 리시버의 명시적 사용
확장 리시버를 명시적으로 참조하여 코드를 작성하면, 작성하려는 의도를 더 명확하게 표현할 수 있습니다.

```kotlin
fun <T: Comparable<T>> List<T>.quicksort(): List<T> {
    if (size < 2) return this
    val pivot = this.first()
    val (smaller, bigger) = drop(1).partition { it < pivot }
    return smaller.quickSort() + pivot + bigger.quickSort()
}
```

### 여러 리시버와의 상호작용
여러 리시버의 범위를 갖는 상황에 놓일 수 있는 `apply`, `with`, `run` 함수를 사용할 때에는, 명시적 리시버를 사용하여 안전하게 코드를 작성하는 것이 좋습니다.

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName").apply { print("Created ${this?.name}") }
        
    fun create(name: String): Node? = Node(name)
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // "Created parent.child" 출력
}
```

### 라벨을 이용한 리시버 명시
리시버가 어떤 것을 가리키는지 명확하지 않은 경우에는, 리시버를 피하거나 명시적으로 리시버를 사용해 명확하게 표현해야 합니다. 라벨을 사용하면 원하는 리시버를 정확히 참조할 수 있습니다.

```kotlin
class Node(val name: String) {
    fun makeChild(childName: String) =
        create("$name.$childName").apply { 
            print("Created ${this.name} in ${this@Node.name}")
        }
        
    fun create(name: String): Node? = Node(name)
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // "Created parent.child in parent" 출력
}
```

# Item 16 : Property는 행동이 아닌 상태를 나타내야한다.

### 속성과 백업 필드
Kotlin의 속성(Property)은 데이터를 보유하는 방식이 Java의 필드(Field)와 비슷하며, 추가적으로 사용자 정의 `setter`와 `getter`를 제공합니다.  
컴파일러는 속성에 대한 `백업 필드`를 자동으로 생성하게 됩니다. 이 백업 필드는 `field` 키워드를 통해 접근할 수 있습니다.

### 파생 속성
파생 속성(Derived Properties)은 다른 속성이나 변수, 연산에 기반한 속성을 말합니다.   
이는 코드의 가독성을 향상시키고, 캡슐화를 쉽게하며, 데이터 타입의 변경에 쉽게 대응할 수 있게 합니다.

### 속성 사용 주의점
속성 접근자는 속성에 접근하는 함수로, 이를 통해 속성을 재정의하거나 다른 객체에게 위임할 수 있습니다.   
하지만, 속성은 알고리즘적인 행동을 나타내는 데 사용되어서는 안되며, 복잡한 로직이나 계산이 포함되어서도 안됩니다.

또한 **속성 사용을 피해야하는** 몇가지 상황은 다음과 같습니다.
- 비용이 많이 드는 연산을 수행해야 하는 상황
- 비지니스 로직이 포함되어 있는 상황
- 결과가 변하는 상황
- 실생순서가 중요한 로직을 수행하는 상황
- 형변환이 필요한 상황
- Getter가 상태를 변경하는 상황


# Item 17 : 명명된 인수 활용 가이드

### 명명된 인수(named Arguments)의 중요성
코드를 작성하거나 읽을 때, 인수의 역할이 불분명할 수 있습니다. 
Kotlin에서는 이를 명명된 인수(named arguments)를 사용해 해결할 수 있습니다. 
명명된 인수는 값의 의미를 명확히 표현하고, 인수의 순서에 독립적으로 안전하게 코드를 작성할 수 있게 합니다.

### 명명된 인수 활용
기본값을 가진 인수, 같은 타입의 인수, 함수가 아닌 타입이면서 마지막 매개변수가 아닌 경우에는 명명된 인수를 사용하는 것이 바람직합니다.
이는 코드의 안정성을 보장하고, 잘못된 인수의 배치나 순서 변경으로 인한 문제를 방지해줍니다.

함수형 매개변수의 경우, 혼동을 줄이기 위해 이름을 붙이는 것이 좋습니다. 마지막에 위치한 함수형 매개변수만이 이름 없이 사용될 수 있으며, 그 외에는 이름을 붙여서 사용해야 합니다.

따라서, 명명된 인수의 사용은 코드의 명확성, 안전성, 신뢰성을 높일 수 있습니다.


# Item 18 : Coding Convention 준수

### Coding Convention 이해와 적용: 효율적인 코드 가독성과 협업
Kotlin의 Coding Convention은 코드 이해도 향상과 효율적인 협업을 가능하게 합니다.   
이는 프로젝트 간 이동을 용이하게 하며, 코드의 작동 방식을 추론하는 데 도움이 됩니다. 이러한 규칙을 준수하면 외부 개발자도 코드를 쉽게 읽을 수 있습니다.

### 클래스와 함수의 포맷팅 규칙
클래스와 함수의 매개변수를 적절하게 줄 바꿈하여 표현하는 것이 중요합니다. 이는 코드의 일관성을 유지하고, 가독성을 높이는 데 도움이 됩니다.   
들여쓰기의 불일관성과 코드 가독성 저하를 방지하기 위해, Kotlin Coding Convention에 따라 첫 번째 매개변수를 같은 줄에 두는 것을 피해야 합니다.