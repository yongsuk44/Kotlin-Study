# Item 11 : Design for readability

개발자들은 오류를 찾기 위해 코드를 추적하고 읽는 시간과 새로운 API의 로직과 구현 방법을 이해하기 위해 코드를 읽는 시간을 생각해보면,
프로그래밍은 주로 코드를 작성하는 시간보다 코드를 읽는 시간이 더 많다는 것을 알 수 있다.
따라서 코드 작성 시, 'Readability'를 고려하여 명확하게 코드를 작성하는 것이 중요하다.

## Reducing cognitive load

'Readability'는 개발자마다 다르게 해석될 수 있다. 아래 예시를 보자.

```kotlin
// impl A
if (person != null && person.isAdult) {
    view.showPerson(person)
} else {
    view.showError()
}

// impl B
person?.takeIf { it.isAdult }
    ?.let(view::showPerson)
    ?: view.showError()
```

경험이 적은 Kotlin 개발자는 A 구현이 훨씬 더 읽기 쉬울 것이고, 경험이 많은 Kotlin 개발자들은 B 구현이 더 익숙할 수 있다.
이처럼 두 구현의 'Readability'는 개발자들이 구문을 인식하고 이해하는데 얼마나 훈련되어 있는지에 따라 달라진다.

'Readability' 관점에서는 A 구현이 더 장점이 많으며, 그 이유는 아래와 같다.

1. 프로젝트 협업 시, 주니어 개발자는 B 구현을 이해하는데 비효율적인 시간을 보낼 수 있으며, Kotlin을 오랫동안 사용했더라도 일반적으로 사용되는 A 구현을 이해하는 것이 더 쉽다.
2.  디버깅 도구는 A 구현과 같이 기본적인 구조에 맞춰서 설계되었기에 디버깅 과정도 B 구현에 비해 더 간단하다.
3. 추가적인 조건을 분기해야 하는 경우, A 구현에서는 'when' 구문으로 전환하여 추가적인 분기를 쉽게 추가할 수 있다.
   반면, B 구현은 이와 같은 변경이 매우 어려워, 코드를 전면적으로 다시 작성해야 할 수 있다.
4. 'if' 블록에 추가적인 구현이 필요한 경우, A 구현의 변경이 더 용이하다.
   반면, B 구현의 경우에 '함수 참조' 사용이 불가능하며, 엘비스 연산자의 오른쪽 항에 특정 함수('run')를 사용 해야한다.

```kotlin
if (person != null && person.isAdult) {
    view.showPerson(person)
    view.hideProgressWithSuccess()
} else {
    view.showError()
    view.hideProgressBar()
}

person?.takeIf { it.isAdult }
  ?.let {
    view.showPerson(it)
    view.hideProgressWithSuccess()
  } ?: run {
    view.showError()
    view.hideProgressBar()
  }
```

5. B 구현의 경우 'showPerson'이 'null'을 반환하는 경우에 'let' 함수가 결과를 반환함으로, 'showError'가 호출될 수 있어 원하지 않는 동작이 실행될 수 있고, 이런 원하지 않는 상황들이 코드 리뷰나 디버깅 시 쉽게 간과될 수 있다.

## Do not get extreme

그럼에도, 'let'은 다양한 상황에서 합리적으로 코드를 간결하게 만들 수 있는 인기 있는 구문이다.

예를 들어, 'Nullable 가변 프로퍼티'가 'Non-Null'일 때 어떤 연산을 실행해야 상황에서 가변 프로퍼티는 다른 스레드에 의해 변경될 수 있기에 'smart-casting'이 불가능하다.
이 때 'Safe-call'과 'let'을 함께 사용하여 해당 상황을 간결하게 실행할 수 있다.

```kotlin
var name: String? = null

fun printName() {
    name?.let { println(it) }
}
```

추가적으로 'let'은 아래와 같은 상황에서 코드를 간결하게 만들 수 있다.

1. 'Argument'에 대한 계산을 끝낸 후, 특정 연산을 수행하고 싶은 경우

```kotlin
students
    .filter { it.pointesInSemester > 15 && it.result >= 50 }
    .sortedWith(compareBy({ it.surname }, { it.name }))
    .joinToString(separator = "\n") { "${it.surname} ${it.name}, ${it.result}" }
    .let(::print)
```

2. 객체를 Decorator 패턴으로 래핑하고 싶은 경우

```kotlin
val obj = FileInputStream("/file.gz")
  .let(::BufferedInputStream)
  .let(::ZipInputStream)
  .let(::ObjectInputStream)
  .readObject() as SomeObject
```

위와 같은 코드들은 디버깅이 어렵고, Kotlin 경험이 부족한 개발자들이 이해하기에 어려운 코드일 수 있다.
하지만, Kotlin에 익숙한 개발자들은 이런 기능과 구조가 가독성이 높고, 프로그램 동작 원리를 더 빠르게 이해할 수 있다.

이처럼 코드 복잡성과 가독성 사이의 균형은 개발자가 설계할 때 항상 고려해야하는 부분이다.
복잡성을 도입하는 것은 코드 이해와 유지 관리를 어렵게 만들 수 있지만, 동시에 특정 상황에서 코드 효율성과 표현력을 높일 수 있다.
따라서 복잡한 구조를 사용하는 것은 개발자 판단에 달렸으며, 항상 합리적인 이유를 가지고 사용해야 한다.

## Convention

위에서 'Readability'는 개발자 경험에 따라 다를 수 있음을 확인하였고, 이러한 차이를 최소화하기 위해 'Convention'을 정하여 이를 따르는 것이 좋다.

아래는 Kotlin에서 좋지 않은 'Convention'을 사용한 예시이다.

```kotlin
operator fun String.invoke(f: ()-> String): String = this + f()
infix fun String.and(s:String) = this + s

val abc = "A" { "B" } and "C"
print(abc) // ABC
```

위와 같은 코드는 다음과 같은 'Convention'을 위반한다.

- 'invoke' 연산자는 객체를 함수처럼 호출하는 연산자로써, 문자열에서 이 연산자를 사용하는 것은 맥락에 맞지 않다.
- 함수 마지막 'Argument'가 'lambda expressions'인 경우, 괄호 밖에 람다를 작성할 수 있는 문법적 편의를 제공하는데, 위 코드에서는 'invoke'와 함께 사용되어 의도가 명확하지 않고 혼란을 줄 수 있다.
- 'and'라는 이름의 의미가 명확하지 않으며 기능을 직관적으로 이해하기 어렵다. 'append' or 'plus'와 같이 더 명확한 이름을 통해 메서드의 의도와 기능을 명확하게 표현할 수 있었을 것이다.
- 문자열 연결에 관한 기능은 이미 언어에서 제공하기에 새로운 방법을 만들기 보단, 기존의 방법을 사용하는 것이 좋다.

---

# Item 12 : Operator meaning should be consistent with its function name

'Operator overloading'은 Kotlin의 강력한 기능 중 하나로, 특정 객체의 연산자 동작 방식을 재정의하는 기법이다.  
그러나, Kotlin에서 각 연산자는 구체적인 의미를 가지고 있기에, 어떤 라이브러리를 처음 사용할 때도 해당 함수와 클래스 안의 연산자 의미를 쉽게 이해할 수 있는 장점을 갖는다.  
예를 들어, `x + y == z`라는 표현식은 `x.plus(y).equals(z)`와 동일하다는 것을 바로 알 수 있고, `plus`가 'Nullable 타입'이라면 `x.plus(y))?.equals(z) ?: (z == null)`과 같음을 바로 알 수 있다.

이처럼 Kotlin에서 각 연산자는 항상 일정한 의미를 갖도록 하는 것이 중요한 설계 원칙 중 하나이기에, 'Operator overloading'을 사용하는 것은 지향하는 것이 좋다.  
만약 이런 'Convention'을 지키지 않고, 'Operator'를 '특정 컨텍스트' 또는 '수학적 이론의 의미'로 'Overloading' 한다면, 함수와 클래스의 이름에 명확한 의미가 존재하여도 내부 코드를 이해하는데 어려움을 겪을 수 있다.

## Unclear cases

가장 큰 문제점은 특정 기능이나 문법을 사용할 때, 해당 사용법이 'Convention'을 따르고 있는지 불분명할 때 이다.

예를 들어 "함수를 3배로 확장한다."는 것을 정확하게 어떤 의미로 생각하는지 사람들에게 물어보면 다음과 같이 나뉠 것이다.

- 주어진 함수를 3번 '반복 실행'하는 새로운 함수를 만든다.
- 주어진 함수를 3번 '호출'하는 새로운 함수를 만든다.

이처럼 의미가 명확하지 않는 경우, 확장 함수의 이름을 더 명시적으로 설명하듯 작성하는 것이 좋다.  
추가로, 함수 사용을 연산자처럼 유지하고 싶으면 'infix function'으로 정의하여 사용할 수 있다.

```kotlin
infix fun Int.timesRepeated(operation: () -> Unit) = {
    repeat(this) { operation() }
}

val tripledHello = 3 timesRepeated { print("Hello") }
tripledHello() // HelloHelloHello
```

그럼에도, 이미 표준 라이브러리에서 구현되어 제공되고 있다면, 제공되는 함수를 사용하는 것이 더 바람직하다.

```kotlin
repeat(3) { println("Hello") } // HelloHelloHello
```

## When is it fine to break this rule

'DSL'을 설계하는 상황에서는 연산자 오버로딩을 특이하게 사용하는 것이 허용된다.

```kotlin
body {
    div {
        + "Some text"
    }
}
```

이런 사용법은 'DSL'의 일부이기에 허용되는 접근 방식이다.

---

# Item 13: Avoid returning or operating on Unit?

'Unit?'은 'Unit' or 'null' 두 가지 상태를 가질 수 있으며, 
이는 'Boolean'과 같은 동치성을 갖기에 'Unit?'과 'Boolean'을 비슷하게 사용 할 우려가 있다.

만약 'Unit?'을 논리적인 값으로 사용하면, 코드를 이해하는데 혼란을 줄 수 있고, 발견하기 어려운 오류로 번질 수 있다.

```kotlin
getData()?.let { view.showData(it) } ?: view.showError()
```

위 코드를 보면, 보통의 개발자들은 'getData' 실행 후, 'showData' or 'showError' 중 하나만 실행하도록 예상하여 구현할 것이다.  
하지만, 'showData'에서 'null'이 반환되면 'showData'와 'showError'가 모두 호출된다.

이처럼 'Unit?' + 'Elvis 연산' + 'Safe-call'을 사용하는 경우 의도치 않은 결과를 초래할 수 있고, 가독성까지 떨어뜨릴 수 있다.  
이를 피하기 위해 표준적인 'if-else' 구문을 사용하여 더 명확한 결과를 얻을 수 있고, 가독성까지 향상시킬 수 있다.

```kotlin
val person: Person? = getPerson()

if (person != null) {
    view.shoePerson(person)
} else {
    view.showError()
}
```

또한 아래 두 표현은 기능적으로 유사하지만, 가독성과 명확성 측면에서 차이가 있다.

```kotlin
fun keyIsCorrect(key: String): Boolean = // ...
if (!keyIsCorrect(key)) return
```

위 코드는 'Boolean'으로 논리적 조건을 명확하게 표현하며, 키 값이 올바른지 직접적으로 검사하고, 그 결과에 따라 동작을 수행한다.  
그리고, 'if'문은 프로그래밍에서 널리 사용되는 조건 처리 방식으로 대부분의 개발자들에게 익숙하며 직관적임을 알 수 있다.

```kotlin
fun verifyKey(key: String): Unit? = // ...
verifyKey(key) ?: return
```

반면, 위 코드는 일반적인 'Boolean' 조건문 보다 덜 직관적이고, 'Unit?'의 의미와 사용법에 익숙하지 않은 개발자들은 이해하는데 어려움을 겪을 수 있다. 

이처럼 'Unit?'은 가독성 향상에 있어 좋은 옵션이라고 볼 수 있는 사례가 거의 없으며, 혼란을 줄 수 있기에 'Boolean'으로 대체하는 것이 좋다. 

---

# Item 14 : Specify the variable type when it is not clear

Kotlin은 타입이 명확한 경우에 타입 명시를 생략할 수 있는 '타입 추론 시스템'을 지원한다.  
이처럼 문맥상 타입이 명확한 경우, 'inferred type'을 통해 코드를 깔끔하게하여 가독성을 높이고, 더 빠르게 작성할 수 있도록 해준다.

그러나 타입이 명확하지 않은 경우, 타입 명시를 생략하는 것은 아래와 같은 문제가 발생한다.

함수 리턴 타입이 생략된 A 함수가 있고, B 함수 내에서 A 함수의 리턴 타입을 추론하고 있다면, 
해당 A 함수의 리턴 타입을 확인하기 위해 타입을 추적하는 상황이 발생하게 되어, 불필요한 비용이 발생하게 된다.

또한, Github 환경에서 코드 리뷰 중, 타입 명시가 되어 있지 않는 코드가 있다면, 리뷰어는 해당 코드의 타입을 추론해야 한다.   
가뜩이나 Github 환경은 함수의 구현점으로 '점프' 할 수 있는 기능을 지원하지 않기에 더욱 시간이 소요된다.

이처럼 타입 명시는 중요한 역할을 하므로, 명확하지 않다면 반드시 명시되어야 한다.  
또한 타입 명시는 코드 안전성과 유지보수성을 높이는데 도움이 된다.

- 타입 명시는 API 사용자에게 필요한 타입을 명확하게 제공 할 수 있도록 한다.
- 컴파일러가 더 엄격한 타입 검사를 수행하여 런타임 오류 가능성을 줄일 수 있다.
- 코드의 의도를 더 명확하게 표현하여 가독성과 이해도를 높일 수 있다.


---

# Item 15 : Consider referencing receivers explicitly

리시버 객체로부터 프로퍼티 또는 함수를 호출한 것으로 명확하게 표현하고 싶을 때, 'this' 키워드를 통해 명시적으로 참조할 수 있다.
또한 'Extension receiver' 사용 시, 'this' 키워드를 통해 명시적으로 참조하여 가독성을 높일 수 있다.

```kotlin
class User: Person() {
   private var beersDrunk: Int = 0

   fun drinkBeers(num: Int) {
      this.beersDrunk += num  // 명시적으로 리시버 참조
   }
}

fun <T: Comparable<T>> List<T>.quickSort(): List<T> {
    if (size < 2) return this
    val pivot = this.first()  // 명시적으로 리시버 참조
    val (smaller, bigger) = this.drop(1).partition { it < pivot } // 명시적으로 리시버 참조
    return smaller.quickSort() + pivot + bigger.quickSort()
}
```

## Many receivers

하나의 코드 블록 내에서 여러 리시버에 대한 접근이 필요할 때, 각 리시버 객체를 명시적으로 구분하지 않으면 어떤 객체의 메서드나 프로퍼티에 접근하는지 구분하기 어려워진다.
특히, 'apply', 'with', 'run', 'also'와 같은 'Scope function'을 사용할 때 더 구분하기 어려워진다.

'Scope function' 내부에서 'this'는 'Scope function'을 호출한 객체를 참조하게 되는데, 
만약 'Scope function'이 중첩되어 사용되면 'this'가 어떤 객체를 참조하는지 명확하지 않아 코드를 이해하는데 어려움을 줄 수 있다.

이런 경우 명시적으로 리시버를 참조하여 코드를 작성하면, 해당 코드의 의도를 더 명확하게 표현할 수 있다.  
아래 코드는 'also'를 통해 리시버를 명시적으로 사용하여 추가적인 작업을 하는 적절한 방법이다.

```kotlin
class Node(val name: String) {
    
    fun create(name: String): Node? = Node(name)
    
    fun makeChild(childName: String) =
        create("$name.$childName")
            .also { createNode -> print("Created ${createNode?.name}") }
}
```

추가로, 여러 수준의 리시버를 사용하는 경우, 'label'을 통해 명시적으로 리시버를 구분하여 참조할 수 있다.

아래 예시에서 'label'이 없는 리시버는 가장 가까운 'Scope function'의 리시버를 참조한다.   
반대로 외부 리시버에 접근이 필요한 경우, 'label'을 통해 명시적으로 리시버를 참조할 수 있다.

```kotlin
class Node(val name: String) {
    
    fun create(name: String): Node? = Node(name)
    
    fun makeChild(childName: String) =
        create("$name.$childName").apply { 
            print("Created ${this?.name} in ${this@Node.name}")
        }
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // Created parent.child in parent
}
```

이처럼, 명시적으로 리시버를 참조하면, 코드의 오류를 예방할 수 있고 가독성을 높일 수 있다.

---

# Item 16 : Property는 행동이 아닌 상태를 나타내야한다.

### 속성과 백업 필드
Kotlin의 속성(Property)은 데이터를 보유하는 방식이 Java의 필드(Field)와 비슷하며, 추가적으로 사용자 정의 `setter`와 `getter`를 제공합니다.  
컴파일러는 속성에 대한 `백업 필드`를 자동으로 생성하게 됩니다. 이 백업 필드는 `field` 키워드를 통해 접근할 수 있습니다.

### 파생 속성
파생 속성(Derived Properties)은 다른 속성이나 변수, 연산에 기반한 속성을 말합니다.   
이는 코드의 가독성을 향상시키고, 캡슐화를 쉽게하며, 데이터 타입의 변경에 쉽게 대응할 수 있게 합니다.

### 속성 사용 주의점
속성 접근자는 속성에 접근하는 함수로, 이를 통해 속성을 재정의하거나 다른 객체에게 위임할 수 있습니다.   
하지만, 속성은 알고리즘적인 행동을 나타내는 데 사용되어서는 안되며, 복잡한 로직이나 계산이 포함되어서도 안됩니다.

또한 **속성 사용을 피해야하는** 몇가지 상황은 다음과 같습니다.
- 비용이 많이 드는 연산을 수행해야 하는 상황
- 비지니스 로직이 포함되어 있는 상황
- 결과가 변하는 상황
- 실생순서가 중요한 로직을 수행하는 상황
- 형변환이 필요한 상황
- Getter가 상태를 변경하는 상황


# Item 17 : 명명된 인수 활용 가이드

### 명명된 인수(named Arguments)의 중요성
코드를 작성하거나 읽을 때, 인수의 역할이 불분명할 수 있습니다. 
Kotlin에서는 이를 명명된 인수(named arguments)를 사용해 해결할 수 있습니다. 
명명된 인수는 값의 의미를 명확히 표현하고, 인수의 순서에 독립적으로 안전하게 코드를 작성할 수 있게 합니다.

### 명명된 인수 활용
기본값을 가진 인수, 같은 타입의 인수, 함수가 아닌 타입이면서 마지막 매개변수가 아닌 경우에는 명명된 인수를 사용하는 것이 바람직합니다.
이는 코드의 안정성을 보장하고, 잘못된 인수의 배치나 순서 변경으로 인한 문제를 방지해줍니다.

함수형 매개변수의 경우, 혼동을 줄이기 위해 이름을 붙이는 것이 좋습니다. 마지막에 위치한 함수형 매개변수만이 이름 없이 사용될 수 있으며, 그 외에는 이름을 붙여서 사용해야 합니다.

따라서, 명명된 인수의 사용은 코드의 명확성, 안전성, 신뢰성을 높일 수 있습니다.


# Item 18 : Coding Convention 준수

### Coding Convention 이해와 적용: 효율적인 코드 가독성과 협업
Kotlin의 Coding Convention은 코드 이해도 향상과 효율적인 협업을 가능하게 합니다.   
이는 프로젝트 간 이동을 용이하게 하며, 코드의 작동 방식을 추론하는 데 도움이 됩니다. 이러한 규칙을 준수하면 외부 개발자도 코드를 쉽게 읽을 수 있습니다.

### 클래스와 함수의 포맷팅 규칙
클래스와 함수의 매개변수를 적절하게 줄 바꿈하여 표현하는 것이 중요합니다. 이는 코드의 일관성을 유지하고, 가독성을 높이는 데 도움이 됩니다.   
들여쓰기의 불일관성과 코드 가독성 저하를 방지하기 위해, Kotlin Coding Convention에 따라 첫 번째 매개변수를 같은 줄에 두는 것을 피해야 합니다.