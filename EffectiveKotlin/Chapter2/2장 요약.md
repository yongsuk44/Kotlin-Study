# Item 11 : Design for readability

개발자들은 오류를 찾기 위해 코드를 추적하고 읽는 시간과 새로운 API의 로직과 구현 방법을 이해하기 위해 코드를 읽는 시간을 생각해보면,
프로그래밍은 주로 코드를 작성하는 시간보다 코드를 읽는 시간이 더 많다는 것을 알 수 있다.
따라서 코드 작성 시, 'Readability'를 고려하여 명확하게 코드를 작성하는 것이 중요하다.

## Reducing cognitive load

'Readability'는 개발자마다 다르게 해석될 수 있다. 아래 예시를 보자.

```kotlin
// impl A
if (person != null && person.isAdult) {
    view.showPerson(person)
} else {
    view.showError()
}

// impl B
person?.takeIf { it.isAdult }
    ?.let(view::showPerson)
    ?: view.showError()
```

경험이 적은 Kotlin 개발자는 A 구현이 훨씬 더 읽기 쉬울 것이고, 경험이 많은 Kotlin 개발자들은 B 구현이 더 익숙할 수 있다.
이처럼 두 구현의 'Readability'는 개발자들이 구문을 인식하고 이해하는데 얼마나 훈련되어 있는지에 따라 달라진다.

'Readability' 관점에서는 A 구현이 더 장점이 많으며, 그 이유는 아래와 같다.

1. 프로젝트 협업 시, 주니어 개발자는 B 구현을 이해하는데 비효율적인 시간을 보낼 수 있으며, Kotlin을 오랫동안 사용했더라도 일반적으로 사용되는 A 구현을 이해하는 것이 더 쉽다.
2.  디버깅 도구는 A 구현과 같이 기본적인 구조에 맞춰서 설계되었기에 디버깅 과정도 B 구현에 비해 더 간단하다.
3. 추가적인 조건을 분기해야 하는 경우, A 구현에서는 'when' 구문으로 전환하여 추가적인 분기를 쉽게 추가할 수 있다.
   반면, B 구현은 이와 같은 변경이 매우 어려워, 코드를 전면적으로 다시 작성해야 할 수 있다.
4. 'if' 블록에 추가적인 구현이 필요한 경우, A 구현의 변경이 더 용이하다.
   반면, B 구현의 경우에 '함수 참조' 사용이 불가능하며, 엘비스 연산자의 오른쪽 항에 특정 함수('run')를 사용 해야한다.

```kotlin
if (person != null && person.isAdult) {
    view.showPerson(person)
    view.hideProgressWithSuccess()
} else {
    view.showError()
    view.hideProgressBar()
}

person?.takeIf { it.isAdult }
  ?.let {
    view.showPerson(it)
    view.hideProgressWithSuccess()
  } ?: run {
    view.showError()
    view.hideProgressBar()
  }
```

5. B 구현의 경우 'showPerson'이 'null'을 반환하는 경우에 'let' 함수가 결과를 반환함으로, 'showError'가 호출될 수 있어 원하지 않는 동작이 실행될 수 있고, 이런 원하지 않는 상황들이 코드 리뷰나 디버깅 시 쉽게 간과될 수 있다.

## Do not get extreme

그럼에도, 'let'은 다양한 상황에서 합리적으로 코드를 간결하게 만들 수 있는 인기 있는 구문이다.

예를 들어, 'Nullable 가변 프로퍼티'가 'Non-Null'일 때 어떤 연산을 실행해야 상황에서 가변 프로퍼티는 다른 스레드에 의해 변경될 수 있기에 'smart-casting'이 불가능하다.
이 때 'Safe-call'과 'let'을 함께 사용하여 해당 상황을 간결하게 실행할 수 있다.

```kotlin
var name: String? = null

fun printName() {
    name?.let { println(it) }
}
```

추가적으로 'let'은 아래와 같은 상황에서 코드를 간결하게 만들 수 있다.

1. 'Argument'에 대한 계산을 끝낸 후, 특정 연산을 수행하고 싶은 경우

```kotlin
students
    .filter { it.pointesInSemester > 15 && it.result >= 50 }
    .sortedWith(compareBy({ it.surname }, { it.name }))
    .joinToString(separator = "\n") { "${it.surname} ${it.name}, ${it.result}" }
    .let(::print)
```

2. 객체를 Decorator 패턴으로 래핑하고 싶은 경우

```kotlin
val obj = FileInputStream("/file.gz")
  .let(::BufferedInputStream)
  .let(::ZipInputStream)
  .let(::ObjectInputStream)
  .readObject() as SomeObject
```

위와 같은 코드들은 디버깅이 어렵고, Kotlin 경험이 부족한 개발자들이 이해하기에 어려운 코드일 수 있다.
하지만, Kotlin에 익숙한 개발자들은 이런 기능과 구조가 가독성이 높고, 프로그램 동작 원리를 더 빠르게 이해할 수 있다.

이처럼 코드 복잡성과 가독성 사이의 균형은 개발자가 설계할 때 항상 고려해야하는 부분이다.
복잡성을 도입하는 것은 코드 이해와 유지 관리를 어렵게 만들 수 있지만, 동시에 특정 상황에서 코드 효율성과 표현력을 높일 수 있다.
따라서 복잡한 구조를 사용하는 것은 개발자 판단에 달렸으며, 항상 합리적인 이유를 가지고 사용해야 한다.

## Convention

위에서 'Readability'는 개발자 경험에 따라 다를 수 있음을 확인하였고, 이러한 차이를 최소화하기 위해 'Convention'을 정하여 이를 따르는 것이 좋다.

아래는 Kotlin에서 좋지 않은 'Convention'을 사용한 예시이다.

```kotlin
operator fun String.invoke(f: ()-> String): String = this + f()
infix fun String.and(s:String) = this + s

val abc = "A" { "B" } and "C"
print(abc) // ABC
```

위와 같은 코드는 다음과 같은 'Convention'을 위반한다.

- 'invoke' 연산자는 객체를 함수처럼 호출하는 연산자로써, 문자열에서 이 연산자를 사용하는 것은 맥락에 맞지 않다.
- 함수 마지막 'Argument'가 'lambda expressions'인 경우, 괄호 밖에 람다를 작성할 수 있는 문법적 편의를 제공하는데, 위 코드에서는 'invoke'와 함께 사용되어 의도가 명확하지 않고 혼란을 줄 수 있다.
- 'and'라는 이름의 의미가 명확하지 않으며 기능을 직관적으로 이해하기 어렵다. 'append' or 'plus'와 같이 더 명확한 이름을 통해 메서드의 의도와 기능을 명확하게 표현할 수 있었을 것이다.
- 문자열 연결에 관한 기능은 이미 언어에서 제공하기에 새로운 방법을 만들기 보단, 기존의 방법을 사용하는 것이 좋다.

---

# Item 12 : Operator meaning should be consistent with its function name

'Operator overloading'은 Kotlin의 강력한 기능 중 하나로, 특정 객체의 연산자 동작 방식을 재정의하는 기법이다.  
그러나, Kotlin에서 각 연산자는 구체적인 의미를 가지고 있기에, 어떤 라이브러리를 처음 사용할 때도 해당 함수와 클래스 안의 연산자 의미를 쉽게 이해할 수 있는 장점을 갖는다.  
예를 들어, `x + y == z`라는 표현식은 `x.plus(y).equals(z)`와 동일하다는 것을 바로 알 수 있고, `plus`가 'Nullable 타입'이라면 `x.plus(y))?.equals(z) ?: (z == null)`과 같음을 바로 알 수 있다.

이처럼 Kotlin에서 각 연산자는 항상 일정한 의미를 갖도록 하는 것이 중요한 설계 원칙 중 하나이기에, 'Operator overloading'을 사용하는 것은 지향하는 것이 좋다.  
만약 이런 'Convention'을 지키지 않고, 'Operator'를 '특정 컨텍스트' 또는 '수학적 이론의 의미'로 'Overloading' 한다면, 함수와 클래스의 이름에 명확한 의미가 존재하여도 내부 코드를 이해하는데 어려움을 겪을 수 있다.

## Unclear cases

가장 큰 문제점은 특정 기능이나 문법을 사용할 때, 해당 사용법이 'Convention'을 따르고 있는지 불분명할 때 이다.

예를 들어 "함수를 3배로 확장한다."는 것을 정확하게 어떤 의미로 생각하는지 사람들에게 물어보면 다음과 같이 나뉠 것이다.

- 주어진 함수를 3번 '반복 실행'하는 새로운 함수를 만든다.
- 주어진 함수를 3번 '호출'하는 새로운 함수를 만든다.

이처럼 의미가 명확하지 않는 경우, 확장 함수의 이름을 더 명시적으로 설명하듯 작성하는 것이 좋다.  
추가로, 함수 사용을 연산자처럼 유지하고 싶으면 'infix function'으로 정의하여 사용할 수 있다.

```kotlin
infix fun Int.timesRepeated(operation: () -> Unit) = {
    repeat(this) { operation() }
}

val tripledHello = 3 timesRepeated { print("Hello") }
tripledHello() // HelloHelloHello
```

그럼에도, 이미 표준 라이브러리에서 구현되어 제공되고 있다면, 제공되는 함수를 사용하는 것이 더 바람직하다.

```kotlin
repeat(3) { println("Hello") } // HelloHelloHello
```

## When is it fine to break this rule

'DSL'을 설계하는 상황에서는 연산자 오버로딩을 특이하게 사용하는 것이 허용된다.

```kotlin
body {
    div {
        + "Some text"
    }
}
```

이런 사용법은 'DSL'의 일부이기에 허용되는 접근 방식이다.

---

# Item 13: Avoid returning or operating on Unit?

'Unit?'은 'Unit' or 'null' 두 가지 상태를 가질 수 있으며, 
이는 'Boolean'과 같은 동치성을 갖기에 'Unit?'과 'Boolean'을 비슷하게 사용 할 우려가 있다.

만약 'Unit?'을 논리적인 값으로 사용하면, 코드를 이해하는데 혼란을 줄 수 있고, 발견하기 어려운 오류로 번질 수 있다.

```kotlin
getData()?.let { view.showData(it) } ?: view.showError()
```

위 코드를 보면, 보통의 개발자들은 'getData' 실행 후, 'showData' or 'showError' 중 하나만 실행하도록 예상하여 구현할 것이다.  
하지만, 'showData'에서 'null'이 반환되면 'showData'와 'showError'가 모두 호출된다.

이처럼 'Unit?' + 'Elvis 연산' + 'Safe-call'을 사용하는 경우 의도치 않은 결과를 초래할 수 있고, 가독성까지 떨어뜨릴 수 있다.  
이를 피하기 위해 표준적인 'if-else' 구문을 사용하여 더 명확한 결과를 얻을 수 있고, 가독성까지 향상시킬 수 있다.

```kotlin
val person: Person? = getPerson()

if (person != null) {
    view.shoePerson(person)
} else {
    view.showError()
}
```

또한 아래 두 표현은 기능적으로 유사하지만, 가독성과 명확성 측면에서 차이가 있다.

```kotlin
fun keyIsCorrect(key: String): Boolean = // ...
if (!keyIsCorrect(key)) return
```

위 코드는 'Boolean'으로 논리적 조건을 명확하게 표현하며, 키 값이 올바른지 직접적으로 검사하고, 그 결과에 따라 동작을 수행한다.  
그리고, 'if'문은 프로그래밍에서 널리 사용되는 조건 처리 방식으로 대부분의 개발자들에게 익숙하며 직관적임을 알 수 있다.

```kotlin
fun verifyKey(key: String): Unit? = // ...
verifyKey(key) ?: return
```

반면, 위 코드는 일반적인 'Boolean' 조건문 보다 덜 직관적이고, 'Unit?'의 의미와 사용법에 익숙하지 않은 개발자들은 이해하는데 어려움을 겪을 수 있다. 

이처럼 'Unit?'은 가독성 향상에 있어 좋은 옵션이라고 볼 수 있는 사례가 거의 없으며, 혼란을 줄 수 있기에 'Boolean'으로 대체하는 것이 좋다. 

---

# Item 14 : Specify the variable type when it is not clear

Kotlin은 타입이 명확한 경우에 타입 명시를 생략할 수 있는 '타입 추론 시스템'을 지원한다.  
이처럼 문맥상 타입이 명확한 경우, 'inferred type'을 통해 코드를 깔끔하게하여 가독성을 높이고, 더 빠르게 작성할 수 있도록 해준다.

그러나 타입이 명확하지 않은 경우, 타입 명시를 생략하는 것은 아래와 같은 문제가 발생한다.

함수 리턴 타입이 생략된 A 함수가 있고, B 함수 내에서 A 함수의 리턴 타입을 추론하고 있다면, 
해당 A 함수의 리턴 타입을 확인하기 위해 타입을 추적하는 상황이 발생하게 되어, 불필요한 비용이 발생하게 된다.

또한, Github 환경에서 코드 리뷰 중, 타입 명시가 되어 있지 않는 코드가 있다면, 리뷰어는 해당 코드의 타입을 추론해야 한다.   
가뜩이나 Github 환경은 함수의 구현점으로 '점프' 할 수 있는 기능을 지원하지 않기에 더욱 시간이 소요된다.

이처럼 타입 명시는 중요한 역할을 하므로, 명확하지 않다면 반드시 명시되어야 한다.  
또한 타입 명시는 코드 안전성과 유지보수성을 높이는데 도움이 된다.

- 타입 명시는 API 사용자에게 필요한 타입을 명확하게 제공 할 수 있도록 한다.
- 컴파일러가 더 엄격한 타입 검사를 수행하여 런타임 오류 가능성을 줄일 수 있다.
- 코드의 의도를 더 명확하게 표현하여 가독성과 이해도를 높일 수 있다.


---

# Item 15 : Consider referencing receivers explicitly

리시버 객체로부터 프로퍼티 또는 함수를 호출한 것으로 명확하게 표현하고 싶을 때, 'this' 키워드를 통해 명시적으로 참조할 수 있다.
또한 'Extension receiver' 사용 시, 'this' 키워드를 통해 명시적으로 참조하여 가독성을 높일 수 있다.

```kotlin
class User: Person() {
   private var beersDrunk: Int = 0

   fun drinkBeers(num: Int) {
      this.beersDrunk += num  // 명시적으로 리시버 참조
   }
}

fun <T: Comparable<T>> List<T>.quickSort(): List<T> {
    if (size < 2) return this
    val pivot = this.first()  // 명시적으로 리시버 참조
    val (smaller, bigger) = this.drop(1).partition { it < pivot } // 명시적으로 리시버 참조
    return smaller.quickSort() + pivot + bigger.quickSort()
}
```

## Many receivers

하나의 코드 블록 내에서 여러 리시버에 대한 접근이 필요할 때, 각 리시버 객체를 명시적으로 구분하지 않으면 어떤 객체의 메서드나 프로퍼티에 접근하는지 구분하기 어려워진다.
특히, 'apply', 'with', 'run', 'also'와 같은 'Scope function'을 사용할 때 더 구분하기 어려워진다.

'Scope function' 내부에서 'this'는 'Scope function'을 호출한 객체를 참조하게 되는데, 
만약 'Scope function'이 중첩되어 사용되면 'this'가 어떤 객체를 참조하는지 명확하지 않아 코드를 이해하는데 어려움을 줄 수 있다.

이런 경우 명시적으로 리시버를 참조하여 코드를 작성하면, 해당 코드의 의도를 더 명확하게 표현할 수 있다.  
아래 코드는 'also'를 통해 리시버를 명시적으로 사용하여 추가적인 작업을 하는 적절한 방법이다.

```kotlin
class Node(val name: String) {
    
    fun create(name: String): Node? = Node(name)
    
    fun makeChild(childName: String) =
        create("$name.$childName")
            .also { createNode -> print("Created ${createNode?.name}") }
}
```

추가로, 여러 수준의 리시버를 사용하는 경우, 'label'을 통해 명시적으로 리시버를 구분하여 참조할 수 있다.

아래 예시에서 'label'이 없는 리시버는 가장 가까운 'Scope function'의 리시버를 참조한다.   
반대로 외부 리시버에 접근이 필요한 경우, 'label'을 통해 명시적으로 리시버를 참조할 수 있다.

```kotlin
class Node(val name: String) {
    
    fun create(name: String): Node? = Node(name)
    
    fun makeChild(childName: String) =
        create("$name.$childName").apply { 
            print("Created ${this?.name} in ${this@Node.name}")
        }
}

fun main(){
    val node = Node("parent") 
    node.makeChild("child") // Created parent.child in parent
}
```

이처럼, 명시적으로 리시버를 참조하면, 코드의 오류를 예방할 수 있고 가독성을 높일 수 있다.

---

# Item 16 : Properties should represent state, not behavior

Kotlin 프로퍼티는 'getter•setter'를 통해 데이터를 읽고 쓰는 기능을 제공하며, 다음과 같이 사용할 수 있다.

```kotlin
var name: String? = null
    get() = field?.uppercase()
    set(value) {
        if (!value.isNullOrBlank()) {
            field = value
        }
    }
```

위 코드에서 'setter'에 'field' 식별자를 사용하는데, 이는 프로퍼티 값을 저장할 수 있게 해주는 'Backing field'를 참조한다.

'Backing field'는 프로퍼티 값을 저장하기 위해 숨겨진 필드로, 'getter•setter'가 값에 접근할 때 Kotlin 컴파일러가 자동으로 생성한다.
만약, 'getter•setter'가 'field' 식별자를 사용하지 않으면 'Backing field'는 생성되지 않는다.  
즉, 프로퍼티가 직접 값을 저장하지 않고, 다른 방식으로 값을 제공하거나 계산되어 사용됨을 의미한다.

```kotlin
val fullName: String
    get() = "$firstName $lastName"

var dateVariable: Date
    get() = Date(millis)
    set(value) {
        millis = value.time
    }
```

위와 같이 프로퍼티가 다른 방식으로 값을 제공하거나 계산되어 사용될 때, 이를 'Derived properties'라고 한다.  
이 'Derived properties'는 Kotlin에서 모든 프로퍼티가 기본적으로 '**캡슐화**'되는 주된 이유 이다.

예를 들어, 어떤 객체에서 'Date' 타입을 사용하여 날짜를 저장하고 있다가, 직렬화의 이유로 더 이상 'Date' 타입을 사용할 수 없는 상황이 발생했다.

Java의 경우 Date 타입의 프로퍼티를 참조하는 코드를 수정해야하는 문제에 직면하게 된다.  

하지만, Kotlin에서는 'Date' 타입을 'Derived properties'로 사용하고, 실제 날짜 데이터를 'Long' 타입의 'dateInMillis'에 저장하여,
직렬화 시 'dateInMillis'를 사용하도록 코드 수정을 최소화해 새로운 요구사항을 수용할 수 있다.

```kotlin
class Article {
    private var dateInMillis: Long = System.currentTimeMillis()
    
    val date: Date
       get() = Date(dateInMillis)
}
```

이처럼 'Derived properties'는 내부적으로는 다른 프로퍼티나 상태에 기반한 값을 제공할 수 있고, 외부에서는 단순히 프로퍼티에 접근하여 값을 얻을 수 있다.
이는 내부 상태를 숨기고 외부에서는 객체와 상호작용 할 수 있는 제한된 인터페이스(getter)만 제공함으로써 캡슐화 원칙을 준수한다고 볼 수 있다.

이처럼, 모든 프로퍼티가 'Backing field'를 갖는 것은 아니며, 'Backing field'가 없는 프로퍼티는 **데이터에 접근하는 방법**으로 사용된다.  
이러한 특성으로 인해, 상태를 저장할 수 없는 인터페이스에서도 프로퍼티를 사용할 수 있게 되었다.

아래와 같이 인터페이스 내에 선언된 프로퍼티는 구현 클래스가 해당 프로퍼티의 'getter'를 구현해야 함을 명시하는 'contract 역할'을 한다.

```kotlin
interface Person {
    val name: String
}
```

추가로, 위와 동일한 이유로 프로퍼티를 'override' 하거나, 'delegation' 할 수 있다.

```kotlin
// e.g : override
open class SuperComputer {
    open val theAnswer: Long = 42
}

class AppleComputer: Supercomputer() {
    override val theAnswer: Long = 1_800_275_2275
}

// e.g : delegate pattern
val db: DataBase by lazy { connectToDb() }
```

앞서 프로퍼티에 접근 시, 'setter•getter'가 호출됨을 알 수 있고, 이는 결국 프로퍼티 접근이 함수 호출로 이루어짐을 알 수 있다.  
이처럼, '**프로퍼티에 대한 접근은 함수 호출**'로 볼 수 있으며, 이 점을 고려하여 아래와 같이 'Extension properties'를 사용할 수 있다.

```kotlin
val Context.preferences: SharedPreferences
    get() = PreferenceManager.getDefaultSharedPreferences(this)

val Context.notificationManager: NotificationManager
   get() = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
```

프로퍼티에 대한 접근을 함수 호출로 볼 수 있다면, 프로퍼티의 'setter•getter'는 특정 함수들을 대체하여 사용될 수 있음을 알 수 있다.  
하지만, 프로퍼티 사용의 일반적인 규칙은 **상태를 나타내거나 설정하는 것에만 한정**되어야 하고, 그 외의 로직은 포함되어선 안된다.

만약 프로퍼티와 함수 중 어떤 것으로 구현해야 하는지 고민이 된다면, 아래와 같은 기준에서는 **함수로 구현하는 것이 좋다.**

**1. '계산 복잡도 O(1)' 보다 높거나, 비용이 많이 드는 연산일 경우 :**  
함수는 명시적으로 개발자에게 비용이 많이 드는 연산임을 알려줄 수 있고, 캐싱을 고려하거나, 덜 사용하도록 유도할 수 있다.

**2. 비지니스 로직을 포함하는 경우 :**  
프로퍼티는 로깅, 리스너 알림, 바인딩된 요소의 업데이트 등 간단한 작업에 사용되어야 하며, 
그 이상의 복잡한 비지니스 로직은 함수로 정의하는 것이 좋다.

**3. 연속 호출 시, 다른 결과를 반환하는 경우 :**  
프로퍼티는 동일한 입력에 대해 항상 동일한 출력을 반환하는 것이 일반적인 원칙이다.  
만약, 어떤 프로퍼티의 값이 외부 상태에 의존하거나 내부 상태를 변경함으로써, 호출을 할 때마다 다른 결과를 반환한다면, 이는 프로퍼티 사용의 부적절한 사례이다.
이처럼 호출할 때마다 다른 결과를 반환하는 로직은 함수로 구현하는 것이 좋다.

**4. 실행 순서가 동작에 영향을 미치는 경우 :**  
프로퍼티 값이 설정되거나 조회되는 순서가 앱의 동작에 영향을 미치는 경우, 이 자체가 프로퍼티 사용의 부적절한 사례이다.  
프로퍼티는 독립적으로 동작하고, 'A 프로퍼티' 설정이 다른 'B 프로퍼티'의 동작에 직접적인 영향을 주지 않는 것이 기본 원칙이다.  
만약 실행 순서가 동작에 영향을 미치는 경우, 이는 함수로 구현하는 것이 좋다.

**5. 'Int.toDouble'과 같이 타입 변환이 필요한 경우 :**  
타입 변환은 객체 전체의 변환 또는 연산을 수행하는 과정이므로, 일반적으로 함수로 수행되는 것이 'Convention'이다.  
만약, 프로퍼티를 통해 타입 변환을 구현하게 되면, 이는 단순하게 객체 내부의 상태에 접근하는 것처럼 보일 수 있어 혼란을 줄 수 있다.  
이러한 이유로, 타입 변환은 함수로 구현하는 것이 좋다.

**6. 'getter'가 프로퍼티 상태를 변경하는 경우 :**  
프로퍼티의 'getter'는 현재 값을 조회하는 용도로 사용되어야 하며, 상태를 변경하거나 Side-effect를 발생시켜선 안된다.  
'getter'가 상태를 변경시키는 방식은 코드 가독성과 안정성, 캡슐화를 저해할 수 있으며, 이러한 경우에는 함수로 구현하는 것이 좋다.


---

# Item 17 : 명명된 인수 활용 가이드

### 명명된 인수(named Arguments)의 중요성
코드를 작성하거나 읽을 때, 인수의 역할이 불분명할 수 있습니다. 
Kotlin에서는 이를 명명된 인수(named arguments)를 사용해 해결할 수 있습니다. 
명명된 인수는 값의 의미를 명확히 표현하고, 인수의 순서에 독립적으로 안전하게 코드를 작성할 수 있게 합니다.

### 명명된 인수 활용
기본값을 가진 인수, 같은 타입의 인수, 함수가 아닌 타입이면서 마지막 매개변수가 아닌 경우에는 명명된 인수를 사용하는 것이 바람직합니다.
이는 코드의 안정성을 보장하고, 잘못된 인수의 배치나 순서 변경으로 인한 문제를 방지해줍니다.

함수형 매개변수의 경우, 혼동을 줄이기 위해 이름을 붙이는 것이 좋습니다. 마지막에 위치한 함수형 매개변수만이 이름 없이 사용될 수 있으며, 그 외에는 이름을 붙여서 사용해야 합니다.

따라서, 명명된 인수의 사용은 코드의 명확성, 안전성, 신뢰성을 높일 수 있습니다.


# Item 18 : Coding Convention 준수

### Coding Convention 이해와 적용: 효율적인 코드 가독성과 협업
Kotlin의 Coding Convention은 코드 이해도 향상과 효율적인 협업을 가능하게 합니다.   
이는 프로젝트 간 이동을 용이하게 하며, 코드의 작동 방식을 추론하는 데 도움이 됩니다. 이러한 규칙을 준수하면 외부 개발자도 코드를 쉽게 읽을 수 있습니다.

### 클래스와 함수의 포맷팅 규칙
클래스와 함수의 매개변수를 적절하게 줄 바꿈하여 표현하는 것이 중요합니다. 이는 코드의 일관성을 유지하고, 가독성을 높이는 데 도움이 됩니다.   
들여쓰기의 불일관성과 코드 가독성 저하를 방지하기 위해, Kotlin Coding Convention에 따라 첫 번째 매개변수를 같은 줄에 두는 것을 피해야 합니다.