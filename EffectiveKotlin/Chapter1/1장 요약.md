# 목차

- [Item 1 : Kotlin 불변성(Immutability) 권장](#item-1--kotlin-불변성immutability-권장)
- [Item 2 : 변수 스코프 최소화](#item-2--변수-스코프-최소화)
- [Item 3 : Kotlin Null-Safety 및 플랫폼 타입](#item-3--kotlin-null-safety-및-플랫폼-타입)
- [Item 4: Kotlin의 타입 추론과 적절한 사용법 이해](#item-4-kotlin의-타입-추론과-적절한-사용법-이해)
- [Itme 5 : Argument와 State에 대한 기대값을 명시](#itme-5--argument와-state에-대한-기대값을-명시)
- [Item 6 : 사용자 지정 오류보단 표준 오류 권장](#item-6--사용자-지정-오류보단-표준-오류-권장)
- [Item 7 : 무조건 적인 예외가 아닌 Null or Result<Failed>](#item-7--무조건-적인-예외가-아닌-null-or-resultfailed)
- [Item 8 : 안정적인 Null 처리](#item-8--안정적인-null-처리)
- [Item 9 : use()를 통한 리소스 관리](#item-9--use를-통한-리소스-관리)
- [Item 10 : 테스트의 중요성](#item-10--테스트의-중요성)

# Item 1 : Kotlin 불변성(Immutability) 권장

Kotlin 불변성은 프로퍼티나 객체의 상태를 변경할 수 없게 함으로써 코드의 안정성과 가독성을 높이는 것을 목표로 하고 있습니다.

### 불변성의 이점

| 장점               | 설명                                                  |
|------------------|-----------------------------------------------------|
| 코드 가독성 및 이해도의 향상 | 상태가 변경되지 않는다면 코드 동작 예측이 쉽고, 추론이 간단해집니다.             |
| 코드 신뢰성 향상        | 불변성을 유지하는 객체는 공유되어도 충돌이 발생하지 않으므로 병렬 프로그래밍이 간편해집니다. |
| 버그 예방 및 디버깅 용이   | 상태가 변경되지 않아 버그 발생 가능성이 줄고, 디버깅 시 객체 상태를 추적하기 쉽습니다.  |

그렇지만 모든 프로퍼티를 불변으로 선언하는 것은 현실적이지 않습니다.   
때로는 상태를 변경해야하는 상황이 발생할 수 있습니다. 이 경우에는 아래와 같이 가변성을 관리할 수 있습니다.

### 가변성의 관리 방법

| 방법                               | 설명                                                                                             |
|----------------------------------|------------------------------------------------------------------------------------------------|
| val 키워드 사용                       | - val 키워드를 사용하여 읽기 전용 속성으로 선언하면 재할당을 방지할 수 있습니다.  <br/> - 이를 통해 객체의 상태를 변경하지 않는 것을 보장할 수 있습니다. |
| data class의 copy 메서드 사용          | data class는 불변성 권장하는 클래스로, copy 메서드를 사용하여 객체의 상태를 변경하는 대신 복사본을 생성할 수 있습니다.                     |
| mutable, immutable collection 구분 | - 변경 가능한 목록 - mutable collection을 사용 <br/> - 읽기 전용 목록 - immutable collection을 사용               |

---

# Item 2 : 변수 스코프 최소화

### 스코프 최소화 방법

| 방법             | 설명                                                          |
|----------------|-------------------------------------------------------------|
| 반복문에서의 변수 선언   | 반복문에서만 사용하는 변수는 해당 반복문 내에서 선언합니다.                           |
| 변수 선언과 동시에 초기화 | 변수는 선언될 때 항상 초기화하는 것이 좋습니다.                                 |
| 구조 분해 선언을 활용   | 여러 속성을 설정할 경우, 구조 분해 선언(destructuring declarations)을 사용합니다. |
| 캡처링 주의         | 람다 본문 안에서 외부 변수를 사용할때에 주의해야 합니다.                            |

### 스코프 최소화의 장점

| 장점           | 설명                                  |
|--------------|-------------------------------------|
| 코드 추적 용이     | 변수가 어디서 정의되고 사용되는지 쉽게 파악 가능합니다.     |
| 오류 감소        | 사용되지 않는 변수나 잘못 사용된 변수로 인한 오류를 줄입니다. |
| 유지 관리 편의성 향상 | 코드의 변경 및 수정이 용이합니다.                 |

스코프 최소화는 변수가 필요한 범위에서만 접근 가능하게 관리함으로써, 코드의 안정성을 향상시킵니다.  
특히, 람다에서 변수를 캡처할 때는 해당 변수의 스코프가 람다 밖으로 확장되는 것을 주의해야 하며,  
지연 연산 특성과 같은 상황일 때 예상치 못한 결과가 발생할 수 있습니다.

따라서 변수는 가능한 한 좁은 범위에서 선언하고, `val`을 사용하여 불변성을 유지하는 것이 좋습니다.

---

# Item 3 : Kotlin Null-Safety 및 플랫폼 타입

Kotlin은 Null-safety를 기본으로 제공하며, 이는 `NullPointerException`를 막아주는 매우 효과적인 기능입니다.  
하지만 이 기능은 Java와 같은 언어와의 상호작용에서는 항상 완벽하게 작동하지 않습니다.

### 플랫폼 타입

Kotlin에서 Java나 다른 언어로부터 가져온 타입에 대해 **Nullability가 알려져 있지 않은 경우**, 이를 **플랫폼 타입**으로 처리합니다.

예를 들어, Java에서 가져온 `String`타입은 Kotlin에서 `String!`로 표시됩니다.
`!` 기호는 이 타입이 `null`일 수 있음을 나타냅니다. 그러나 이를 직접 선언하는 것은 허용되지 않습니다.

### 플랫폼 타입 유의점

플랫폼 타입이 `null`일 수 있으므로, 이를 사용할 때는 주의해야 합니다.   
가급적 플랫폼 타입의 사용을 최소화하고, 이를 Kotlin의 `non-null`이나 `nullable` 타입으로 변환하는 것이 좋습니다.

플랫폼 타입으로 인한 예기치 않은 `NullPointerException`을 방지하기 위해, Kotlin에서는 `null` 처리를 위한 특별한 연산자들을 제공합니다.

| 연산자              | 설명                                                                |
|------------------|-------------------------------------------------------------------|
| Safe call (`?.`) | 객체가 null이 아닐 때만 메서드 호출을 수행하며, 객체가 null일 경우에는 전체 표현식이 null을 반환합니다. |
| Elvis 연산자 (`?:`) | 원래 표현식이 null이 아니면 그 값을 반환하고, null일 경우에는 Elvis 연산자 뒤의 표현식을 반환합니다.  |

---

# Item 4: Kotlin의 타입 추론과 적절한 사용법 이해

Kotlin에서 타입 추론은 변수의 타입을 결정하는 유용한 기능입니다. 하지만 이를 올바르게 이해하고 사용하지 않으면, 의도치 않은 문제를 일으킬 수 있습니다.

### 타입 추론의 특성과 한계

타입 추론은 할당의 오른쪽 타입에 기반하여 변수의 타입을 결정합니다. 이 때, 상위 클래스나 인터페이스로는 추론되지 않습니다.

### 타입 추론의 위험성

| 문제점    | 설명                                                    |
|--------|-------------------------------------------------------|
| 가독성 저하 | 타입이 명시적으로 선언되지 않을 경우 코드를 이해하는 데 어려움을 겪을 수 있습니다.       |
| 에러 발생  | 외부 라이브러리나 모듈에서 추론된 타입이 변경될 경우, 예상치 못한 오류가 발생할 수 있습니다. |

### 타입 추론 활용 방향

| 활용           | 설명                                        |
|--------------|-------------------------------------------|
| 타입 명시        | 확실하지 않은 타입에 대해서는 명시적으로 타입을 선언하는 것이 안전합니다. |
| 외부 API 타입 명시 | 외부 API에서는 항상 타입을 명시하는 것이 좋습니다.            |

---

# Itme 5 : Argument와 State에 대한 기대값을 명시

### 기대값 명시의 중요성

- 문서를 읽지 않는 프로그래머들에게 기대치가 명확히 보인다.
- 기대값에 충족되지 않으면 함수는 예외를 발생시켜 예상치 못한 동작을 방지한다.
- 코드에 대한 일정한 검사가 이루어지므로 단위 테스트의 필요성이 줄어든다.
- 모든 검사는 스마트 캐스팅과 함께 작동하므로 캐스팅을 덜 하게 된다.

### 기대값을 명시하는 방법

| 항목                | 설명                                                             | 예시                                                                                  |
|-------------------|----------------------------------------------------------------|-------------------------------------------------------------------------------------|
| Arguments     | - 함수의 인자에 대한 기대값을 명시한다. </br> - 인자가 요구사항을 만족시키지 않으면 예외를 발생시킨다. | ```require(n >= 0) { "Number must be non-negative" }```                             |
| State         | - 함수가 특정 조건에서만 실행될 수 있다는 것을 명시한다.                              | ```check(isInitialized) { "TextToSpeech not initialized" }```                       |
| Assertions    | - 함수가 의도대로 실행되는지 확인한다.                                         | ```assert(ret.size == number)```                                                    |
| Nullability   | - `Elvis` 연산자를 사용하여 더 높은 가독성과 유연성을 제공한다.                       | ```val email = user.email ?: throw IllegalArgumentException("Email required")```    |
| Smart-Casting | - `require`에서 한번 확인한 값은 추후에도 컴파일러에 의해 `true`로 추론된다.            | ```require(person.outfit is Dress)``` </br> ```val dress: Dress = person.outfit ``` |

---

# Item 6 : 사용자 지정 오류보단 표준 오류 권장

- 본문 참고

---

# Item 7 : 무조건 적인 예외가 아닌 Null or Result<Failed>

| 항목                         | 설명                                             |
|----------------------------|------------------------------------------------|
| 예외 사용                      | 일반적인 제어 흐름에서 사용되어서는 아니되며, 오류 상황을 다루는 데 사용해야한다. |
| 예외 사용의 문제점                 | 가독성 저하, 예외의 강제성 부재, 성능 저하, 최적화 억제 등이 발생될 수 있다. |
| `null` 혹은 `Result<Failed>` | 오류가 예상될 때 사용                                   |
| `throw` 사용                 | 오류가 예싱치 못할때 사용                                 |

---

# Item 8 : 안정적인 Null 처리

`null`은 값이 없음을 나타내는 표현입니다. 함수가 `null`을 반환한다는 것은 특정 조건에 일치하는 값이 없음을 의미합니다.

### Null 안전하게 사용

| 방법          | 예시                                             |
|-------------|------------------------------------------------|
| 안전한 호출  | `printer?.print()`                             |
| 스마트 캐스팅 | `if (printer != null) printer.print()`         |

### Throw 에러 던지기

| 방법                      | 예시                                                      |
|-------------------------|---------------------------------------------------------|
| not-null 연산자 (`!!`) | `printer!!.print()`                                     |
| `requireNotNull()`  | `requireNotNull(printer).print()`                       |
| `checkNotNull()`    | `checkNotNull(printer).print()`                         |
| 직접 예외 던지기           | `if (printer == null) throw PrinterNotFoundException()` |

### not-null `!!` 연산자 사용과 주의점

`!!` 연산자는 `null`이 아님을 확신하고 사용하는 연산자입니다. 하지만 실제로는 `null`일 가능성이 있으므로 사용에 주의가 필요합니다.

### nullability 정보의 은폐

`null` 가능성에 대한 정보가 감추어지면 중요한 상황에서 `null`을 쉽게 놓칠 수 있습니다.   
이럴 때는 `lateinit` 또는 `Delegates.notNull`을 사용하는 것이 좋습니다.

### 불필요한 nullability 피하기

`null` 값은 중요한 정보를 전달할 수 있지만, 그 값의 핸들링에는 주의가 필요하며, 불필요한 경우에는 피하는 것이 좋습니다.

이를 위해 Kotlin에서는 다음과 같은 방법들을 제공합니다

- 결과를 예상하는 함수의 변형을 제공하여 값의 부재를 처리합니다. 예를 들어, `List<T>`의 `getOrNull()` 등.
- 초기화가 보장되는 경우, `lateinit` 프로퍼티나 `notNull` 대리자를 사용합니다.
- 컬렉션을 반환하는 경우, `null`보다는 `empty` 컬렉션을 반환하는 것이 바람직합니다.

### lateinit과 notnull 대리

클래스 생성 시에는 초기화가 불가능하지만, 첫 사용 전에 반드시 초기화되어야 하는 프로퍼티가 있는 경우 `lateinit`을 사용할 수 있습니다.   

이를 활용하면 nullable → not-null로 "언팩"하는 작업이 필요 없으며, 필요에 따라 쉽게 nullable로 전환할 수 있습니다.   
하지만, 프로퍼티가 초기화된 후에는 초기화되지 않은 상태로 되돌릴 수 없습니다.

단, 기본형에 해당하는 타입으로 프로퍼티를 초기화해야 하는 경우에는 `Delegates.notNull`을 사용할 수 있습니다.   
이 경우에는 프로퍼티 대리자로 대체하여 `lazy`하게 초기화하는 것도 가능합니다.

---

# Item 9 : use()를 통한 리소스 관리

어떤 리소스들, 예를 들어 파일 입출력이나 네트워크 연결과 같은 리소스들은 사용 후 반드시 닫혀야 합니다.   
이를 처리하지 않으면 메모리 누수와 같은 문제가 발생할 수 있기에 `Closeable` 인터페이스를 구현하므로 사용이 끝난 후에는 `close()`를 호출해야 합니다.

예전에는 이러한 리소스 관리를 `try-finally` 블록을 사용해 `close()`를 호출하였습니다.   
하지만 이 방식은 `close()` 메소드가 예외를 던질 수 있는 문제와 두 블록에서 모두 예외가 발생하면 한쪽의 예외만 전파되는 문제가 있었습니다.

Kotlin에서는 이러한 문제를 해결하기 위해 `use` 함수를 제공합니다.  
이 함수를 사용하면, 리소스을 올바르게 닫고 예외를 처리하는 작업을 간결하게 할 수 있습니다.

---

# Item 10 : 테스트의 중요성
코드의 안정성을 확보하는 가장 좋은 방법 중 하나는 테스트를 실시하는 것입니다.  
이는 앱이 사용자 관점에서 올바르게 작동하는지 확인하는데 필수적입니다.

### 유닛 테스트
유닛 테스트는 시스템의 특정 부분이 올바르게 작동하는지 확인하고 개발 과정에서 빠른 피드백을 제공하는 테스트 방법입니다.

### 장점
잘 이루어진 유닛 테스트는 신뢰성을 높이고, 리팩토링에 대한 부담감을 줄여줍니다.   
수동으로 로직을 확인하는 것보다 효율적입니다.

### 단점
유닛 테스트 작성에는 시간이 필요하며, 테스트 가능한 코드로 수정이 필요합니다.  
좋은 유닛 테스트 작성에는 여러 조건을 만족해야하기에 작성 난이도가 높습니다.

### 필요성
복잡한 기능, 변경 가능성이 있는 부분, 리팩토링이 필요한 부분, 비즈니스 로직, 외부 라이브러리, 수정된 프로덕션 버그 등에 유닛 테스트가 필요합니다.