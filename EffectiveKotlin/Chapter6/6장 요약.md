# Item 36 : Prefer composition over inheritance

상속은 객체의 계층 구조가 'is-a' 관계를 갖도록 설계되었다.
단순히 코드를 재사용하기 위해 상속을 사용하는 경우에는 적절하지 않으며, 더 가벼운 방법인 'Composition'을 사용하는 것이 좋다.

## Simple behavior reuse

예를 들어, 프로그래스바 표시와 숨김을 처리하는 비슷한 로직이 있는 두 클래스가 있고, 
이를 상속을 통해 공통된 로직을 추출하면 다음과 같을 것이다.

```kotlin
abstract class LoaderWithProgress {
    fun load() {
        // show progress
        innerLoad()
        // hide progress
    }
    
    abstract fun innerLoad()
}

class ProfileLoader: LoaderWithProgress() {
    override fun innerLoad() {
        // load profile
    }
}

class ImageLoader: LoaderWithProgress() {
    override fun innerLoad() {
        // load image
    }
}
```

하지만, 이런 방식은 몇 가지 단점이 존재한다.

- 클래스는 단 하나의 상위 클래스만 가질 수 있기에, 함수 추출이 누적되어 거대한 'BaseXXX' 클래스를 만들거나, 복잡하고 깊은 타입 계층을 만들 수 있다.
- 하위 클래스는 상위 클래스의 모든 메서드와 필드를 상속받게 되어, 필요하지 않은 기능까지 상속받을 수 있어 '인터페이스 분리 원칙(ISP)'를 위반하는 문제가 발생할 수 있다.
- 상위 클래스의 기능이 명시적이지 않을 때, 이를 확인하기 위해 상위 클래스의 코드를 참조해야 하는 추가적인 노력이 필요하다.

이러한 단점을 해결하기 위해, 'Composition'을 사용하는 것이 좋다.

'Composition'은 객체를 프로퍼티로 보유하고 필요한 동작만 선택적으로 재사용할 수 있다.  
또한, 'Composition'은 여러 기능을 추출하여 사용하기에 더 유연한 작업이 가능하다.

```kotlin
class Progress {
    fun showProgress() { /* show progress */ }
    fun hideProgress() { /* hide progress */ }
}

class FinishedAlert {
    fun show() { /* show finished alert */ }
}

class ImageLoader {
    private val progress = Progress()
    private val finishedAlert = FinishedAlert()
    
    fun load() {
        progress.showProgress()
        // load image
        progress.hideProgress()
        finishedAlert.show()
    }
}
```

## Talking the whole package

위에서 설명한 것과 같이 상속은 객체의 계층 구조를 나타내는데 좋은 방법이지만, 단지 몇몇 공통 부분을 재사용하기 위해 사용하는 것은 적절하지 않다.
이런 몇몇 공통 부분을 재사용할 때는 필요한 기능만 선택하여 사용할 수 있는 'Composition'을 사용하는 것이 좋다.

예를 들어, 짖을 수 있고 냄새를 맡을 수 있는 'Dog' 클래스를 만든다고 가정해보자.

```kotlin
abstract class Dog {
    
    open fun bark() {
        // ...
    }
    
    open fun sniff() { 
        // ...
    }
}
```

이 때, 냄새를 맡을 수 없는 'RobotDog'라는 타입을 만드려면 다음과 같은 문제가 발생한다.

```kotlin
abstract class Robot {
    
    open fun calculate() {
        // ...
    }
}

// Error: Only one class may appear in a supertype list
class RobotDog : Dog(), Robot() {  
    
    override fun sniff() {
        throw Error("Operation not supported")
    }
}
```

1. 'RobotDog'에 불필요한 메서드 'sniff'가 존재하기에 '인터페이스 분리 원칙(ISP)'을 위반한다.
2. 'Dog' 타입의 객체를 'RobotDog' 타입의 객체로 대체했을 때, 프로그램이 예외를 던질 수 있기에 '리스코프 치환 원칙(LSP)'을 위반할 수 있다.
3. Kotlin에서는 다중 상속을 지원하지 않기에 'RobotDog'는 'Dog'와 'Robot'을 동시에 상속받을 수 없다.

'Composition'은 개발자가 필요한 기능만을 선택하여 재사용할 수 있고, 클래스가 불필요한 의존성을 갖지 않도록 할 수 있다.
또한, 타입 계층 구조를 표현할 때 인터페이스를 사용하면, 다중 상속의 이점을 얻을 수 있다.

## Inheritance breaks encapsulation

클래스에 상속 관계가 생기면 상위 클래스의 내부 구현이 하위 클래스에 영향을 줄 수 있다.
이는 곧 '상속'이 '캡슐화'를 깨뜨릴 수 있음을 의미한다.

예를 들어 요소의 수를 계산하는 'CounterSet'이 필요하다고 가정하고, 'HashSet'을 상속 받아 구현하면 다음과 같을 것이다.

```kotlin
class CounterSet<T> : HashSet<T>() {
    
    var counter = 0
        private set
    
    override fun add(element: T): Boolean {
        counter++
        return super.add(element)
    }
    
    override fun addAll(elements: Collection<T>): Boolean {
        counter += elements.size
        return super.addAll(elements)
    }
    
    override fun remove(element: T): Boolean {
        counter--
        return super.remove(element)
    }
}
```

하지만 위 구현은 다음과 같이 의도했던 방식과 다르게 동작할 수 있다.

```kotlin
val counterList = CounterSet<String>()
counterList.addAll(listOf("A", "B", "C"))
print(counterList.elementsAdded)            // 6
```

이유는 'HashSet' 클래스의 'addAll' 메서드가 'add' 메서드를 내부적으로 사용하기 때문에 'addAll'을 통해 요소를 추가할 때마다 카운터가 2번 증가하기 때문이다.

이러한 이유로 'HashSet'을 상속하는 대신 'Composition'을 사용하는 것이 좋다.

```kotlin
class CounterSet<T> {
    
    private val set = HashSet<T>()
    
    var counter = 0
        private set
    
    fun add(element: T): Boolean {
        counter++
        return set.add(element)
    }
    
    fun addAll(elements: Collection<T>): Boolean {
        counter += elements.size
        return set.addAll(elements)
    }
    
    fun remove(element: T): Boolean {
        counter--
        return set.remove(element)
    }
}

// usage
val counterList = CounterSet<String>()
counterList.addAll(listOf("A", "B", "C"))
print(counterList.elementsAdded)            // 3
```

또 다른 문제가 발생할 수 있는데, 바로 'CounterSet'이 'Set'의 성질을 잃게 된다는 점이다.  
즉, 'CounterSet'은 'Set'이 아니기에 다형성을 잃게 된다.

이를 'Delegation pattern'으로 해결할 수 있다.

'Delegation pattern'은 클래스가 어떤 인터페이스를 구현하고, 동일한 인터페이스를 구현하는 객체를 내부에 구성한 뒤, 인터페이스에 정의된 메서드를 구성된 객체에 전달하는 패턴이다.
이렇게 전달된 메서드를 'Forwarding methods'라고 한다.

```kotlin
class CounterSet<T>: MutableSet<T> {
    
    private val innerSet = HashSet<T>()         // Composition
    var elementsAdded = 0
        private set

    override fun add(element: T): Boolean {
        elementsAdded++
        return innerSet.add(element)            // Forwarding method
    }

    override fun addAll(elements: Collection<T>): Boolean {
        elementsAdded += elements.size
        return innerSet.addAll(elements)        // Forwarding method
    }
    
    override val size: Int 
        get() = innerSet.size
    
    override fun contains(element: T): Boolean =
        innerSet.contains(element)
    
    override fun containsAll(elements: Collection<T>): Boolean =
        innerSet.containsAll(elements)
    
    override fun isEmpty(): Boolean =
        innerSet.isEmpty()
    
    override fun iterator(): MutableIterator<T> = 
        innerSet.iterator()
    
    override fun clear() = 
        innerSet.clear()
    
    override fun remove(element: T): Boolean = 
        innerSet.remove(element)
    
    override fun removeAll(elements: Collection<T>): Boolean =
        innerSet.removeAll(elements)
    
    override fun retainAll(elements: Collection<T>): Boolean =
        innerSet.retainAll(elements)
    
}
```

Kotlin은 위와 같이 많은 수의 'Forwarding methods'를 구현해야 하는 문제를 알고, 
다음과 같이 간편하게 사용할 수 있도록 'Interface delegation'을 지원한다. 

```kotlin
class CounterSet<T>(
    private val innerSet: MutableSet<T> = mutableSetOf()
) : MutableSet<T> by innerSet {                 // Interface delegation
    
    var elementsAdded = 0                       // Composition
        private set

    override fun add(element: T): Boolean {
        elementsAdded++
        return innerSet.add(element)            // Forwarding method
    }

    override fun addAll(elements: Collection<T>): Boolean {
        elementsAdded += elements.size
        return innerSet.addAll(elements)        // Forwarding method
    }
}
```

이처럼 다형성이 필요함과 동시에 상속을 사용하는 것에 리스크가 있을 때 'Delegation pattern'을 사용하는 것이 좋다.
하지만, 대부분의 경우 다형성이 필요하지 않기에, 'Composition'을 사용하는 것이 코드를 더 쉽게 이해할 수 있고 유연하게 만들 수 있다.

또한, 상속이 캡슐화를 깨뜨리는 점은 보안상의 문제를 일으킬 수 있지만, 대부분의 클래스는 'contract'가 명시되어 있거나 상속을 염두에 두고 메서드를 설계한 경우가 많기에 하위 클래스에서 특정 구현에 의존하지 않도록 설계할 수 있다.
그럼에도 불구하고, 상속 대신 'Composition'을 사용하는 것은 더 많은 유연성과 재사용성을 제공하기에 'Composition'을 사용하는 것이 좋다.

## Restricting overriding

상속을 염두 하지 않고 설계된 클래스는 내부 메서드나 필드를 'final'로 선언하면 확장을 방지할 수 있다.  
기본적으로 모든 메서드들은 'final'로 설정되어 있기에, 특별한 이유로 상속을 허용해야 하는 경우 'override'하고 싶은 메서드들만 'open'으로 설정하면 된다. 

```kotlin
open class Parent {
    fun a() {}
    open fun b() {}
}

class Child: Parent() {
    override fun a() {} // Error : final a cannot be overridden
    override fun b() {}
}
```

또한, 메서드를 'override'하면 해당 메서드를 'final'로 다시 설정할 수 있다는 점을 기억해야 한다.  
다음과 같이 선언하면 하위 클래스에서 'override' 할 수 있는 메서의 수를 제한할 수 있다.

```kotlin
open class ProfileLoader: InternetLoader() {
    
    final override fun loadFromInternet() {
        // load profile
    }
}
```

---

## Item 37 : 데이터 번들 표현 시 데이터 클래스 사용

Kotlin의 데이터 클래스는 데이터 번들을 표현하고 전달하는데 유용한 도구입니다.  
`toString`, `equals`, `hashCode`, `copy`, `componentN` 등과 같은 다양한 메서드와 데이터 수정자를 제공하여 코드의 간결성과 가독성을 높여줍니다.

### 데이터 클래스를 비구조화 할당 시 주의점

Kotlin의 비구조화 할당 기능은 데이터 클래스의 속성을 변수에 쉽게 할당할 수 있게 해주지만, 주의해야 할 점들이 있습니다.

데이터 클래스의 속성 순서 변경, 잘못된 비구조화 등의 문제를 예방하기 위해 비구조화 할당을 잘 이해하고 사용해야 합니다.

### 튜플보다 데이터 클래스를 선호하라

튜플(`Pair`, `Triple`)은 간결한 데이터 구조를 표현하는데 유용하지만, Kotlin에서는 데이터 클래스를 통해 더 명확하고 가독성 높은 코드를 작성할 수 있습니다.

특히, 데이터 클래스는 이름이 있는 속성을 가지므로, 이는 코드를 더 이해하기 쉽게 만듭니다. 따라서 가능한 한 튜플 대신 데이터 클래스를 사용하는 것이 좋습니다.

---

## Item 38 : 연산 및 이벤트 전달 시 인터페이스 대신 함수 타입 권장

함수 타입 사용 시 `람다 표현식`, `함수 참조`, `함수 타입 구현 객체` 등 다양한 방식으로 함수에 값을 전달할 수 있습니다.
이는 코드의 유연성을 높이며, 더 많은 사용 사례를 커버할 수 있습니다.

### SAM(Single Abstract Method)의 한계

SAM은 값 전달 방식이 제한적이며 코드의 가독성이 떨어질 수 있습니다.
특히 여러 리스너를 설정하는 경우, 모든 리스너를 하나의 인터페이스에 묶어 놓는 것은 관리와 사용에 불편함이 있을 수 있습니다.

### 함수 타입에서 typealias 활용

SAM과 비교했을 때의 함수 타입의 단점(파라미터 값과 반환 값 명시)을 `typealias`를 활용하여 극복할 수 있습니다.
이는 코드의 가독성을 높이며, IDE가 기본적으로 제안할 수 있도록 도와줍니다.

### Java와의 호환성

Kotlin 이외의 언어에서 사용될 때는 SAM의 사용이 더 합리적일 수 있습니다.  
이는 Java 클라이언트가 typealias나 IDE의 제안을 볼 수 없으며, 함수가 명시적으로 Unit을 반환하도록 요구하기 때문입니다.

따라서 Java에서 사용되도록 API를 설계할 때는 이 점을 고려해야 합니다.

---

## Item 39 : 태그 클래스 대신 클래스 계층 선호

### 태그 클래스의 단점과 클래스 계층 구조의 장점

태그 클래스는 하나의 클래스에 여러 모드를 두어 클래스의 동작을 정의합니다. 이로 인해 클래스는 여러 책임을 가지게 되며, 복잡도가 증가하고 유지 관리가 어려워집니다.
이에 반해, 클래스 계층 구조는 각 모드를 별도의 클래스로 분리하여 다형성을 허용함으로써 코드의 가독성을 향상시키고 유지 관리를 쉽게 할 수 있습니다.

### sealed 클래스 활용하여 클래스 계층 구조 제한

Kotlin에서는 `sealed` 클래스를 사용하여 한정된 하위 클래스 집합을 제한할 수 있습니다.
이를 통해 `when` 표현식을 사용할 때 새로운 기능을 쉽게 추가하고 `when` 표현식에서 빠트린 처리가 없음을 확인하는데 유용합니다.

### Sealed 클래스와 Abstract 클래스의 선택

`sealed` 클래스는 모든 하위 클래스를 한정할 수 있어 `when` 표현식에서의 안전성을 보장하지만,
`abstract` 클래스는 새로운 하위 클래스를 추가할 수 있기에 이를 사용할 때에는 함수를 `abstract`로 선언하고 각 하위 클래스에서 해당 함수를 오버라이드하는 것이 좋습니다.

### 태그 클래스와 상태 패턴의 구분

태그 클래스와 상태 패턴은 동일하지 않습니다.
상태 패턴은 객체 내부 상태가 변경될 때 그 행동을 변경하게 하는 행동적인 소프트웨어 디자인 패턴입니다.
이를 통해 동일한 객체의 상태 변화에 따른 다양한 동작을 관리할 수 있습니다.
이를 위해 상태 패턴은 각 상태를 별도의 클래스로 표현하며 각 상태를 `sealed` 클래스로 관리합니다.

---

## Item 40 : Equals 계약 준수

Kotlin의 모든 객체는 `Any`라는 최상위 클래스를 상속받습니다.
`Any`는 `equals`, `hashCode`, `toString` 등의 기본 메서드를 포함하고 있으며, 이들 메서드는 특정 계약에 기반을 두고 있습니다.
이러한 계약을 어길 경우, 일부 객체나 함수가 제대로 작동하지 않을 위험이 있습니다.

### 동등성에 대한 이해

| 동등성 타입  | 연산자           | 설명                        |
|---------|---------------|---------------------------|
| 구조적 동등성 | `==` `equals` | 객체의 내용이 같은지를 판단           |
| 참조 동등성  | `===`         | 두 객체가 동일한 인스턴스를 가리키는지를 판단 |

### equals 필요성

기본적으로 `Any`로부터 상속받은 `equals` 메서드는 참조 동등성을 확인합니다. 
이는 각 객체가 고유하다는 것을 의미하며, 이는 특히 데이터베이스 연결이나 스레드와 같이 활성화된 요소에 유용합니다.

그러나, 데이터에 의해 정의되는 클래스에서는 객체의 내용이 같은지를 비교하는 '구조적 동등성'이 필요한 경우도 있습니다. 
예를 들어, 모든 기본 생성자 속성이 같은지 확인하는 데이터 클래스가 이에 해당합니다.

### equals 재정의

`equals` 메서드의 기본 동등성과 데이터 클래스의 동등성 이외에도, 직접 `equals`를 구현해야하는 경우가 있습니다.

- 동등성 판단 로직이 기본적인 것과 다르게 필요한 경우
- 속성 중 일부만 비교하고 싶을 때
- 객체가 데이터 클래스가 되기를 원하지 않거나 비교해야 하는 속성들이 기본 생성자에 없는 경우

### 객체 동등성(Equals) 구현 요구 사항

| 요구사항 | 설명 |
|---------|-----|
| 반사성 (Reflexive) | 모든 null이 아닌 값 x에 대해, `x.equals(x)`는 항상 `true`를 반환해야 합니다. 이것은 객체 자체와의 동일성을 보장합니다. |
| 대칭성 (Symmetric) | 모든 null이 아닌 값 x와 y에 대해, `x.equals(y)`가 `true`일 때만 `y.equals(x)`도 반드시 `true`를 반환해야 합니다. 즉, 양방향 동등성을 보장해야 합니다. |
| 전이성 (Transitive) | 모든 null이 아닌 값 x, y, z에 대해, `x.equals(y)`가 `true`를 반환하고 `y.equals(z)`가 `true`를 반환하는 경우, `x.equals(z)`도 반드시 `true`를 반환해야 합니다. 즉, 연쇄적인 동등성을 보장해야 합니다. |
| 일관성 (Consistent) | 모든 null이 아닌 값 x와 y에 대해, `equals` 비교에 사용되는 객체 정보가 수정되지 않는 한 `x.equals(y)`를 여러 번 호출하더라도 항상 일관성있게 `true`나 `false`를 반환해야 합니다. 객체 정보가 변경되지 않는 한 결과가 변하지 않는 일관성을 보장합니다. |
| null과 절대 동일하지 않음 | 모든 null이 아닌 값 x에 대해, `x.equals(null)`은 항상 `false`를 반환해야 합니다. null은 고유하며, 어떤 객체도 null과 동등하다고 볼 수 없기 때문입니다. |

`equals`, `toString`, `hashCode` 메서드는 빠르게 동작해야 합니다. 두 객체를 비교하는데 오랜 시간이 걸리면 사용성이 저하될 수 있습니다.

---

## Item 41 : HashCode 계약 준수

해시 테이블은 빠르게 요소를 추가하고 검색할 수 있는 컬렉션을 제공하기 위해 사용되는 자료구조입니다. 
이러한 해시 테이블은 해시 함수를 사용하여 요소를 다른 버킷으로 분류하고 각 요소에 대해 고유한 번호를 할당합니다.

### 해시 함수

해시 함수는 빠른 동작, 동등한 요소에 대해 동일한 해시 코드 반환, 서로 다른 요소에 대해 다른 해시 코드를 반환하거나 충돌을 최소화해야 하는 특징이 있습니다.
해시 함수는 해시 테이블의 성능에 직접적인 영향을 미치므로 빠른 동작과 충돌 최소화를 고려하여 구현해야 합니다.

그러나 가변 요소는 해시 기반의 자료구조에서 문제가 될 수 있기에 가변 객체는 해시 기반의 자료구조나 다른 자료구조에서 사욛되지 않아야 합니다.

### hashCode 규약

동일 객체에 대한 `hashcode` 메서드가 여러 번 호출될 경우, 객체의 `equals` 메서드에 사용되는 정보가 변경되지 않는 이상 항상 같은 정수를 반환해야 합니다.
또한 두 객체가 `equals` 메서드를 통해 같다고 판단되면, 두 객체의 `hashCode` 메서드는 항상 같은 결과를 반환해야 합니다.

만약 위 규약을 지키지 않으면, 해시 테이블 컬렉션에서 요소가 사라지는 문제가 발생할 수 있습니다.

### hashCode 구현

구현은 `equals()`가 재정의되었다면 함께 `hashCode()`도 오버라이드하는 것이 좋습니다. 
주요 속성들의 동일성을 확인하는 일반적인 `equals()` 구현 시, 이들 속성들의 해시 코드를 기반으로 하는 일반적인 `hashCode()`를 구현해야 합니다. 

일반적으로는 해시 코드들을 모두 누적하면서 값을 31로 곱하는 방법을 사용합니다.

---

## Item 42 : compareTo 계약 준수

`compareTo()` 함수는 Kotlin에서 수학적 부등호로 변환되는 연산자입니다. 
이 함수는 `Comparable<T>` 인터페이스에 속해 있으며, 이 인터페이스를 구현하거나 `compareTo()` 연산자 메서드를 가진 객체는 자연스러운 순서를 가진다고 볼 수 있습니다. 

`compareTo()` 규약의 핵심은 반대 대칭성(Anti-symmetric), 전이성(Transitive), 연결성(Connex)을 갖는다는 것입니다.

### compareTo 필요성과 활용

개발자들은 `compareTo()`를 직접 구현하지 않고, 경우에 따라 순서를 지정해 더 큰 유연성을 얻습니다. 
키를 통한 간단한 비교가 아닌 복잡한 비교가 필요한 경우, `Comparator`를 이용하여 요소를 정렬합니다. 
또한, 자연스러운 순서가 확실하지 않은 객체에 대해선 `Comparator`를 사용하는 것이 더 좋습니다.

### compareTo 구현

직접 `compareTo`를 구현하는 경우, 최상위 함수인 `compareValues`나 `compareValuesBy`등 사용하여 구현할 수 있습니다. 

`Comparator`를 사용해야 하는 특별한 로직이 필요한 경우, `Comparator`는 다음을 반환해야 합니다.

- 수신자와 other가 동등하면 0
- 수신자가 other보다 크면 양수
- 수신자가 other보다 작으면 음수

---

## Item 43 : API 비핵심 부분을 extension으로 추출하는 것을 고려

Kotlin에서는 메서드를 클래스의 멤버로 정의하거나 확장(Extension)으로 정의할 수 있습니다. 
두 방식 모두 장단점이 있으며, 상황에 따라 적절한 선택을 해야합니다.

### Extension 장점

확장은 별도로 임포트해야 하며, 이를 통해 다른 패키지에 위치할 수 있습니다. 
이는 멤버를 직접 추가할 수 없는 경우, 또는 데이터와 동작을 분리하도록 설계된 프로젝트에서 유용하게 사용될 수 있습니다. 
또한 동일한 유형에 동일한 이름을 가진 많은 확장을 가질 수 있어 다른 라이브러리가 추가적인 메서드를 제공하는데 용이합니다.

### Extension 한계

확장은 [가상](../../용어.md#가상virtual)이 아니기에 파생 클래스에서 재정의할 수 없습니다.
확장 함수는 컴파일 중에 정적으로 선택됩니다. 이는 Kotlin의 멤버 요소가 가상인 것과 다른 동작이며, 상속을 위해 설계된 요소에 대해선 확장을 사용하지 않아야 합니다.

### Extension 특성

확장은 클래스 참조에 있어 멤버로 나열되지 않습니다. 이는 확장이 클래스의 인스턴스에 대한 첫 번째 매개변수를 가진 정적 메서드로 컴파일되기 때문입니다. 
이로 인해 어노테이션 프로세서와 같은 도구는 확장을 클래스의 멤버로 간주하지 않습니다. 따라서 비핵심 요소를 확장으로 추출하면, 이들이 어노테이션 프로세서에 의해 확인되는 것에 대해 걱정할 필요가 없습니다.

---

## Item 44 : 클래스 내부 Extension 피하기

클래스에 확장 함수 정의 시, 확장 함수는 첫 번째 인자로 받은 객체에 대한 호출을 수행하는 특별한 함수일 뿐 해당 **클래스의 멤버 함수가 아닙니다.**  
이러한 함수들은 내부적으로 일반 함수로 컴파일되며, 수신(receiver) 객체는 첫 번째 파라미터로 전달됩니다.

```kotlin
fun String.isPhoneNumber(): Boolean = length == 7 && all { it.isDigit() }

// 코드 컴파일
fun isPhoneNumber(`$this`: String): Boolean = $this.length == 7 && $this.all { it.isDigit() }
```

### 클래스 내부 확장 함수 정의를 피해야 하는 이유 

멤버 확장 함수는 정적으로 참조할 수 없으며 확장 수신자 및 디스패치 수신자에 대해 모두 접근할 수 있어 확장 함수가 상태를 변경하거나 참조 시 코드에 대한 이해가 어려워질 수 있습니다. 
또한, 주니어 개발자는 확장 함수에 대한 개념이 없는 경우 코드에 대한 이해도가 떨어져 프로젝트 생산성을 떨어뜨릴 수 있습니다. 