# Item 19 : Do not repeat knowledge

프로그래밍에서 'knowledge'를 표현하면 다음과 같다.

- 의도적으로 생성된 모든 '정보 조각'을 의미하며, 코드 또는 데이터로 표현된다.
- 코드 또는 데이터가 없는 경우에는, 기본 동작을 사용하고 싶다는 의미로 나타낼 수 있다.
    - e.g : 상속을 받고 메서드를 'override' 하지 않을 때, 해당 메서드가 상위 클래스와 동일하게 동작하기를 원하는것으로 나타낼 수 있다.

소프트웨어에서 'knowledge'는 '알고리즘', 'UI 디자인' 등이 될 수 있으며, 다음과 같은 방식으로 표현될 수 있다.

- 코드 : 가장 직접적인 표현 방식, 함수•클래스•변수 등을 통해 구체적인 동작과 로직을 표현
- 구성 : 앱의 동작 환경을 정의하는 방식, 런타임에 프로그램의 행동 조정 가능
- 템플릿 : 문서•UI 레이아웃•코드 구조 등 미리 정의하여 재사용 가능한 형태로 만들 수 있음

결과적으로, 프로그램은 어떤 형태로든 'knowledge'를 보유하고 있으며, 다음 두 가지 'knowledge'를 중요하게 생각한다.

- 로직 : 프로그램의 동작 방식과 UI 디자인에 대한 예상
- 공통 알고리즘 : 기대하는 동작을 달성하기 위해 구현한 알고리즘

## Everything can change

프로그래밍에서 유일한 상수는 '변화'라는 말이 있다.  
5 ~ 10년 전의 서비스들을 살펴보면, 변경되지 않는 앱 또는 웹사이트가 있는지 생각해보면 많이 없을 것이다.  
또한, Android OS도 08년에 처음 출시되어, 'Vanilla'까지 계속 업데이트 되고 있고,
Kotlin도 16년도에 1.0 버전 출시 후 계속 업데이트 되어 2.0 안정화 출시를 앞두고 있다.

이러한 변화는 UI 디자인과 기술에서 더욱 빠르게 발생하며, 이에 맞춰 사용자들의 요구사항도 빈번하게 변경되고 달라진다.  
이는 곧, 기존의 서비스들이 계속해서 사용자 요구사항에 맞춰 업데이트 되어야 함을 의미한다.  
결과적으로, 현대의 S/W 개발은 기술의 발전, 경쟁 상대의 변화, 사용자 피드백 등 여러 요인에 의해 '지속적인 변화'가 필수적임을 알 수 있다.

이러한 변화에 가장 큰 문제점 중 하나는 '반복되는 knowledge'이다.  
예를 들어, 프로젝트 내 전역적으로 사용되는 버튼의 디자인이 변경된다면 모든 위치의 디자인을 바꾸는 것은 번거롭고 실수를 유발할 수 있다.
또한, DB 테이블 이름이 바뀌는 경우, 모든 SQL문에 맞게 수정되지 않으면 큰 문제가 발생할 수 있다.

이러한 문제를 선임 개발자들이 일찍이 인지하고, 이를 해결하기 위해 다양한 도구와 기능을 만들었다.  
전역적으로 사용되는 버튼은 Style Pattern, Custom View, Component 등을 통해 해결할 수 있고,
텍스트 형식의 SQL문 대신 ORM, DAO를 사용하여 해결할 수 있다.

이러한 해결법들은 다양한 종류의 추상화를 나타내며, 프로젝트를 다양한 종류의 중복성으로부터 보호한다.

## When should we allow code repetition?

비슷해 보이는 코드 블록이 있을지라도, 실제로 동일한 기능을 수행하거나 동일한 문제를 해결하는 것은 아니다.  
이처럼 각 코드가 다른 목적으로 사용될 수 있기에, 동일해 보이는 코드를 무작정 하나로 추출하여 재사용하는 것은 안된다.

예를 들어, 같은 프로젝트에 두 개의 독립적인 안드로이드 앱이 있다고 가정해보자.  
두 앱은 비슷한 'Build configuration'을 갖지만, 각 앱은 독립적인 요구사항과 개발 사이클을 지닌다.  
이때, 각 'Build configuration'을 무작정 하나의 'common configuration'으로 만들면 다음과 같은 문제가 발생할 수 있다.

- 한 앱에서 'Configuration'의 변경이 필요한 경우, 다른 앱에 영향을 주기에 관리의 복잡성이 증가한다.
- 새로운 방식의 'common configuration'이 도입되어, 개발자들이 다시 패턴과 규칙을 만들어 지켜야하는 비용이 발생한다.

이처럼, 공통 로직으로 추출하는 것은 각 코드 블록들이 **향후에 어떻게 변경될 가능성이 있는지에 대한 고려**가 필요하다.  

- 동일한 비지니스 로직 또는 요구사항에 영향을 받으면, 함께 변경될 가능성이 높기에 공통 로직으로 추출하는 것이 효율적이다.
- 비슷하지만 서로 다른 목적으로 사용되는 경우, 별도로 변경될 가능성이 높기에 강제로 공통 로직으로 추출하는 것은 향후 유지보수를 어렵게 하고, 프로젝트의 유연성을 떨어뜨릴 수 있다.

## Single responsibility principle

프로젝트에서의 '변화'는 다양한 관점에서 주도할 수 있으며, 이는 '관리자 • 개발자 • 외부 시스템' 등에서 발생 할 수 있다.  
이처럼 클래스나 모듈에 변경을 요구하는 어떠한 외부 요소를 '**액터**'라고 한다.  
만약, 액터가 여럿인 경우에 각각의 요구사항들이 충돌할 수 있기에, 이러한 상황을 피해야 한다.

SRP는 '클래스가 **변경**되어야 하는 이유는 **단 하나의 이유**여야 한다'는 원칙을 가지며, 
위 상황에 접목하면 '2명 이상의 액터가 동일한 클래스를 변경하는 상황이 없어야 한다.'로 간소화 할 수 있다. 

이처럼 SRP는 공통 로직으로 추출하지 말아야하는 상황을 판단하는데 도움을 줄 수 있으며, 아래 예시를 보자.  
대학에서 '장학 부서'와 '인증 부서'가 각각의 목적으로 '학생 정보'를 사용한다고 가정해보면 다음과 같이 사용할 수 있을 것이다.

```kotlin
class Student {
    // 인증 부서 - 학생의 합격 유무
    fun isPassing(): Boolean =
        calculatePointsFromPassedCourses() > 60

    // 장학 부서 - 학생의 장학금 자격 유무
    fun qualifiesForScholarship(): Boolean =
        calculatePointsFromPassedCourses() > 80
  
    // 지난 학기의 점수 계산
    private fun calculatePointsFromPassedCourses(): Int {
        // ...
    }
}
```

그런데, 어느날 장학금 기준이 변경되어, 일부 과목을 제외하기로 결정하였다.  
이에 따라, '장학 부서' 개발자는 '지난 학기의 점수를 계산하는 함수' 수정이 필요한 상황이다.  
그러나, 이러한 수정은 의도치 않게 '인증 부서'에도 영향을 줄 수 있기에, 곤란한 상황이 발생하게 된다.

이처럼, 같은 클래스나 파일 내 위치한 두 기능이 서로 강하게 의존되어 있으면 문제가 되는 상황이 많이 발생할 수 있다.  
이를 위해, 기능이나 역할을 별도의 클래스로 추출하여 독립적으로 변경될 수 있도록 하여 문제를 해결할 수 있다.

위 예시를 통해 알 수 있는 것은, '서로 다른 출처'에서 오는 'knowledge'는 독립적으로 변할 수 있기에 'different knowledge'로 다루어야 한다.
또한, 이러한 'different knowledge'를 분리하지 않으면, 재사용이 가능한 부분과 그렇지 않은 부분으로 구별하는 것이 어려워지고, 재사용되서는 안되는 부분을 재사용하게 되는 실수가 발생될 수 있다.

---

## Item 20 : Do not repeat common algorithms

개발자들은 종종 일반적인 문제를 해결하기 위해, 특정 코드 패턴이나 알고리즘을 구현하려는 경향이 있다.
이런 코드 패턴이나 알고리즘은 비지니스 로직과 별개로, 수학적 연산이나 컬렉션 처리와 같은 일반적인 기능 수행 등 다양한 형태로 나타난다.

이때, 필요한 기능이 이미 '표준 라이브러리'로 제공되고 있다면, 직접 구현하는 것은 불필요한 행동이다.  
그럼에도, 짧지만 반복되는 알고리즘을 함수로 추출하는 접근 방식은 개발 프로세스의 여러 측면에서 이점을 제공한다.

1. 함수 호출 1번으로 훨씬 간결한 코드 작성을 하기에 프로그래밍 속도가 향상된다.
2. 알고리즘이 함수 이름으로 명시되어 있어, 구현을 하나하나 이해하지 않아도 해당 기능을 바로 알 수 있다.
3. 불필요한 정보가 최소화되어, 코드 내 특이점(오류 상황, 비정상 로직 등)을 파악하기 쉬워진다.
4. 한 번의 최적화로 모든 사용처에 성능 향상 이점을 볼 수 있다.

'표준 라이브러리'는 대부분의 일반적인 알고리즘을 '확장 함수'로 제공하고 있으며, 다양한 유틸리티의 거대한 집합으로 정의된다.  
이 때문에 표준 라이브러리 함수들을 학습하는 것은 까다롭지만, 매우 가치 있는 일이다.

## Implementing your own utils

그럼에도, 모든 프로젝트에는 표준 라이브러리가 제공하지 않는 특정 알고리즘이 필요한 순간들이 있다.  
이런 경우에는 널리 알려진 함수들을 활용하여, 보편적인 유틸리티 함수로 정의하는 것이 좋다.

아래는 컬렉션에 있는 숫자의 곱을 계산하는 함수를 정의한 예시이다.

```kotlin
fun Iterable<Int>.product() = fold(1) { acc, i -> acc * i }
```

또한 보편적인 유틸리티 함수를 정의할 때, 이미 잘 알려진 수학적 개념을 미리 구현하는 것도 좋다. 
이런 수학적 개념들은 이름 자체가 이미 명확하기에, 먼 미래에 다른 개발자가 해당 함수를 필요로 할 때, 미리 구현되어 있다면 큰 도움을 받을 것이다.

이 때, **주의할 점은 동일한 결과를 얻는 중복 함수**를 만드는 것이다.  
각 함수들은 반드시 테스트되고, 개발자들이 기억하고 있어야 하며, 유지보수 되어야 하기에 비용으로 간주된다.  
만약, 함수를 무분별하게 추가하게 되면 이 비용이 계속해서 증가함으로, 필요한 함수가 이미 존재하는지 확인하는 것이 중요하다.

개발자들은 'top-level function', 'property delegate', 'class'에 이르기까지, 다양한 방법으로 공통 알고리즘을 추출할 수 있다.
그럼에도 불구하고, 표준 라이브러리와 같이 대부분 함수를 '확장 함수'로 정의하는 이유는 다음과 같다.

1. 함수는 상태를 필요로 하지 않기에, 'Side-effect'가 없는 행동을 표현하는데 적합하다.
2. 함수의 파라미터를 수정하는 것보다, 리시버를 수정하는 것이 더 직관적이다.
3. 객체의 메서드에 비해, 객체에만 '제안'되기에 '힌트' 중에서 찾기 더 쉽다.  
   예를 들어, `TextUtils.isEmpty("Text")` 보다 `"Text".isEmpty()`가 더 찾기 쉽다.
4. '확장 함수'는 명확한 호출 컨텍스트를 제공하기에, 'class / super class의 메서드' 또는 'top-level function'과의 혼동을 줄일 수 있다.

---

## Item 21 : Property Delegation

### Property Delegation 기능 및 예시

Kotlin은 코드 재사용을 향상시키는 Property Delegation 기능을 제공합니다. 이 기능을 이용하면, 일반적으로 발생하는 Property 관련 동작을 쉽게 재사용할 수 있습니다.
이를 통해, 첫 번째 접근 시에만 초기화되는 `lazy` property와 같은 특성이나, 값이 변경될 때마다 특정 동작을 실행하는 `observable` property 등의 동작을 쉽게 재사용할 수 있습니다.

### Property Delegation 활용 다양한 패턴 추출

Property Delegation 메커니즘은 다양한 패턴을 추출하는데 사용될 수 있습니다. 이를
통해 `View-Resource Binding`, `DI(Dependency Injection)`, `Data Binding` 등과 같은 패턴을 구현할 수 있습니다.
이런 패턴들은 일반적으로 Java에서는 주석 처리가 필요하지만, Kotlin에서는 Property Delegation을 사용하여 쉽고 안전하게 구현할 수 있습니다.

### Property Delegation 활용 반복 패턴 추출

Kotlin의 Property Delegation 기능을 이용하면, 프로젝트에서 자주 사용하는 반복 패턴을 쉽게 추출할 수 있습니다.
예를 들어, `getter`와 `setter` 메소드를 가진 객체는 `getValue`와 `setValue` 함수를 통해 위임될 수 있습니다.
이 기능을 이용하여 다른 객체로부터 메소드를 위임받는 방식으로 반복되는 패턴을 쉽게 추출하고 재사용할 수 있습니다.
이는 코드의 가독성을 향상시키고 유지 관리를 쉽게 만듭니다.

---

## Item 22 : 공통 알고리즘 구현 시 제네릭 사용

### 제네릭 기능 및 사용 예시

Kotlin에서는 함수에 인자를 전달하는 것처럼, 타입을 타입 인자로 전달할 수 있습니다.
이런 타입 인자를 받는 함수를 제네릭 함수라고 하며, 제네릭 함수를 이용하면 코드를 좀 더 안전하게 작성할 수 있습니다.

### 제네릭 사용으로 프로그램 안전성 향상

Kotlin의 제네릭 기능을 이용하면 컴파일러가 타입을 좀 더 정확하게 확인하고 추론할 수 있습니다.
이를 통해 프로그램의 안전성이 향상됩니다. 일반적으로 제네릭은 클래스와 인터페이스에 도입되어, 특정 타입만을 가지는 컬렉션의 생성을 가능하게 합니다.

### 제네릭 제약조건 활용

제네릭의 중요한 특징 중 하나는 타입 매개변수를 특정 타입의 서브타입으로 제약할 수 있다는 것입니다.
이를 통해 특정 타입의 인스턴스가 해당 타입이 제공하는 모든 메소드를 사용할 수 있게 됩니다.
한 타입에 여러 개의 상위 제한을 설정해야 하는 경우에는, `where`를 사용하여 더 많은 제약을 설정할 수 있습니다.

---

## Item 23 : 타입 매개변수 섀도잉

### 섀도잉의 위험성

Kotlin에서는 섀도잉을 통해 속성과 매개변수를 같은 이름으로 정의할 수 있습니다.
이는 로컬 매개변수가 외부 범위의 속성을 섀도잉하는 결과를 초래합니다.
하지만, 이러한 동작은 종종 코드의 가독성을 저해하고, 개발자가 실수를 범할 수 있는 여지를 제공합니다.

### 타입 매개변수 섀도잉 문제점

함수의 타입 매개변수가 클래스의 타입 매개변수를 섀도잉하는 상황은 코드의 가독성을 더욱 떨어뜨립니다.
이는 주로 제네릭의 작동 방식을 제대로 이해하지 못한 개발자들이 범하는 실수이며, 이런 실수는 심각한 문제를 초래할 수 있습니다.

### 타입 매개변수 섀도잉 해결책

타입 매개변수 섀도잉의 문제를 해결하기 위한 가장 간단한 방법은 타입 매개변수에 제네릭을 사용하도록 변경하는 것입니다.
이렇게 하면 클래스의 타입 매개변수와 함수의 타입 매개변수가 혼동되는 문제를 피할 수 있습니다.
만약 새로운 타입 매개변수를 도입해야 하는 경우에는, 서로 다른 이름을 사용하거나 다른 타입 매개변수의 하위타입으로 제한하는 것이 좋습니다.

---

## Item 24 : 제네릭 타입의 공변성과 반공변성 고려

### variance modifier `in`, `out`

변위 수식어 `out`와 `in`을 통해 제네릭 타입 간의 관계를 설정할 수 있습니다.  
`out`은 타입 파라미터를 공변(covariant)으로 만들어 주어, A가 B의 하위 타입일 때 `Cup<A>`가 `Cup<B>`의 하위 타입이 됩니다.  
반대로, `in`은 타입 파라미터를 반공변(contravariant)으로 만들어 주어, A가 B의 하위 타입일 때 `Cup<A>`가 `Cup<B>`의 상위 타입이 됩니다.

### Function Type

함수 타입에서는 파라미터 타입이 반공변적(`in` 수정자)이고 반환 타입은 공변적(`out` 수정자)입니다.  
오직 반환(생성 또는 공개)만 하는 타입에 대해서는 공변성(`out` 수정자)을 사용합니다.  
오직 받아들이는 타입에 대해서는 반공변성(`in` 수정자)을 사용합니다.

### variance modifier 안정성

`in`과 `out` 제한자는 타입 안정성을 보장하는 중요한 도구입니다.  
`out` 제한자가 붙은 타입은 오직 [읽기 전용](../../용어.md#in-positions)이며 반대로 `in` 제한자가 붙은 타입은 오직 [쓰기 전용](../../용어.md#out-positions)
타입입니다.  
이 둘은 모두 제네릭 타입에 대해 추가적인 유연성을 제공하면서도, 타입 안정성을 손상시키지 않습니다.

### variance modifier 위치

variance modifier의 위치는 2가지 위치에서 사용될 수 있습니다.

- 일반적인 선언 위치(declaration-side) : 이는 클래스나 인터페이스 선언에 붙어 해당 클래스나 인터페이스가 사용되는 모든 곳에 영향을 줍니다.
- 사용 위치(use-side) : 이는 특정 변수에 대한 변위 제한성입니다. 이는 모든 인스턴스에 대해 변위 제한성이 적용될 필요가 없으나, 특정 변수에는 필요한 경우 사용됩니다.

