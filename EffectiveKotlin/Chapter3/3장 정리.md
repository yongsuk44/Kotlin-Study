# 목차

- [Item 19 : 반복되는 정보 처리를 하지말것](#item-19--do-not-repeat-knowledge)
- [Item 20 : 공통 알고리즘 반복 금지](#item-20--공통-알고리즘-반복-금지)
- [Item 21 : Property Delegation](#item-21--property-delegation)
- [Item 22 : 공통 알고리즘 구현 시 제네릭 사용](#item-22--공통-알고리즘-구현-시-제네릭-사용)
- [Item 23 : 타입 매개변수 섀도잉](#item-23--타입-매개변수-섀도잉)
- [Item 24 : 제네릭 타입의 공변성과 반공변성 고려](#item-24--제네릭-타입의-공변성과-반공변성-고려)

---

## Item 19 : 반복되는 정보 처리를 하지말것

### 지식 (knowledge)

프로그래밍에서 '지식'은 모든 의도적인 정보를 포함하며, 이는 알고리즘의 작동 방식, UI 디자인, 목표 결과 등 다양한 형태로 나타납니다.

### 모든 것은 변할 수 있습니다.

프로그래밍에서 변화는 불가피하며, 이는 유저의 요구, 디자인 표준, 라이브러리나 툴의 변화 등으로 발생합니다.
이 변화는 지식의 반복을 가져와 프로젝트 확장 가능성을 떨어뜨릴 수 있기에 유의해야 합니다.

### 코드 반복을 허용하는 경우

두 코드 조각이 비슷해 보이더라도 실질적으로 다른 정보를 나타내는 경우에는 코드의 반복이 허용될 수 있습니다.
이를 결정하는 요인은 "두 코드가 함께 변경될 가능성이 더 큰가, 아니면 별도로 변경될 가능성이 더 큰가?"를 두고 고민해야 합니다.

### 단일 책임 원칙

SOLID 원칙 중 하나로, 클래스는 단 한 가지의 이유로만 변화해야 한다는 규칙을 제시합니다.
이 규칙은 코드를 추출하지 않고 독립적으로 변경될 가능성이 더 큰 경우에 특히 중요합니다.

---

## Item 20 : 공통 알고리즘 반복 금지

### 반복 알고리즘 추출 및 장점

알고리즘의 반복적인 사용은 코드의 비효율성을 야기하며, 이를 개선하기 위해 공통 알고리즘을 별도의 모듈이나 라이브러리로 추출하는 것이 중요하며 이를 통해 다음과 같은 장점을 제공합니다.

- 프로그래밍 속도 향상: 코드 작성이 빠르게 진행되며, 개발 효율성이 증가합니다.
- 코드 인식 용이성: 알고리즘에 이름을 부여함으로써 코드 이해가 쉬워집니다.
- 특이점 쉽게 발견: 코드 복잡성을 줄이고, 특이한 로직을 쉽게 찾을 수 있습니다.
- 최적화의 공통 이점: 한 번의 최적화로 모든 곳에서 효과를 볼 수 있습니다.

### 표준 라이브러리의 이용

표준 라이브러리는 일반적으로 공통 알고리즘의 모음이며, 이를 이용함으로써 불필요한 알고리즘 개발을 줄일 수 있습니다.

### 커스텀 유틸리티 구현의 필요성

프로젝트에는 표준 라이브러리에서 제공되지 않는 알고리즘이 필요한 경우도 있습니다.
이럴 때에는 커스텀 유틸리티 함수로 해당 알고리즘을 정의하여 사용하면 됩니다.

구현 전, 표준 라이브러리에서 제공되는지는 않는지 검색 하여 불필요한 함수 정의를 피하는게 좋습니다.
또한 확장 함수는 상태를 가지지 않으며 부작용이 없는 행동을 표현하는데 적합하므로 확장 함수를 활용하는 것이 좋습니다.

---

## Item 21 : Property Delegation

### Property Delegation 기능 및 예시

Kotlin은 코드 재사용을 향상시키는 Property Delegation 기능을 제공합니다. 이 기능을 이용하면, 일반적으로 발생하는 Property 관련 동작을 쉽게 재사용할 수 있습니다.
이를 통해, 첫 번째 접근 시에만 초기화되는 `lazy` property와 같은 특성이나, 값이 변경될 때마다 특정 동작을 실행하는 `observable` property 등의 동작을 쉽게 재사용할 수 있습니다.

### Property Delegation 활용 다양한 패턴 추출

Property Delegation 메커니즘은 다양한 패턴을 추출하는데 사용될 수 있습니다. 이를
통해 `View-Resource Binding`, `DI(Dependency Injection)`, `Data Binding` 등과 같은 패턴을 구현할 수 있습니다.
이런 패턴들은 일반적으로 Java에서는 주석 처리가 필요하지만, Kotlin에서는 Property Delegation을 사용하여 쉽고 안전하게 구현할 수 있습니다.

### Property Delegation 활용 반복 패턴 추출

Kotlin의 Property Delegation 기능을 이용하면, 프로젝트에서 자주 사용하는 반복 패턴을 쉽게 추출할 수 있습니다.
예를 들어, `getter`와 `setter` 메소드를 가진 객체는 `getValue`와 `setValue` 함수를 통해 위임될 수 있습니다.
이 기능을 이용하여 다른 객체로부터 메소드를 위임받는 방식으로 반복되는 패턴을 쉽게 추출하고 재사용할 수 있습니다.
이는 코드의 가독성을 향상시키고 유지 관리를 쉽게 만듭니다.

---

## Item 22 : 공통 알고리즘 구현 시 제네릭 사용

### 제네릭 기능 및 사용 예시

Kotlin에서는 함수에 인자를 전달하는 것처럼, 타입을 타입 인자로 전달할 수 있습니다.
이런 타입 인자를 받는 함수를 제네릭 함수라고 하며, 제네릭 함수를 이용하면 코드를 좀 더 안전하게 작성할 수 있습니다.

### 제네릭 사용으로 프로그램 안전성 향상

Kotlin의 제네릭 기능을 이용하면 컴파일러가 타입을 좀 더 정확하게 확인하고 추론할 수 있습니다.
이를 통해 프로그램의 안전성이 향상됩니다. 일반적으로 제네릭은 클래스와 인터페이스에 도입되어, 특정 타입만을 가지는 컬렉션의 생성을 가능하게 합니다.

### 제네릭 제약조건 활용

제네릭의 중요한 특징 중 하나는 타입 매개변수를 특정 타입의 서브타입으로 제약할 수 있다는 것입니다.
이를 통해 특정 타입의 인스턴스가 해당 타입이 제공하는 모든 메소드를 사용할 수 있게 됩니다.
한 타입에 여러 개의 상위 제한을 설정해야 하는 경우에는, `where`를 사용하여 더 많은 제약을 설정할 수 있습니다.

---

## Item 23 : 타입 매개변수 섀도잉

### 섀도잉의 위험성

Kotlin에서는 섀도잉을 통해 속성과 매개변수를 같은 이름으로 정의할 수 있습니다.
이는 로컬 매개변수가 외부 범위의 속성을 섀도잉하는 결과를 초래합니다.
하지만, 이러한 동작은 종종 코드의 가독성을 저해하고, 개발자가 실수를 범할 수 있는 여지를 제공합니다.

### 타입 매개변수 섀도잉 문제점

함수의 타입 매개변수가 클래스의 타입 매개변수를 섀도잉하는 상황은 코드의 가독성을 더욱 떨어뜨립니다.
이는 주로 제네릭의 작동 방식을 제대로 이해하지 못한 개발자들이 범하는 실수이며, 이런 실수는 심각한 문제를 초래할 수 있습니다.

### 타입 매개변수 섀도잉 해결책

타입 매개변수 섀도잉의 문제를 해결하기 위한 가장 간단한 방법은 타입 매개변수에 제네릭을 사용하도록 변경하는 것입니다.
이렇게 하면 클래스의 타입 매개변수와 함수의 타입 매개변수가 혼동되는 문제를 피할 수 있습니다.
만약 새로운 타입 매개변수를 도입해야 하는 경우에는, 서로 다른 이름을 사용하거나 다른 타입 매개변수의 하위타입으로 제한하는 것이 좋습니다.

---

## Item 24 : 제네릭 타입의 공변성과 반공변성 고려

### variance modifier `in`, `out`

변위 수식어 `out`와 `in`을 통해 제네릭 타입 간의 관계를 설정할 수 있습니다.  
`out`은 타입 파라미터를 공변(covariant)으로 만들어 주어, A가 B의 하위 타입일 때 `Cup<A>`가 `Cup<B>`의 하위 타입이 됩니다.  
반대로, `in`은 타입 파라미터를 반공변(contravariant)으로 만들어 주어, A가 B의 하위 타입일 때 `Cup<A>`가 `Cup<B>`의 상위 타입이 됩니다.

### Function Type

함수 타입에서는 파라미터 타입이 반공변적(`in` 수정자)이고 반환 타입은 공변적(`out` 수정자)입니다.  
오직 반환(생성 또는 공개)만 하는 타입에 대해서는 공변성(`out` 수정자)을 사용합니다.  
오직 받아들이는 타입에 대해서는 반공변성(`in` 수정자)을 사용합니다.

### variance modifier 안정성

`in`과 `out` 제한자는 타입 안정성을 보장하는 중요한 도구입니다.  
`out` 제한자가 붙은 타입은 오직 [읽기 전용](../../용어.md#in-positions)이며 반대로 `in` 제한자가 붙은 타입은 오직 [쓰기 전용](../../용어.md#out-positions) 타입입니다.  
이 둘은 모두 제네릭 타입에 대해 추가적인 유연성을 제공하면서도, 타입 안정성을 손상시키지 않습니다.

### variance modifier 위치

variance modifier의 위치는 2가지 위치에서 사용될 수 있습니다.

- 일반적인 선언 위치(declaration-side) : 이는 클래스나 인터페이스 선언에 붙어 해당 클래스나 인터페이스가 사용되는 모든 곳에 영향을 줍니다.
- 사용 위치(use-side) : 이는 특정 변수에 대한 변위 제한성입니다. 이는 모든 인스턴스에 대해 변위 제한성이 적용될 필요가 없으나, 특정 변수에는 필요한 경우 사용됩니다.

