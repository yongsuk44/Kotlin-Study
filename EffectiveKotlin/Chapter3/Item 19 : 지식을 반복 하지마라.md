# Item 19: 지식을 반복 하지마라 

## 지식 (knowledge)
프로그래밍에 있어 '지식'을 더욱 넓게 해석하면, 모든 의도적인 정보가 그것이 될 수 있습니다.  
이 정보는 코드나 데이터를 통해 나타낼 수 있고, 또는 코드나 데이터의 부재를 통해 표현될 수 있습니다. 
즉, 우리가 기본적인 행동을 사용하고자 한다는 것을 의미합니다.

예를 들어, 상속을 받아 메소드를 오버라이드하지 않을 때, 이는 우리가 해당 메소드가 상위 클래스와 동일하게 동작하기를 원한다는 것을 나타냅니다.  

이렇게 지식을 정의하면, 프로젝트의 모든 부분이 어떤 형태로든 '지식'이 됩니다.

### 지식의 종류 예
 
지식의 종류는 매우 다양하며 다음과 같은 예가 있습니다. 
- 알고리즘이 어떻게 작동해야 하는지 
- UI가 어떤 모습이어야 하는지
- 어떤 결과를 얻고자 하는지

또한 이 지식을 표현하는 방법은 다음과 같을 수 있습니다.
- 코드를 사용
- 구성(configurations)을 활용
- 템플릿을 사용  

결국, 우리 프로그램의 모든 부분은 도구, 가상 머신, 또는 다른 프로그램이 이해할 수 있는 정보입니다.

프로그램에서 특히 중요한 두 가지 지식의 종류는 다음과 같습니다.

- 로직 : 프로그램이 어떻게 동작하며 어떻게 보여야 하는지에 대한 우리의 기대치
- 공통 알고리즘 : 기대하는 동작을 달성하기 위해 구현한 알고리즘들

이 두 가지의 핵심적인 차이점 다음과 같습니다.
- 비즈니스 로직은 시간이 흐르며 계속 변화, 
- 공통 알고리즘은 일단 정의되면 대체로 변경되지 않음

알고리즘은 최적화되거나, 다른 알고리즘으로 교체될 수는 있지만, 알고리즘 자체는 대체로 안정적인 성격을 가집니다.

---

## 모든 것은 변할 수 있습니다.

프로그래밍 세계에서 변화는 유일한 상수입니다.   
과거의 프로젝트를 생각해보면, 오늘날에는 다른 라이브러리, 아키텍처, 디자인을 사용할 것입니다. 

변화는 종종 예상치 못한 곳에서 발생하며, 이러한 변화는 유저의 필요와 습관, 디자인 표준, 라이브러리나 툴의 변화 등 
다양한 이유로 인해 프로젝트의 지식이 계속 변화하게 됩니다.

하지만 이 변화의 가장 큰 문제는 '지식의 반복'입니다.  
예를 들어, 프로젝트 내 다양한 곳에서 사용되는 버튼의 디자인이 변경된다면, 각각의 위치에서 디자인을 바꾸는 것은 번거롭고 실수를 유발할 수 있습니다.   
또한, 데이터베이스의 테이블 이름을 바꾸는 경우, 모든 SQL 문이 이에 맞게 수정되지 않으면 큰 문제가 발생할 수 있습니다.

이런 지식의 반복은 프로젝트의 확장 가능성을 낮추고 취약하게 만듭니다.   
이러한 문제의 해결책으로 개발자들은 지식의 중복을 제거하기 위해 다양한 도구와 기능을 만들어왔습니다.   

대부분의 플랫폼에서는 버튼에 대한 사용자 정의 스타일을 정의하거나, 사용자 정의 뷰/컴포넌트로 표현할 수 있습니다.
텍스트 형식으로 SQL을 작성하는 대신 ORM 이나 DAO를 사용할 수 있습니다.

이와 같이 도구들은 추상화의 다양한 형태를 제공하며, 프로젝트를 다양한 종류의 중복성으로부터 보호합니다. 
이러한 도구와 기능의 발달은 지식의 반복을 줄이고 변화에 대비할 수 있는 능력지니게 할 수 있습니다.

## 코드가 반복되는 것을 허용하는 경우

코드 반복을 허용해야 하는 경우는 두 코드 조각이 비슷해 보이지만 실질적으로 다른 지식을 나타낼 때입니다.   
예를 들어, 동일한 프로젝트의 독립적인 두 Android 애플리케이션의 빌드 설정이 비슷해도, 애플리케이션은 독립적이므로 설정 변경은 대개 한 앱에서만 필요합니다.   

위 상황을 결정짓는 가장 중요한 질문은 "두 코드가 함께 변경될 가능성이 더 큰가, 아니면 별도로 변경될 가능성이 더 큰가?"입니다. 
비즈니스 규칙이 서로 다른 출처에서 왔다면, 이들은 독립적으로 변경될 가능성이 크므로 "단일 책임 원칙"에 따라 코드를 추출하지 않아야 합니다.


## 단일 책임 원칙

'단일 책임 원칙'은 SOLID 원칙 중 하나로, "클래스는 단 한 가지의 이유로만 변화해야 한다"는 규칙을 제시합니다.   
이 규칙은 2개 이상의 액터(변경의 원인)가 동일한 클래스를 변경하는 상황을 피해야 한다는 것을 강조합니다.

예를 들어, 대학의 '장학부서'와 '인증부서'가 '학생' 클래스를 사용하는 경우를 생각해보겠습니다.   
부서는 각각 '학생이 통과하는지'와 '학생이 장학금 자격을 갖추었는지'를 판단하는 함수를 만들었습니다.   
두 함수 모두 학생이 지난 학기에 얼마나 많은 점수를 얻었는지 계산해야 합니다.

그런데 어느 날 교장이 장학금 계산을 위해 일부 과목을 제외하기로 결정했습니다.
이로 인해 '장학금 자격을 판단하는 함수'를 수정하는 개발자가 '학생이 통과하는지 판단하는 함수'의 동작도 함께 변경하는 결과를 가져왔습니다.
이로 인해 통과해야 할 학생들이 학기를 실패했다는 통보를 받게 되었습니다.

위 예시를 통해 '단일 책임 원칙'은 다음 2가지를 알려줍니다.
1. 서로 다른 소스에서 오는 지식 (여기서는 두 개의 다른 부서)은 독립적으로 변할 가능성이 크기에, 다른 지식으로 다루어야 합니다.
2. 다른 지식들을 분리 하지 않으면 재사용이 가능한 부분과 그렇지 않은 부분을 구별하는 것이 어렵습니다.
   또한, 재사용해서는 안 될 부분이 재사용되는 문제가 발생할 수 있습니다.