# 공통되는 알고리즘을 반복 하지마라

개발자들이 종종 같은 알고리즘을 계속해서 다시 구현하는 것을 볼 수 있습니다.  
여기서 알고리즘이란 프로젝트에 특화된 것이 아니라, 별도의 모듈이나 라이브러리로 추출될 수 있는 비즈니스 로직을 포함하지 않은 패턴을 의미합니다.   
이는 '수학적 연산', '컬렉션 처리' 또는 다른 '공통적인 동작' 등을 포함할 수 있습니다.

예를 들어, 범위 내에서 숫자를 제어하는 아래와 같은 간단한 예시가 있습니다.

```kotlin
val percent = when {
    numberFromUser > 100 -> 100
    numberFromUser < 0 -> 0
    else -> numberFromUser
}
```

하지만, 이는 이미 표준 라이브러리('stdlib')에 `coerceIn` 확장 함수로 정의되어 있으므로 직접 구현할 필요가 없습니다.

```kotlin
val percent = numberFromUser.coerceIn(0, 100)
```

## 짧지만 반복 적인 알고리즘을 추출하는 장점

#### 프로그래밍이 빨라집니다
짧지만 반복적인 알고리즘을 별도의 함수나 모듈로 추출하면, 코드 작성이 빨라집니다.  
함수 호출 한 번이 여러 단계로 이루어진 알고리즘을 직접 코딩하는 것보다 시간을 덜 소모하기 때문입니다. 
이러한 방식으로 불필요한 코딩을 줄이고 개발 효율성을 높일 수 있습니다.

#### 알고리즘에 이름이 있어 인식이 쉽습니다
알고리즘에 이름을 부여하면 해당 구현체를 일일이 읽어 이해하는 대신, 알고리즘의 이름을 통해 그 기능을 쉽게 알 수 있습니다.   
따라서 코드를 읽는 사람이 해당 알고리즘이 어떤 기능을 하는지 빠르게 이해할 수 있으며, 이미 해당 알고리즘을 알고 있는 개발자라면 그 개념을 더욱 쉽게 파악할 수 있습니다.

#### 노이즈를 제거하여 특이점을 쉽게 발견합니다
알고리즘을 분리하면, 코드의 복잡성이 줄어들어 더 직관적으로 보입니다.  
이는 코드 안에서 특이한 로직이나 예외 사항을 쉽게 찾아낼 수 있도록 돕습니다.   
긴 알고리즘을 한눈에 보는 것은 어려울 수 있지만, 알고리즘이 각각의 모듈로 나누어져 있으면 훨씬 이해하기 쉬워집니다.

#### 한 번의 최적화로 공통 이점을 얻습니다
알고리즘을 별도의 함수로 만들면, 그 함수의 성능을 최적화하는 데 필요한 노력을 한 번만 기울이면 됩니다. 
그러면 그 함수를 사용하는 모든 곳에서 이 최적화의 효과를 누릴 수 있습니다.   
반면에, 알고리즘이 코드의 여러 부분에 반복적으로 구현되어 있다면, 각각의 구현마다 최적화를 해야 하므로 비효율적일 수 있습니다.

## 표준 라이브러리를 배우자

공통 알고리즘은 거의 항상 이미 누군가에 의해 정의되어 있습니다.
대부분의 라이브러리는 공통 알고리즘의 모음일 뿐입니다. 특히 표준 라이브러리(stdlib)는 주로 확장 함수로 정의된 유틸리티의 거대한 모음입니다.   
표준 라이브러리 함수를 배우는 것은 어려울 수 있지만, 그만한 가치가 있습니다. 만약 사용하고자 하는 알고리즘의 표준 라이브러리가 없다면, 개발자들은 계속해서 알고리즘을 개발하게 됩니다.

## 커스텀 유틸리티 구현

모든 프로젝트에서 어느 시점에는 표준 라이브러리에 없는 알고리즘들이 필요합니다.
예를 들어, 컬렉션에서 숫자의 곱을 계산해야 하는 경우가 있을 수 있습니다.

이러한 경우에는 보편적인 유틸리티 함수로 정의하는 것이 좋습니다.

```kotlin
fun Iterable<Int>.product() = fold(1) { acc, i -> acc * i }
```

이러한 함수는, 다른 개발자가 나중에 사용해야 하는 경우 이미 정의되어 있어서 시간을 단축시킬 수 있습니다.  
각 함수는 테스트되어야 하며, 기억되고 유지되어야 하므로 비용으로 간주되어야 합니다.
필요하지 않은 함수를 정의하지 않도록 주의해야 하며, 커스텀으로 유틸리티를 구현하기 전에 기존에 존재하는지 먼저 검색해야 합니다.

표준 라이브러리에서 대부분의 함수처럼, `product`는 확장 함수입니다.   
공통 알고리즘을 추출하는 방법은 여러 가지가 있지만, 확장 함수는 좋은 선택입니다.
이는 함수가 상태를 가지지 않으며 부작용이 없는 행동을 표현하는 데 완벽하기 때문입니다.