프로그래밍에서 지식은 넓게 정의하면 '의도적으로 생성된 모든 정보 조각'을 의미하며, 코드나 데이터로 표현할 수 있다.  
또한 코드나 데이터가 없는 경우에도 지식으로 표현될 수 있는데, 이렇게 표현되는 것은 기본 동작을 사용하고 싶다는 것을 의미한다.  
예를 들어, 상속을 받고 메소드를 오버라이드하지 않을 때, 이는 해당 메소드가 상위 클래스와 동일하게 동작하기를 원한다는 것을 나타낸다.

이와 같이 지식을 표현하는 방법은 다양하며, 회사 프로젝트의 모든 것이 아래와 같이 어떤 종류의 지식이 될 수 있다.

- 알고리즘이 어떻게 동작해야 하는지
- UI가 어떻게 보여야 하는지
- 원하는 결과가 무엇인지

이러한 여러 종류의 지식들은 다음과 같은 방식으로 표현할 수 있다.

- 코드 : 가장 직접적인 지식 표현 방식으로, 함수, 클래스, 변수 등을 통해 구체적인 동작과 로직을 표현한다.
- 구성 : 앱의 동작 환경을 정의하는 방식으로, 런타임에 프로그램의 행동을 조정할 수 있다.
- 템플릿 : 문서•UI 레이아웃•코드 구조 등을 미리 정의하여, 재사용 가능한 형태로 만들 수 있다.

결과적으로, 프로그램의 모든 요소는 어떤 형태로든 정보를 담고 있으며, 해당 정보는 컴파일러, 인터프리터, 가상 머신 또는 다른 프로그램에 의해 해석되고 실행된다.
이 중 프로그램에서 중요한 두 가지 지식의 종류가 있는데, 이는 다음과 같다.

- 로직 : 프로그램이 어떻게 동작하기를 기대하는지, 그리고 그것이 어떻게 보여야 하는지에 대한 기대
- 공통 알고리즘 : 기대하는 동작을 달성하기 위해 구현한 알고리즘들

이 두가지의 차이점은 비지니스 로직은 시간이 지남에 따라 많이 변경되는 반면, 공통 알고리즘은 일단 정의되면 대체로 변경되지 않는다.  
알고리즘은 최적화되거나 다른 알고리즘으로 대체될 수 있지만, 알고리즘 자체는 대체로 안정적인 성격을 가진다.

---

## Everything can change

프로그래밍에서 유일한 상수는 변화라는 말이 있다.   
엄청 오랜 시간은 아니지만, 5 ~ 10년 전의 프로젝트들을 생각해보면 변하지 않는 앱 또는 웹이 있을까??  
또한, 기술뿐만 아니라 언어도 매우 빠르게 변하는데 Android OS는 08년에 출시하였고, Kotlin의 안정화된 첫 버전은 16년에 출시 되었다.  
또한 과거의 프로젝트를 회상하면, 오늘날에는 다른 라이브러리, 아키텍처, 디자인을 사용할 것이다.

UI 디자인과 기술은 훨씬 더 빠르게 변하며, 이로 인해 사용자들에 대한 요구사항도 매일 변경되는 경우가 많다.  
이에 따라 프로젝트에 대한 지식들도 빠르게 변화되며, 아래는 프로젝트에 대한 지식들이 변경되는 이유들이다.

- 타임라인에 따라 사용자 요구사항이 변경될 수 있으며, 서비스는 이에 대응하여 변경되어야 한다.
- UX 연구, 기술 발전, 산업 트렌드 등의 변화에 따라 UI 디자인이 변경될 수 있다.
- 플랫폼, 라이브러리, 도구 등의 지속적인 발전으로 새로운 기능이 추가되고, 기존 기능이 폐기됨에 따라 프로젝트의 지식이 변경될 수 있다.

현대의 소프트웨어 개발에서 요구사항과 내부 구조의 지속적인 변화는 거의 필수 요소이다.  
이는 기술의 발전, 경쟁 환경의 변화, 사용자 피드백의 통합 등 여러 요인에 의해 주도된다.  
이러한 변화를 관리하는 것은 프로젝트를 현재와 미래의 시장 요구사항에 맞게 조정하고, 제품을 지속적으로 개선하는데 중요하다.

하나의 사례로, 'Slack'은 요구사항의 변화와 프로젝트 방향의 전환을 잘 보여주는 사례이다.  
원래 게임으로 시작했지만, 사용자의 피드백과 시장의 요구사항에 따라 커뮤니케이션 도구로 전환하여 성공을 거두었다.

지식의 변화에 가장 큰 문제는 '지식의 반복'이다.  
예를 들어, 프로젝트 내 다양한 곳에서 사용되는 버튼의 디자인이 변경된다면, 각각의 위치에서 디자인을 바꾸는 것은 번거롭고 실수를 유발할 수 있다.  
또한, 데이터베이스의 테이블 이름을 바꾸는 경우, 모든 SQL 문이 이에 맞게 수정되지 않으면 큰 문제가 발생할 수 있다.

이처럼, '지식의 반복'은 프로젝트의 확장 가능성을 낮추고 취약하게 만든다.  
이런 문제를 해결하기 위해 개발자들은 지식의 중복을 제거하기 위해 다양한 도구와 기능을 만들어왔다.

위 예시에서는 대부분의 플랫폼에서는 버튼에 대한 Custom Style / Custom View / Component 등을 작성해 지식의 반복을 줄일 수 있다.  
또한, 텍스트 형식으로 SQL을 작성하는 대신, ORM이나 DAO를 사용하여 지식의 반복을 줄일 수 있다.

이러한 해결 방법들은 다양한 종류의 추상화를 나타내며, 프로젝트를 다양한 종류의 중복성으로부터 보호한다.

---

## When should we allow code repetition?

비슷해 보이는 코드 블록들이 실제로 동일한 기능을 수행하거나 동일한 문제를 해결하는 것이 아니다.  
때로는 유사한 코드가 다른 맥락에서 다른 목적으로 사용될 수 있으며, 이런 경우에는 코드를 단순히 추출하여 재사용하는 것은 적절하지 않다.

예를 들어, 같은 프로젝트 내에 두 개의 독립적인 안드로이드 앱이 있다고 가정해보자.  
두 앱은 비슷한 빌드 구성을 가지고 있을 수 있지만, 각각의 앱은 독립적인 요구사항과 개발 사이클을 가진다.  
만약, 빌드 구성을 하나의 공통된 구성으로 만들게 되면, 다음과 같은 문제점이 발생할 수 있다.

1. 한 앱에 구성이 변경되면 다른 앱에도 영향을 줄 수 있고, 이는 관리의 복잡성을 증가시킨다.
2. 기존의 표준 빌드 구성과 달리, 새로운 방식의 도입으로 개발자들이 익숙해져야 할 새로운 패턴과 규칙이 생기게 된다.

이처럼, 비슷해 보이는 코드 블록을 추출하고 재사용하는 결정은, 코드 블록들이 향후 어떻게 변경될 가능성이 있는지에 대한 고려가 필요하다.

만약, 비슷한 코드 블록이 동일한 비지니스 로직이나 요구사항에 의해 영향을 받는 경우, 함께 변경될 가능성이 높기에 공통 로직으로 추출하고 재사용하는 것이 효율적이다.
반면, 비슷해 보이지만 서로 다른 맥락이나 목적을 가지고 있는 경우, 별도로 변경될 가능성이 높기에 강제로 코드를 합치는 것은 향후 변경을 어렵게 만들고, 유연성을 떨어뜨릴 수 있다.

---

## Single responsibility principle

SOLID 원칙 중 공통 코드를 추출하지 말아야 하는 상황을 알려주는 매우 중요한 원칙이 바로 '단일 책임 원칙'이다.  
'단일 책임 원칙'은 클래스가 변경되어야 하는 이유가 하나여야 한다는 원칙이다.  
이 규칙은 "2명의 액터가 동일한 클래스를 변경하는 상황이 없어야 한다"는 선언으로 간소화할 수 있다.

여기서 액터는 클래스나 모듈에 변경을 요구하는 어떤 외부 요소를 의미한다.  
이 액터는 다양한 관점에서 변경을 주도할 수 있으며, 이는 개발자, 관리자 또는 외부 시스템 일 수 있다.  
액터가 여럿인 경우, 그들 각각의 요구사항이 충돌할 수 있으므로, 이러한 상황을 피해야 한다.

예를 들어, 대학의 '장학 부서'와 '인증 부서'가 '학생' 클래스는 사용된다고 가정해보자.  
각 부서의 개발자들은 다음 두 함수를 도입했다.

- `isPassing` : '인증 부서'에서 사용되며, 학생의 합격 유무
- `qualifiesForScholarship` : '장학 부서'에서 사용되며, 학생의 장학금 자격 유무

두 함수 모두 지난 학기의 점수에 대한 계산이 필요하므로, `calculatePointsFromPassedCourses`라는 함수를 추출했다.

```kotlin
class Student {
    fun isPassing(): Boolean =
        calculatePointsFromPassedCourses() > 60

    fun qualifiesForScholarship(): Boolean =
        calculatePointsFromPassedCourses() > 80

    private fun calculatePointsFromPassedCourses(): Int {
        // ...
    }
}
```

그런데, 어느 날 교장이 장학금 계산을 위해 일부 과목을 제외하기로 결정했다.  
이로 인해, '장학 부서' 개발자는 `qualifiesForScholarship`를 수정하기로 결정되었고, `calculatePointsFromPassedCourses`도 함께 수정하였다.
하지만, 이는 의도치 않게 `isPassing`에 영향을 주었고, 합격해야 할 학생들이 학기에 불합격 했다는 통보를 받게 되었다.

일반적으로 같은 클래스나 파일 내에 위치한 두 기능이 서로 강하게 의존하게 되면 위와 같은 문제가 발생 할 수 있다.  
이를 해결하려면, 기능이나 역할을 별도의 클래스로 추출하는 것으로 간단하게 해결할 수 있을 것이다.

이처럼, `calculatePointsFromPassedCourses`를 추출하는 과정에서 고려 할 점은, 이 함수가 서로 다른 맥락에서 사용될 수 있는지에 대한 여부이다.  
예를 들어, `isPassing`과 `qualifiesForScholarship`는 비슷한 연산을 수행할 수 있지만, 실제로는 서로 다른 기준과 목적을 가진다.  
이 두 함수가 공통으로 사용하는 `calculatePointsFromPassedCourses`를 추출할 때, SRP는 중요한 가이드라인이 될 수 있다.

- 두 부서가 공유하는 모듈 내에 일반적인 'public-function'를 정의하여, 공통 연산 로직에 대한 컨벤션을 정하고 중앙에서 관리할 수 있다.  
  이 접근법은 코드의 중복을 줄이고, 유지보수성을 용이하게 한다. 그러나, 한 부서의 요구 사항이 변경되면, 다른 부서에 무조건 영향을 준다.
- 각 부서를 위한 별도의 보조 함수를 만들면, 각각의 요구사항에 맞춰 더 세밀한 조정이 가능하다.  
  이는 더 유연성을 갖지만, 코드의 중복과 유사한 연산을 여러 곳에서 관리해야 하는 부담이 있다.

위 예시를 통해 '단일 책임 원칙'은 다음 2가지를 알려준다.

1. 서로 다른 소스에서 (여기서는 두 개의 다른 부서) 오는 지식은 독립적으로 변할 가능성이 크기에, '서로 다른 지식'으로 다루어야 한다.
2. '서로 다른 지식'들을 분리 하지 않으면, 재사용이 가능한 부분과 그렇지 않은 부분을 구별하는 것이 어렵다.  
   또한, 재사용해서는 안되는 부분을 재사용 할 수 있는 실수가 발생할 수 있다.