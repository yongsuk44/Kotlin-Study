# 목차

- [Item 45 : 불필요 객체 생성 피하기](#item-45--불필요-객체-생성-피하기)
- [Item 46 : 함수 타입 파라미터가 있는 함수에 inline 키워드 사용하기](#item-46--함수-타입-파라미터가-있는-함수에-inline-키워드-사용하기)
- [Item 47 : Inline Class 사용 고려](#item-47--inline-class-사용-고려)
- [Item 48 : 사용되지 않은 객체 참조 정리](#item-48--사용되지-않은-객체-참조-정리)

## Item 45 : 불필요 객체 생성 피하기

불필요 객체 생성은 메모리 사용과 성능에 영향을 미치는 중요한 요소로 객체 생성시 3가지 비용이 발생하게 됩니다.
비용으로는 객체의 메모리 공간 차지, 캡슐화 시 메서드 호출 비용, 객체 생성 과정에서 거치는 비용 등이 있습니다.

### object 선언 및 팩토리 함수와 캐시 활용

`object` 선언을 통해 싱글톤 패턴을 구현할 수 있으며 재사용 가능한 객체를 하나의 인스턴스로 생성하여 불필요 객체 생성을 피할 수 있습니다.

팩토리 함수를 사용하여 객체 생성을 캡슐화하고 필요에 따라 캐시를 사용하여 이미 생성된 객체를 재사용할 수 있습니다.
또한 객체 풀을 가지는 방법도 불필요 객체 생성을 줄이는 좋은 방법이 될 수 있습니다.

캐싱을 통해 계산 비용이 큰 함수를 최적화할 수 있지만 나중에 메모리 사용량이 늘어날 수 있는 문제가 발생할 수 있습니다.
이는 `SoftReference`를 통해 메모리 문제를 완화할 수 있습니다.

### 성능 향상을 위한 다양한 기법

리프팅 기법은 반복 처리에서 무거운 연산을 최소화하는 방법으로 객체 내부 메서드 생성 비용을 최적화 할 수 있습니다.

Lazy 초기화는 객체 생성 시점을 늦추어 하나의 클래스에서 여러 객체의 인스턴스를 사용할 때 불필요 객체 생성을 피해 생성 비용을 최적화 할 수 있습니다.

원시 타입 최적화는 기본 타입을 사용하여 래핑된 클래스를 사용하는 것보다 메모리 사용량을 줄일 수 있습니다.

---

## Item 46 : 함수 타입 파라미터가 있는 함수에 inline 키워드 사용하기

Kotlin 표준 라이브러리에서 대부분의 고차 함수에는 `inline` 수식어가 정의되어 있습니다.  
`inline` 함수는 컴파일 도중 해당 함수의 구현을 함수 본문으로 대체합니다.
또한, 함수 인자로 전달된 함수 호출도 해당 함수들의 본문으로 대체됩니다.

### 타입 인자가 실체화될 수 있습니다.

일반적으로 제네릭 함수는 컴파일 시점에 타입 인자 정보를 잃어버리는데 `inline` 함수를 사용하면 이를 피할 수 있습니다.

`reified` 수식어와 함께 사용하면 컴파일 타임에 타입 정보를 유지하고 런타임에도 이를 활용할 수 있습니다. 이로 인해 제네릭 타입의 클래스를 검사하는 등의 작업이 가능해집니다.

### 파라미터가 함수타입 일 때 inline 함수가 더 빠릅니다.

`inline` 함수는 호출되는 시점에서 함수 본문으로 대체되기 때문에 별도의 함수 호출 비용이 없습니다.
따라서 함수를 파라미터로 전달할 때 발생하는 오버헤드가 없습니다.

### Non-local return 허용

`inline` 함수를 사용할 때 내부 함수(람다)에서도 외부 함수를 벗어날 수 있습니다.
이를 통해 코드의 가독성과 흐름 제어를 향상 시킬 수 있습니다.

### reified 타입 인자와 inline 함수 활용

`reified`와 `inline`을 함께 사용하면 제네릭 함수의 타입 정보를 유지할 수 있고, 런타임에도 이를 활용할 수 있습니다.

### inline 수식어 비용

`inline` 함수는 모든 경우에 사용할 수 없습니다. 재귀로 사용하거나 반복적인 사이클을 만드는 경우에는 문제가 발생할 수 있습니다. 또한 `inline` 함수는 가시성을 제한한 요소를 사용할 수 없습니다.

### Crossinline과 noinline

`crossinline`과 `noinline` 수식어를 사용하면 `inline` 함수를 유연하게 다룰 수 있습니다.

`crossinline`은 함수가 `inline`되어야 하지만 'non-local return'이 허용되지 않음을 의미하며, `noinline`은 인수가 `inline`되지 않아야 함을 의미합니다.

---

## Item 47 : Inline Class 사용 고려

`inline class`는 Kotlin에서 제공하는 기능으로, 단일 생성자 속성을 가진 클래스를 그 값으로 대체할 수 있습니다.   
`inline class`는 성능 오버헤드 없이 특정 타입을 래핑하는 데 사용되며, 아래 두 가지 목적으로 활용됩니다

### 측정 단위 표현

`inline class`를 이용하면 측정 단위를 더 명확하게 표현할 수 있습니다.

예를 들어, 타이머의 호출 지연 시간을 나타내는 인자로 단순히 정수 값을 사용하는 것보다 `Millis`나 `Minutes` 등의 `inline class`를 이용하면 가독성이 향상되고 실수를 줄일 수 있습니다.
특히 단위가 여러 개인 경우에는 `inline class`가 더욱 유용하게 사용될 수 있습니다.

### 타입 오용 방지

`inline class`를 사용하면 타입 오용을 방지할 수 있습니다.

예를 들어 DB의 여러 컬럼을 Int 타입의 ID 필드로 관리하는 경우가 많은데, 이 ID를 잘못 사용하기 쉽기에 `inline class`로 래핑하면 타입 오용을 방지할 수 있습니다.
각 ID를 래핑하면 컴파일러가 타입 오류를 캐치할 수 있으며, 컴파일 시에는 모든 타입이 원래의 기본 타입으로 대체되므로 성능에 영향을 주지 않습니다.

### inline class와 interface

`inline class`가 인터페이스를 구현하는 경우, 인터페이스를 통해 접근할 때는 `inline class`의 성능 이점을 잃게 됩니다.
인터페이스를 통해 `inline class`의 인스턴스에 접근하려면 실제 객체가 필요하므로 성능 최적화가 어렵습니다.

### typealias

`typealias`는 기존 타입에 새로운 이름을 부여하는 데 유용하지만, 실제로는 새로운 타입을 만들지 않으므로 타입 오용을 방지하는 데에는 `inline class`를 사용하는 것이 더 효과적입니다.
측정 단위를 나타내는 경우에도 `typealias`보다는 `inline class`를 사용하는 것이 권장됩니다.

---

## Item 48 : 사용되지 않은 객체 참조 정리

개발자들은 메모리 관리에 대해 항상 신경 써야 하며 더 이상 사용되지 않은 객체에 대한 참조를 잘 정리해주어야 합니다. 
Android에서 이를 실천하지 않으면 메모리 누수가 발생하며, OOM(Out of Memory)등의 이슈가 발생할 수 있습니다. 
이런 이슈는 메모리 부족으로 앱의 성능을 저하시키거나 심지어는 앱이 충돌하는 원인이 될 수 있습니다.

### 메모리 누수 방지 

무거운 객체를 참조하는 경우, 해당 객체가 더 이상 사용되지 않을 때 참조를 해제해주어야 합니다.
이를 위해 `WeakReference`를 사용할 수 있습니다. `WeakReference`는 GC에 의해 메모리 관리가 이루어지므로 메모리 누수를 방지할 수 있습니다.

또한 메모리 누수를 찾기 위한 도구로는 HeapProfiler와 LeakCanary 등이 있습니다.