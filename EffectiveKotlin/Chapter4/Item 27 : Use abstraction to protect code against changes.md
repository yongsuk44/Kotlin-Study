함수나 클래스 같은 추상화를 통해 실제 코드를 숨기는 것은 개발자를 세부 사항으로부터 보호하는 것만이 아니라, 나중에 자유롭게 코드를 변경할 수 있도록 한다.
이는 대부분 그 변화를 인식하지 못하는 상황에서도 가능하다. 예를 들어, 정렬 알고리즘을 함수로 분리해두면, 나중에 사용 방식을 변경하지 않고도 성능을 최적화 할 수 있다.

또한 자동차에 비유해 보면, 제조사와 정비사는 자동차의 후드 안의 모든 것을 변경할 수 있으며, 작동 방식이 동일하게 유지되는 한 운전자는 그 차이를 알아차리지 못할 것이다.
이는 제조사가 자동차를 더 환경 친화적으로 만들거나, 더 많은 센서를 추가하여 안전성을 높일 수 있는 자유를 제공한다.

'Item 27'에서는 다양한 추상화 방법이 어떻게 다양한 변화로부터 개발자들을 보호하며, 그 과정에서 어떻게 자율성을 제공하는지 알아볼 것이다.  

## Constant

리터럴 상수 값들은 자체적으로 설명 없이 사용되는 경우가 많으며, 코드 내에서 여러 번 반복될 때 문제가 된다.  
이런 리터럴 상수 값을 상수 프로퍼티로 옮김으로써, 값에 의미 있는 이름을 부여할 수 있고, 상수를 변경해야 할 상황이 발생했을 때 더 용이하게 관리할 수 있다.

아래는 패스워드 유효성 검사가 포함된 예제 코드이다.

```kotlin
fun isPasswordValid(text: String): Boolean {
    if (text.length < 7) return false
    // ...
}
```

위 숫자 '7'은 문맥에 따라 이해할 수 있지만, 이를 상수로 추출하면 더 명확해진다.

```kotlin
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
    if (text.length < MIN_PASSWORD_LENGTH) return false
}
```

이 후에 복잡한 유효성 검증 로직을 이해할 필요 없이, 간단하게 상수 값을 조정하여 '최소 비밀번호 길이'를 더 쉽게 수정할 수 있다.  

위와 같은 이유로 인해, 여러 번 사용되는 값을 별도로 추출해 두는 것이 중요하다.  
예를 들어, 데이터 베이스에 동시에 연결할 수 있는 최대 스레드 수를 설정하는 경우 다음과 같다.

```kotlin
val MAX_THREADS = 10
```

이처럼 추출되고 나면, 필요할 때 쉽게 변경할 수 있다.  
만약 이 숫자가 프로젝트 전반에 걸쳐 퍼져 있다고 상상해보면, 변경하기가 얼마나 어려울 지 알 수 있다.

## Function

안드로이드 애플리케이션 개발 중 사용자에게 토스트 메시지를 알려야하는 경우가 있다고 가정해보면, 다음과 같이 구현할 것이다.

```kotlin
Toast.makeText(context, "Hello World!", Toast.LENGTH_SHORT).show()
```

위 토스트 메시지를 표시하는 공용 알고리즘을 아래와 같이 간단한 확장 함수로 추출할 수 있다.

```kotlin
fun Context.toast(
    msg: String,
    duration: Int = Toast.LENGTH_LONG
) {
    Toast.makeText(this, msg, duration).show()
}

context.toast("Hello World!")
```

이렇게 추출함으로 인해, 개발자는 매번 토스트를 어떻게 표시해야 하는지 기억할 필요가 없다.  
또한, 토스트를 표시하는 방식이 변경되는 경우에도 도움이 될 것이다.

하지만, 사용자에게 메시지를 표시하는 방식을 토스트에서 스낵바로 변경해야 한다면 어떻게 해야할까?  
간단한 해결책은 해당 기능을 이미 독립적으로 추출해 두었기 때문에, 함수 내부의 구현을 변경하고 이름을 바꾸면 된다.

```kotlin
fun Context.snackbar(
    msg: String,
    length: Int = Toast.LENGTH_LONG
) {
    // ...
}
```

하지만, 이 방법은 완전한 해결책이라고 볼 수 없다.

우선, 내부적으로 사용되더라도 함수의 이름을 변경하는 것은 위험할 수 있다. 특히, 이 함수를 사용하는 다른 모듈이 있다면 더욱 문제가 된다.  
또 다른 문제는 파라미터를 쉽게 변경 할 수 없기 때문에, 메시지 표시 시간을 선언하는데 토스트 API를 계속해서 사용해야 한다.  

스낵바를 표시할 때 토스트의 특정 필드에 의존하는 것은 문제가 될 수 있다.   
그렇다고, 스낵바의 `enum`으로 모두 변경하는 것 또한 문제가 될 수 있다.

```kotlin
fun Context.snackbar(
    msg: String,
    duration: Int = Snackbar.LENGTH_LONG
) {
    // ...
}
```

메시지가 표시되는 방식이 바뀔 가능성이 있다는 것을 알고 있으면, 이 메시지가 어떻게 보여지는가가 중요한게 아니다.     
바로, 사용자에게 메시지를 전달하고자 한다는 점이 중요하며, 이때 필요한 것은 메시지를 표시하는 더 추상적인 방법이다. 

이 사실을 인지하고 나면, 개발자는 토스트의 개념과 독립적인 보다 더 상위 수준의 함수인 'showMessage'를 통해 메시지를 표시할 수 있을 것이다.

```kotlin
enum class MessageLength { SHORT, LONG }

fun Context.showMessage(
    message: String,
    duration: MessageLength = MessageLength.LONG
) {
    val toastDuration = when (duration) {
        SHORT -> Length.LENGTH_SHORT
        LONG -> Length.LENGTH_LONG
    }

    Toast.makeText(this, message, toastDuration).show()
}

```

여기서 가장 큰 변화는 함수의 이름이다. 일부 개발자들은 함수 이름을 단지 라벨 정도로 여겨, 이 변화의 중요성을 간과할 수 있다.  
이런 관점은 컴파일러의 관점에서는 타당하지만, 개발자의 관점에서는 그러면 안된다.  
함수는 추상화를 나타내며, 함수의 시그니처는 자신이 어떤 추상화인지 알려주기에, 의미 있는 이름은 매우 중요하다.

함수는 매우 간단한 추상화 방법이지만, 상태를 보유하지 않기에 매우 제한적이다.  
또한, 함수의 시그니처가 변경되면 함수 사용법 전체에 영향을 줄 수 있기에, 더 강력하게 구현을 추상화하는 방법은 클래스를 사용하는 것이다.

## Class

위 메시지 표시를 클래스로 추상화하면 다음과 같이 작성할 수 있다.

```kotlin
enum class MessageLength { SHORT, LONG }

class MessageDisplay(val context: Context) {
    
    fun show(
        message: String,
        length: MessageLength = MessageLength.LONG
    ) {
        val toastDuration = when (length) {
            SHORT -> Length.Short
            LONG -> Length.Long
        }

        Toast.makeText(context, message, toastDuration).show()
    }
}

val msgDisplay = MessageDisplay(context)
msgDisplay.show("Hello World!")
```

클래스가 함수보다 더 강력하게 구현을 추상화 할 수 있는 이유는 상태를 유지할 수 있고, 여러 함수를 노출할 수 있기 때문이다.   
이 경우 클래스 상태에는 컨텍스트가 있으며, 이는 생성자를 통해 주입된다.

아래와 같이 의존성 주입 프레임워크를 사용하여 클래스 생성을 위임할 수 있다.

```kotlin
@Inject lateinit var msgDisplay: MessageDisplay
```

또한, 특정 클래스에 의존성을 가진 다른 클래스의 기능을 테스트하고자 할 때, 'Mock 객체'를 통해 해당 클래스를 대체할 수 있다.  
이는 테스트를 위해 클래스를 임의로 구현할 수 있기 때문에 가능한 접근 방식이다.

```kotlin
val msgDisplay: MessageDisplay = mockk()
```

또한, 메시지 표시 메서드를 더 추가할 수 있다.

```kotlin
msgDisplay.setChristmasMode(true)
```

보다시피, 클래스는 함수 보다 더 많은 자율성을 제공한다. 하지만, 여전히 한계점이 존재한다.

예를 들어, 'final'로 선언된 클래스는 상속을 통해 기능을 확장하거나 변경할 수 없어, 해당 클래스의 정확한 구현을 알고 있어야 한다.  
반면, 'open'으로 선언된 클래스는 상속이 허용되어 기존 클래스의 기능을 확장하거나 변경할 수 있는 서브 클래스를 제공할 수 있다.  
하지만, 이런 추상화도 결국 기존 상위 클래스와 강하게 연결되어 있기에, 상위 클래스의 변경이 파생 클래스에 영향을 미칠 수 있다.

클래스 보다 더 높은 수준의 자율성을 추구하려면, 해당 클래스를 인터페이스 뒤에 숨겨 더욱 추상적인 형태로 만드는 것이 좋다.

## Interface

Kotlin 표준 라이브러리를 읽다 보면, 아래와 같이 대부분 인터페이스로 표현되어 있음을 알 수 있다.

- `listOf()`는 인터페이스 `List`를 반환한다. 이는 다른 '팩토리 메서드'들도 비슷하게 적용된다.
- 컬렉션을 처리하는 함수들은 `Iterable` 또는 `Collection`에 대한 확장 함수이며, `List`, `Map` 등의 인터페이스를 반환한다.
- 'property delegation'은 `ReadOnlyProperty` 또는 `ReadWriteProperty` 인터페이스 뒤에 숨겨져 있다. 
이 인터페이스 뒤에 숨겨진 실제 클래스들은 대부분 'private'으로 선언되어 내부 구현을 숨기고, 사용자에게는 인터페이스만 노출 시킨다. 
또한, `lazy` 함수 역시 반환 타입으로 `Lazy` 인터페이스를 선언한다.

이처럼, 대부분의 라이브러리 개발자들은 내부 클래스의 'visibility'를 제한하고, 인터페이스를 통해 내부 구현을 제공한다.  
이렇게 하면, 라이브러리 개발자들은 사용자가 해당 클래스를 직접 사용하지 않음을 확신할 수 있기 때문에, 인터페이스가 변경되지 않는 한 구현체를 자유롭게 변경할 수 있다.
즉, **인터페이스 뒤에 객체를 숨김으로써, 실제 구현을 추상화하여 사용자가 이 추상화에만 의존하도록 강제함으로써, 결합도를 낮출 수 있다.**

Kotlin에서 클래스 대신 인터페이스를 반환하는 또 다른 이유는, Kotlin이 다중 플랫폼 언어이며, 동일한 `listOf`가 Kotlin/JVM, Kotlin/JS, Kotlin/Native에서는 각각 다른 리스트 구현체로 반환하기 때문이다.
Kotlin은 일반적으로 플랫폼 별로 특화된 네이티브 컬렉션을 사용하며, 모두 `List` 인터페이스를 준수하기 때문에 문제가 되지 않는다.

위 내용을 토대로 'MessageDisplay' 클래스를 인터페이스 뒤로 숨기는 예시를 보자.

```kotlin
enum class MessageLength { SHORT, LONG }

interface MessageDisplay {
    fun show(message: String, duration: MessageLength = LONG)
}

class ToastDisplay(val context: Context): MessageDisplay {
    
    override fun show(message: String, duration: MessageLength) {
        val toastDuration = when (duration) {
            SHORT -> Length.SHORT
            LONG -> Length.LONG
        }

        Toast.makeText(context, message, toastDuration).show()
    }
}

```

위와 같이, 인터페이스로 추상화하여 더 많은 자율성을 얻을 수 있다.

예를 들어, 태블릿에서는 토스트를 표시하는 클래스, 스마트폰에서는 스낵바를 표시하는 클래스를 각각 주입할 수 있다.  
더 나아가, Android, iOS, Web 간에 공유하는 공통 모듈에서 'MessageDisplay'를 구현할 수 있다.  
이를 통해 각 플랫폼에 맞게 다양한 구현을 적용할 수 있다.

또 다른 장점은 테스트를 위한 'Fake 인터페이스'가 'Mock 클래스' 보다 간단하고, 모킹 라이브러리를 필요로 하지 않는다.

```kotlin
val msgDisplay: MessageDisplay = TestMessageDisplay()
```

마지막으로, 선언부와 사용부가 더욱 분리되어 있어, 'ToastDisplay'와 같은 실제 클래스를 변경하는데 더 유연하다.  
그러나, 사용 방식을 변경하고 싶다면, 'MessageDisplay' 인터페이스와 이를 구현하는 모든 클래스들을 수정해야 한다.

## Next ID

프로젝트에 '유니크한 ID'가 필요하다고 가정해보자.  
매우 간단한 방법으로는 'Top-level 프로퍼티'에 ID를 저장하고, 새로운 ID가 필요할 때마다, 해당 값을 증가시키는 것이 가장 간단할 것이다.

```kotlin
var nextId: Int = 0

// usage
val newId = nextId++
```

그러나, 위와 같은 방법이 코드 곳곳에 사용되고 있다면, 
이는 프로그램을 새로 시작할 때마다 항상 0부터 시작하고, 'Thread-safe'하지 않기 때문에 수정되어야 한다.

현재로썬 위 솔루션을 사용해야 한다고 가정하면, ID 생성을 함수로 추출하여 변경으로부터 보호해야 한다.

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++

// usage
val newId = getNextId()
```

하지만, 이 솔루션은 아이디 생성 방식의 변경만을 방지하는 해결책일 뿐이며, 여전히 많은 변경 사항이 발생하기 쉽다.

예를 들어, 시스템에서 ID가 'Int'로 표현되고 있을 때, 이 사실에 의존하여 타입에 종속된 연산(숫자를 비교하여 어떤 ID가 더 오래되었는지 확인하는 등)을 수행할 수 있을 것이다.
그러나, 언젠가 ID를 'String'으로 변경해야 하는 상황이 생긴다면, 타입에 종속된 연산들은 더 이상 유효하지 않게되며, 시스템에 심각한 문제를 일으킬 수 있다.

이를 방지하고, 향후 ID 타입을 쉽게 변경할 수 있도록, ID를 별도의 클래스로 추출하는게 좋다.

```kotlin
data class Id(private val id: Int)

private var nextId: Int = 0
fun getNextId() = Id(nextId++)
```

이처럼, 추상화를 하면 할 수록 더 많은 자율성이 주어지지만, 사용법을 정의하고 이해하기 더 어려워진다는 점은 명확해 진다.

## Abstractions give freedom

위 내용을 살펴보면, 일반적으로 추상화를 도입하는 몇 가지 방법들을 확인하였다.

- 상수로 추출
- 동작을 함수로 래핑
- 함수를 클래스로 래핑
- 클래스를 인터페이스 뒤에 숨기기
- 범용 객체를 특수한 객체로 래핑

각각의 방법들이 얼마나 다른 종류의 자율성을 제공하는지 살펴봤다.  
이와 같은 방법 외에도 더 많은 방법들이 존재하고, 몇 가지 예시를 보면 다음과 같다.

- 제네릭 타입 파라미터 사용
- 'inner' 클래스로 추출
- '팩토리 메서드'를 통해서만 객체를 생성하도록 제한

반면에, 추상화에는 어두운 면도 있다.   
추상화는 자율성을 주고 코드 분할과 같은 이점들을 제공 하지만, 때로는 코드의 이해와 수정을 더 어렵게 만들 수 있다.

## Problems with abstraction

추상화는 코드를 구조화하고 재사용성을 높이는데 도움이 됨과 동시에, 코드를 읽는 사람에게 추가적인 학습 부담을 주며, 프로젝트 복잡성을 증가 시킬 수 있다. 
특히, 새로운 추상화 개념을 도입할 때는 추상화를 하려는 개념을 이미 알고 있거나 배워야 하는 요구가 생기며, 추가적으로 프로젝트 내에서 이해해야 할 요소가 하나 더 늘어나게 되는 것이다.

물론, 추상화의 'visibility'를 제한하여 필요한 개발자만 사용하거나, 
구체적인 작업에 초점을 맞춘 추상화는 그 범위와 프로젝트의 영향이 제한적이기에 위와 같은 문제가 덜 해지긴 하다.

이처럼, 전체 프로젝트의 모든 세부 사항을 파악하는것 보다, 자신이 작업하는 특정 기능이나 서비스에 초점을 맞추게되면 위와 같은 문제들이 덜 발생하게 된다.
때문에, 대규모 프로젝트에서 모듈화가 중요한 이유이다.  
결과적으로, 추상화를 정의하는데는 모두 비용이 발생하며, 모든 것을 기본적으로 추상화해서는 안된다는 점을 이해해야 한다.

한편으론, 추상화는 개발자가 고려해야 할 사항들을 줄여주어 개발 과정을 단순화시키는 이점을 제공한다.  
그러나 반대로, 너무 많은 추상화를 사용하는 경우, 코드가 실제로 어떻게 동작하는지 이해하기 어려워 질 수 있다.  

예를 들어, 'showMessage' 함수가 여전히 토스트 메시지를 표시할 것이라고 생각하고 사용했지만, 실제로는 스낵바가 표시되어 놀랄 수 있다.
이처럼, 의도치 않은 토스트 메시지가 표시되는 것을 본 사람은 'Toast.makeText'를 통해 찾으려 했지만, 실제로는 'showMessage'를 통해 표시되었기에 이를 찾는 데 어려움을 겪을 수 있다.

위 예제와 같이 추상화가 많을 수록 코드를 이해하기 어렵게 만들 뿐만 아니라, 개발자가 실행한 행동이 어떤 결과를 가져올지 확신할 수 없게 만들어 불안감을 조성할 수 있다.

## Where is the balance?

기본적인 원칙은, 프로젝트의 복잡성이 증가할수록 개발자에게 더 많은 자율성을 제공하고 코드를 더 잘 체계적으로 관리할 수 있게 해준다.  
그러나, 동시에 복잡성이 증가하면 프로젝트에서 실제로 어떤 일이 일어나고 있는지 이해하기 더 어려워진다.  
또한, 너무 단순하거나 너무 복잡한 것도 바람직하지 않다. 최선의 방법은 중간 어딘가에 있으며, 정확한 위치는 다음과 같은 요인들에 따라 유동적이다.

- 팀 규모
- 팀 경험 수준
- 프로젝트 규모
- 제공하는 기능들
- 도메인에 대한 지식

모든 프로젝트에서는 끊임없이 이 균형을 찾고 있지만, 쉽지 않은 작업이다.  
이러한 균형을 찾기 위해서는 지속적인 학습과 경험이 축적되어야 하며, 아래는 균형있는 추상화 수준을 갖도록 하는 몇 가지 제안사항들 이다.

- 개발자가 많은 대규모 프로젝트에서는 객체 생성과 사용 방법을 나중에 변경하기 어렵기 때문에, 더 추상적인 솔루션을 선호한다.  
  또한, 모듈이나 파트 별로 코드를 독립적인 단위로 나누는 것이 특히 유용할 수 있다.
- 의존성 주입 프레임워크를 사용하면 대부분의 경우 객체 생성과 관련된 설정을 한 번만 정의하면 되기 때문에, 객체 생성의 복잡성에 대해서 크게 걱정하지 않아도 괜찮다.
- 다양한 애플리케이션 버전을 만들거나 테스트를 수행할 때 추상화를 사용할 수 있다.
- 프로젝트가 작고 실험적인 단계에 있을 때는 추상화를 다룰 필요 없이 직접 변경을 적용하는 것이 개발 초기의 아이디어를 신속하게 구현하는데 좋다.
  그러나 프로젝트가 규모가 커지고 본격적으로 진행될 때는 가능한 빨리 추상화 작업을 수행하는 것이 좋다.

개발자들은 프로젝트를 설계하고 구현할 때, 시스템의 어떤 부분이 변경될 가능성이 있는지, 그리고 각 변경사항이 발생할 확률은 얼마나 되는지를 지속적으로 고려해야 한다.

예를 들어, 토스트 메시지를 표시하는 API가 변경될 가능성은 매우 낮지만, 메시지를 표시하는 방법 자체를 변경하는 확률은 상대적으로 높다.

이는 개발자가 시스템의 어떤 부분을 더 일반적으로, 혹은 플랫폼에 독립적인 방식으로 설계해야 할지, 
혹은 특정 메커니즘을 'mock'해야 할 필요성이 있는지 등을 미리 고려 해야함을 말한다.
이러한 변경 확률은 0%가 아니므로, 개발자가 시간이 지남에 따라 변화하는 패턴을 관찰하고 이해함으로써, 이런 변경들을 더 효과적으로 대응할 수 있게 해준다.

