추상화는 프로그래밍 세계에서 매우 중요한 개념이며, OOP에서 추상화가 캡슐화와 상속과 함께 3대 핵심 개념 중 하나로 여겨진다.
함수형 프로그래밍에서는 프로그래밍 작업 전체를 추상화와 구성으로 보는 관점이 일반적이다.

추상화는 일반화 과정이나 결과로서, 특성을 제거하거나 아이디어를 객체로부터 멀어지게 하는 것이다.

즉, 추상화는 복잡성을 숨기는 단순화의 한 형태로, 프로그래밍에서 기본적인 예로 인터페이스를 들 수 있다.  
인터페이스는 클래스의 일부 특성만을 나타내기에 클래스의 추상화로 볼 수 있다. 구체적으로는 메서드와 프로퍼티의 집합을 의미한다.

---

# Item 26 : Each function should be written in terms of a single level of abstraction

잘 분리된 계층 구조는 특정 계층에서 작업을 할 때, 하위 계층이 예상한 대로 동작할 것이라는 믿음을 바탕으로 모든 세부 사항을 깊게 이해하지 않아도 된다.
이러한 장점은 어셈블리 언어나 JVM 바이트코드에 대한 지식을 갖지 않아도 프로그래밍을 할 수 있다는 것을 의미한다.

이로 인해, 컴퓨터 과학에서는 계층 위에 계층을 쌓아 올리면서, 어떤 기술이나 언어가 얼마나 '고수준(high-level)'인지를 구분하기 시작했다. 
더 높은 수준일수록 물리적인 부분으로부터 멀어지며, 프로그래밍에서는 프로세서와 멀어지는 것을 의미한다.

```mermaid
graph BT
    Physics --- Hardware
    Hardware --- Assembler
    Assembler --- ProgrammingLanguage
    ProgrammingLanguage --- Application
```

고수준일수록 세부적인 부분에 대해 걱정을 하지 않아도 된다는 장점이 있지만, 이는 동시에 제어력의 손실과 교환하는 것을 의미한다. 
예를 들어, Java에서는 메모리 관리를 가비지 컬렉터가 자동으로 해주지만, 메모리 최적화를 하는 것이 더 어렵다.

## Single Level of Abstraction Principle

복잡한 문제를 해결하기 위해서 코드 작성 시에도 추상화를 적용할 수 있으며, 이를 위한 가장 기본적인 방법은 '함수'를 사용하는 것이다. 
이때, 'SLAP(함수를 한 가지 추상화 수준에서 구현)'를 도입하면 프로그램의 각 로직들이 어떻게 상호작용 하는지 명확하게 이해할 수 있다.  

예를 들어, 커피 머신 클래스가 있다고 가정해 보자.  
커피를 만드는 과정은 여러 단계를 거치며, 이를 단일 함수 'makeCoffee'로 전체 과정을 표현할 수 있다.

```kotlin
class CoffeeMachine {
    
    fun makeCoffee() {
        // ...
    }
}
```

그러나, 위와 같은 함수는 기능이 추가되고 수정될 수록 코드가 길어지며, 극단적으로는 수백 줄에 달하는 코드로 구현될 수 있다.
이렇게 긴 함수는 읽을 수 없을 정도로 복잡하고, 어떤 동작을 하는지 파악하기 어려워진다.
또한, 전체적인 맥락을 이해하기 어려워지고, 특정 부분을 찾는 것도 쉽지 않아진다.

이러한 단점으로 인해, 고수준의 함수는 'high-level step' 별로 분리하여 함수로 작성하는 것이 좋다.

```kotlin
class CoffeeMachine {
    
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }
    
    private fun boilWater() { /* ... */ }
    private fun brewCoffee() { /* ... */ }
    private fun pourCoffee() { /* ... */ }
    private fun pourMilk() { /* ... */ }
}
```

이렇게 함으로써, 처음 시작 할 작업과 각 단계의 절차들을 쉽게 이해할 수 있도록 단순화할 수 있다.  
또한, 각각의 'private' 함수들은 책의 파트처럼, 전체적인 구조에서 특정 부분을 담당하는 것처럼 보이게 할 수 있다.
이는 코드를 더 읽기 쉽게하고, 누군가 세부적인 구현을 이해하고자 할 때, 간편하게 이동하여 확인하거나 수정할 수 있게 한다.  
이처럼 간단한 추상화를 통해 'high-level step'을 분리함으로써 전체적인 가독성과 유지보수성을 높일 수 있다.

'SLAP' 원칙에 따르면 새롭게 추가되는 함수들도 간단하게 유지되어야 한다.  
만약, 프로그램 내 추상화 된 함수 보다 더 복잡한 함수가 존재하면, 'intermediary abstraction'로 추출해야 한다. 
이를 통해, 읽기 쉬운 작은 단위의 함수들을 여럿으로 만들고, 이들 모두 동일한 'single level abstraction'으로 맞춰야 한다.
'every level abstraction'에서는 '추상적인 용어(메서드나 클래스)'로 작업하며, 해당 기능이나 데이터가 어떻게 구현되는지 이해하려면 해당 정의로 직접 이동하여 확인할 수 있다.

위와 같은 방식으로 함수를 분리함으로써 프로그램의 기능이나 동작에 영향을 주지 않으면서, 가독성을 크게 향상할 수 있다.

추가적으로, 함수 분리 시, 각 함수들을 재사용하거나 단위 테스트하기 용이하다는 장점도 얻을 수 있다.  
예를 들어, 다른 에스프레소 커피를 만들기 위해 별도의 함수를 설정해야 한다면, 추출된 함수를 재사용하여 쉽게 구현할 수 있다.

```kotlin
fun makeEspressoCoffee() {
    boilWater()
    brewCoffee()
    pourCoffee()
}
```

## Abstraction levels in program architecture

추상화 계층의 개념은 함수보다 더 높은 수준에도 적용이 가능하다.  

프로그램 구조를 추상화하여 분리하면 다음과 같은 이점을 얻을 수 있다.

- 하위 시스템의 세부 구현을 숨겨, 시스템의 다른 부분에 영향을 주지 않고 내부 구현을 변경할 수 있다.
- 프로그램 내 서로 다른 관심사를 분리하며, 특정 로직에 대한 변경이 전체 시스템에 미치는 영향을 최소화한다.
- 시스템 구성 요소 간 상호작용을 원활하게 하고, 다양한 플랫폼에서도 동작하도록 한다. 
- 비지니스 로직을 'problem-domain terms'로 표현하게 하여 기술적인 세부 사항보다는 실제 문제를 해결하는데 집중할 수 있다.

<img src="program_abstract.png" width="350">

이러한 개념은 모듈형 시스템을 설계할 때도 중요하다.
독립적으로 분리된 모듈은 특정 계층의 요소를 숨기는데 효과적인 방법을 제공한다.

예를 들어, 애플리케이션 개발 시 일반적으로 화면을 출력하거나 백엔드의 HTTP 처리 등을 담당하는 모듈은 하위 계층 모듈로 간주되고, 
'Usecase', '비지니스 로직'을 다루는 모듈은 보다 상위 계층 모듈로 간주된다.

<img src="module_abstract.png" width="200">

이처럼 잘 분리된 계층 구조를 가진 프로젝트는 시스템의 어느 한 부분을 확인하더라도, 전체 구조와 해당 계층의 역할, 기능, 연결성을 쉽게 이해할 수 있다.

예를 들어, 소프트웨어 개발에서 'DB 설계', 'UI 개발', 'API 개발' 등 분리된 계층 구조를 가질 때,
'API 개발'을 살펴보면 **해당 계층이 어떻게 데이터 베이스와 연결되고, UI에 어떤 데이터를 제공하는지 쉽게 이해**할 수 있다.

이러한 장점이 있기에 프로그램 개발 시 잘 분리된 계층 구조를 가진 프로젝트를 선호한다.

---

# Item 27 : Use abstraction to project code against changes

추상화를 통해 실제 코드를 숨기는 것은 개발자를 세부 구현으로부터 보호하고, 나중에 자유롭게 코드를 변경할 수 있도록 한다.  
예를 들어, 정렬 알고리즘을 함수로 추출하고, 나중에 사용 방법을 변경하지 않고도 쉽게 성능을 최적화할 수 있다.

아래 추상화 방법들을 통해, 어떻게 변화로부터 개발자를 보호하고, 그 과정에서 자율성을 제공하는지 알아보자.

## Constant

리터럴 상수 값들은 자체적으로 설명 없이 사용되는 경우가 많으며, 이는 코드를 이해하기 어렵게 만들기에 문제가 된다.  
이런 리터럴 상수 값을 상수 프로퍼티로 옮김으로써, 값에 의미 있는 이름을 부여할 수 있고, 값을 변경 해야하는 상황이 발생했을 때 더 쉽게 관리할 수 있다.

아래 예시와 같이, 패스워드 유효성 검사에서 숫자 '7'은 문맥에 따라 이해할 수 있겠지만, 이를 프로퍼티로 추출하여 더 명확하게 표현할 수 있다.

```kotlin
// Before
fun isPasswordValid(text: String): Boolean {
    if (text.length < 7) return false
    // ...
}

// After
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
    if (text.length < MIN_PASSWORD_LENGTH) return false
}
```

## Function

안드로이드 앱 개발 중 'Toast Message' 표시를 아래와 같이 간단한 확장 함수로 추출할 수 있으며,  
이는 추후에 변경될 때에도 사용 방법을 수정할 필요 없이, 함수 내부만 수정하여 모든 곳에 적용할 수 있는 이점을 얻을 것이다.

```kotlin
// Before
Toast.makeText(this, "Hello, World!", Toast.LENGTH_SHORT).show()

// After
fun Context.toast(msg: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, msg, duration).show()
}
```

하지만, 만약 'Toast'가 아닌 'Snackbar'로 메시지 표시 방식 자체를 변경해야 한다고 가정해보자.

이런 변경사항을 미리 알고 있었으면, "메시지를 어떻게 보여주는가?" 보다는 사용자에게 "메시지를 전달한다."라는 점을 더 중요하게 생각했을 것이다. 
이처럼 더 추상적인 방법으로 메시지를 표시하면 다음과 같이 'Toast', 'Snackbar' 보다 더 상위 수준의 함수로 추출할 수 있다.

```kotlin
enum class MessageLength { SHORT, LONG }

fun Context.showMessage(
    msg: String,
    length: MessageLength = MessageLength.LONG
) {
    val duration = when (length) {
        SHORT -> Length.LENGTH_SHORT
        LONG -> Length.LENGTH_LONG
    }

    Toast.makeText(this, msg, duration).show()
    // or Snackbar.make(this, msg, duration).show()
}
```

위 상황에서 가장 큰 변화는 함수의 이름인데, 일부 개발자들은 함수 이름을 단지 'label' 정도로 생각한다.  
하지만, 함수 시그니처는 자신이 어떤 추상화인지 알려주기에, 의미 있는 이름은 매우 중요하기에 이런 변화를 간과해서는 안된다.  
또한, 함수 이름을 변경하는 것은, 이를 사용하는 모든 곳을 수정해야 하기에 예상치 못한 오류가 발생될 수 있어 주의해야 한다.

이처럼, 함수는 매우 간단한 추상화 방법이지만, 상태를 보유하지 않기에 제한적이다.  
또한, 위 예시와 같이 함수 시그니처가 변경되면 함수 사용법에 영향을 주므로, 더 강력하게 구현을 추상화하는 클래스를 사용하는 것이 좋다.

## Class

클래스가 함수보다 더 강력하게 구현을 추상화할 수 있는 이유는 상태를 유지할 수 있고, 여러 함수를 노출할 수 있기 때문이다.  
위 'showMessage'를 클래스로 추출하고, 추가적으로 상태를 통해 메시지 표시를 구분해 보면 다음과 같을 수 있다.

```kotlin
enum class MessageLength { SHORT, LONG }

class MessageDisplay(val context: Context) {

    var isToastMessageType = false 

    fun show(
        msg: String, 
        length: MessageLength = MessageLength.SHORT
    ) {
        val duration = when (length) {
            SHORT -> Length.LENGTH_SHORT
            LONG -> Length.LENGTH_LONG
        }

        if (isToastMessageType) Toast.makeText(context, msg, duration).show()
        else Snackbar.make(context, msg, duration).show()
    }
}

// usage
val messageDisplay = MessageDisplay(context)
messageDisplay.show("Hello, World!")        // Snackbar

messageDisplay.isToastMessageType = true
messageDisplay.show("Hello, World!")        // Toast
```

클래스는 함수 보다 더 많은 자율성을 제공하지만, 여전히 한계점이 존재한다.

예를 들어, 'final class'는 상속을 허용하지 않아, 기능을 확장하거나 변경할 수 없어 제한적이고,  
'open class'는 서브 클래스를 제공하여 상속을 허용하고 확장할 수 있지만,  
결국 기존 클래스와 강하게 연결되어 있어서 상위 클래스에 변경사항이 생기면 서브 클래스에도 영향을 준다.

이런 한계점을 극복하고, 클래스 보다 더 높은 수준의 자율성을 추구하려면, 클래스를 인터페이스 뒤에 숨겨 추상화를 더 강화할 수 있다.

## Interface

Kotlin 표준 라이브러리를 보면, 대부분 인터페이스로 추상화되어 있음을 알 수 있다.

-   'listOf()'는 'List' 인터페이스를 반환하며, 다른 '팩토리 메서드'들도 비슷하다.
-   컬렉션을 처리하는 함수들은 'Iterable', 'Collection'에 대한 확장 함수로, 'List', 'Map' 등의 인터페이스를 반환한다.
-   'property delegation'은 'ReadOnlyProperty' 또는 'ReadWriteProperty' 인터페이스 뒤에 숨겨져 있다.
-   'lazy { ... }' 또한 'Lazy' 인터페이스를 반환한다.

이처럼 인터페이스 뒤에 객체를 숨김으로써, 실제 구현을 추상화하고 사용자가 해당 추상화에만 의존하도록 강제함으로써, 결합도를 낮출 수 있다.

이를 토대로 'MessageDisplay'를 인터페이스로 추출하면 다음과 같을 수 있다.

```kotlin
enum class MessageLength { SHORT, LONG }

interface MessageDisplay {
    fun show(msg: String, length: MessageLength = MessageLength.SHORT)
}

class ToastDisplay(val context: Context): MessageDisplay {

    override fun show(msg: String, length: MessageLength) {

        val duration = when (length) {
            SHORT -> Length.LENGTH_SHORT
            LONG -> Length.LENGTH_LONG
        }

        Toast.makeText(context, msg, duration).show()
    }
}

class SnackbarDisplay(val context: Context): MessageDisplay {

    override fun show(msg: String, length: MessageLength) {

        val duration = when (length) {
            SHORT -> Length.LENGTH_SHORT
            LONG -> Length.LENGTH_LONG
        }

        Snackbar.make(context, msg, duration).show()
    }
}
```

이처럼, 인터페이스로 추상화를 하면 더 많은 자율성을 얻을 수 있다.

예를 들어, 태블릿에서는 'ToastDisplay', 모바일에서는 'SnackbarDisplay'를 각각 사용할 수 있다.  
더 나아가, 플랫폼 공통 모듈에서 'MessageDisplay'를 사용하여, 각 플랫폼에 맞게 다양한 구현을 적용할 수 있도록 할 수 있다.

또한, 'Mock 클래스' 대신, 'Fake 인터페이스'를 통해 간편하게 테스트할 수 있다.

```kotlin
val msgDisplay: MessageDisplay = FakeMessageDisplay()
```

## Next ID

간단한 방법으로 프로젝트에 '유니크 ID'가 필요하다고 가정해 보면,  
'Top-level 프로퍼티'를 통해 ID를 저장하고, 새로운 ID가 필요할 때마다 값을 증가시켜 구현할 것이다.

```kotlin
var nextId: Int = 0
fun getNextId(): Int = nextId++

// usage
val newId = getNextId()
```

하지만, 이런 방법은 많은 변경 사항이 발생할 수 있다.

예를 들어, 현재 ID를 'Int'로 표현하고 있기에, 타입에 종속된 연산(e.g : 숫자를 비교하여 어떤 ID가 더 오래되었는지 확인하는 등)을 수행할 수 있을 것이다.  
그러나 시간이 지나, ID를 'String'으로 변경해야 하는 상황이 생긴다면, 타입에 종속된 연산들을 모두 수정해야 할 것이다.

이를 방지하고, 향후 ID 타입을 쉽게 변경할 수 있도록 ID를 별도의 클래스로 추출하는 것이 좋다.

```kotlin
data class Id(private val id: Int)

private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```

## Problems with abstraction

추상화는 코드를 구조화하고 재사용성을 높이는데 도움이 되지만, 이와 동시에 코드를 읽는 사람에게 추가적인 학습 부담을 주며, 프로젝트 복잡성을 증가시킨다.  
특히, 새로운 추상화 개념을 도입할 때, 도입하려는 추상화 개념을 이미 알고 있어야 하거나 배워야 하는 요구가 있으며, 추가적으로 프로젝트 내에서 이해해야 할 요소가 하나 더 늘어나게 된다.

물론, 위와 같은 문제는 'visibility'를 제한하여 필요한 개발자만 해당 추상화를 사용하거나, 구체적인 작업에 초점을 두어서 범위를 제한하는 방식으로 문제점을 완화할 수 있다.

이를 통해 알 수 있는 것은, 자신이 작업하는 특정 기능이나 서비스 범위로 제한하여 추상화를 도입하면, 위와 같은 문제점을 완화할 수 있다는 것이다.  
이러한 이유로, **대규모 프로젝트에는 모듈성을 적용하는 것이 좋다.**

한편으로, 추상화는 개발자가 고려해야 할 사항들을 줄여 주기에 개발 과정을 단순화시키는 이점을 제공한다.  
그러나 반대로, 너무 많은 추상화는 코드가 실제로 어떻게 동작하는지 이해하는데 어려움을 줄 수 있다.

예를 들어, 여전히 'showMessage'가 'Toast'를 표시할 것이라 생각하여 사용하다가, 실제로는 'Snackbar'로 표시된다면 놀랄 것이다.  
이처럼, 의도치 않은 동작을 확인한 개발자는 'Toast.make'를 통해 찾으려 했지만, 실제로는 'showMessage'를 통해 표시되었기에 이를 찾는데 어려움을 겪을 것이다.

이런 예시와 같이 추상화가 많을수록 코드를 이해하기 어렵게 만들고, 개발자가 실행한 행동이 어떤 결과를 가져올지 확신할 수 없게 만들어 불안감을 가질 수 있다.

## Where is the balance?

기본적인 원칙은, 프로젝트 복잡성이 증가하면 개발자에게 더 많은 자율성을 제공하고, 더 체계적으로 코드를 관리할 수 있음을 의미한다.  
그러나, 동시에 복잡성의 증가로 인해 프로젝트에서 실제로 어떤 일이 일어나고 있는지 이해하기 어려워진다.

이는 프로젝트 복잡성이 너무 단순하거나 너무 복잡한 것도 바람직하지 않으며, 최선의 방법은 이 두 가지 사이의 밸런스를 잡는 것이다.  
추가적으로, 이 밸런스는 다음과 같은 요소들에 따라 유동적으로 변할 수 있다.

-   Team size
-   Team experience
-   Project size
-   Feature set
-   Domain knowledge

모든 프로젝트는 계속해서 밸런스를 잡아가고 있지만, 쉽지 않은 작업이다.  
이런 밸런스를 잡기 위해서는 지속적인 학습과 경험이 필요하며, 아래는 프로젝트 복잡성의 밸런스를 잡기 위한 몇 가지 제안사항들이다.

-   개발자가 많은 대규모 프로젝트에서는 객체 생성과 사용 방법을 나중에 변경하기 어렵기에, 복잡성이 증가하더라도 더 추상적인 솔루션을 사용하는 것이 좋다.  
    추가적으로, 'module'이나 'feature' 별로 코드를 독립적으로 분리하여 작성하는 것도 복잡성을 낮추는데 도움이 될 수 있다.
-   대부분의 경우, 객체 생성과 관련된 설정을 'DI 프레임워크'를 통해 정의하기에, 객체 생성 복잡성에 대해서 걱정할 필요가 없다.
-   다양한 앱 버전을 만들거나(release, debug, bench-mark 등), 테스트를 수행할 때, 코드를 범용적으로 만들어 다양한 시나리오에 적용할 수 있도록 일정 수준의 추상화가 필요하다.
-   프로젝트가 작고 실험적인 단계에 있을 때는 추상화를 다루지 말고, 개발 초기의 아이디어를 신속하게 직접 구현하는 것이 좋다.  
    단, 프로젝트 규모가 커지고 릴리즈 단계로 진행될 때는 가능한 빨리 추상화를 도입하여, 코드를 더 체계적으로 관리하는 것이 좋다.

또한, 개발자들은 프로젝트 설계 및 구현 시, 특정 부분이 변경될 가능성과 해당 변경사항이 발생할 확률을 지속적으로 고려하여 추상화를 해야 한다.

-   시스템이 일반적인 메커니즘으로 전환해야 하는지?
    -   'ID/PW'만 사용하다가, 'SNS' 및 'FaceID' 등 지원해야 하는 경우
-   플랫폼에 독립적인 메커니즘이 필요한 지?
    -   'Android'에만 사용되는 'Message'를 'iOS'에서도 사용해야 하는 경우
-   특정 메커니즘을 모의(mock) 해야 하는지?
    -   결제 시스템에서 결제 처리를 위한 '모의 결제'가 필요한 경우

이런 고려사항을 통해, 개발자는 시간이 지나면서 변화하는 패턴을 관찰하고, 이를 바탕으로 변경 사항들을 대비할 수 있어야 한다.

---

## Item 28 : API 안정성 명시

개발자들이 새로운 버전의 라이브러리 사용과 이로 인한 문제가 발생하지 않도록 API 안정성을 명시하는 것이 중요합니다.

### SemVer(Semantic Versioning)

SemVer은 API의 안정성을 명시하기 위한 표준화된 버전 관리 시스템입니다.
MAJOR.MINOR.PATCH 형식으로 구성되며, 각 부분은 API의 변화에 따라 증가합니다.

|  구성   |                             설명                             |
|:-----:|:----------------------------------------------------------:|
| MAJOR | - API 변화가 호환되지 않을때 증가 <br/> - 증가 시 `MINER`와 `PATCH` 0으로 설정 |
| MINOR |    - 호환 가능한 방식으로 기능 추가 시 증가 <br/> - 증가 시 `PATCH` 0으로 설정    |
| PATCH |                  -  호환 가능한 버그 수정이 있을 때 증가                  |

### 안정적인 API에 불안정한 요소 추가 시

안정적인 API에 아직 안정적이지 않은 새로운 요소를 도입하는 경우, `@Experimental`을 사용하여 경고하거나, `@Deprecated`를 사용하여 API를 변경하려는 사람들에게 차이점을 알려줄 수
있습니다.

이를 통해 API를 사용하는 개발자들이 적절한 조치를 취할 수 있도록 하며 변경사항에 대한 명확한 정보를 제공하고 안정적인 마이그레이션을 지원합니다.

---

## Item 29 : 외부 API 사용시 래핑

프로젝트에서 불안정한 API를 많이 사용하는 것은 큰 위험을 수반합니다.
API의 변경은 해당 API를 사용하는 코드 전체의 수정을 필요로 하기 때문입니다.
따라서 가능한 API 사용을 제한하고, 로직을 분리하여 이를 관리하는 것이 바람직합니다.

### 래핑을 통한 문제점 해결

그럼에도 API 사용이 필요한 경우 래핑하는 방법으로 문제를 완화 시킬 수 있습니다.
래핑을 통해 프로젝트 내에서 API를 제한적으로 사용하고, 필요에 따라 수정하거나 변경할 수 있습니다.
또한 라이브러리에 문제가 생긴 경우, 다른 라이브러리로 대체할 수도 있습니다.

### 래핑의 단점

래핑에 필요한 추가적인 코드가 필요하고, 래핑된 API를 사용하려면 개발자들이 해당 API의 작동 방식을 이해해야 합니다.
또한 래핑된 API에 대한 레퍼런스를 직접 작성해야 할 수도 있습니다.

### API 래핑 여부 결정

라이브러리의 안정성, 버전, 사용자 수 등을 검토하여 라이브러리의 신뢰성을 판단해야 하며,
특히 사용자 수가 많을수록 해당 라이브러리가 안정적일 가능성이 높습니다.

---

## Item 30 : API 설계 시 요소 가시성 최소화

API 설계 시 요소의 가시성을 최소화 하는 중요한 이유는 아래와 같습니다.

### 학습과 유지 관리

인터페이스가 작을수록 학습하고 유지 관리하기 쉽습니다. 클래스 내 기능이 적을수록 그 클래스를 이해하고 유지 관리하는 것이 더 쉽습니다.

### API 변경 용이성

API의 변경이 필요할 때, 기존 요소를 숨기는 것보다 새로운 것을 공개하는 것이 더 간단합니다. 이미 공개된 요소는 외부에서 사용되고 있을 가능성이 높아, 이를 변경하는 것은 복잡할 수 있습니다.

### 클래스 상태 책임

클래스 상태를 나타내는 속성들이 외부에서 변경될 경우, 클래스는 자신의 상태를 제대로 책임지지 못하게 됩니다. 이를 방지하기 위해 속성에 대한 접근자의 가시성을 적절히 제한하는 것이 필요합니다.

### 추적 용이성

가시성이 제한된 클래스는 상태 변화를 추적하기 더 쉽습니다. 이는 속성 상태를 이해하는 것을 도와주며, 특히 동시성 문제를 다루는 경우에 중요합니다.

### Visiblity Modifier

| modifier    | 설명                                                    |
|-------------|-------------------------------------------------------|
| `private`   | 선언된 클래스 내에서만 볼 수 있습니다.                                |
| `protected` | 선언된 클래스와 서브 클래스 내에서만 볼 수 있습니다. (최상위 선언에는 사용할 수 없습니다.) |
| `public`    | 모든 곳에서 볼 수 있습니다. 이는 기본으로 적용되는 수정자 입니다.                |
| `internal`  | 같은 모듈 내에서 볼 수 있습니다.                                   |

---

## Item 31 : 문서를 통한 Contract 정의

문서화 및 주석은 코드 가독성과 이해도를 높이는 중요한 도구 입니다.
특히, 코드의 작동 방식, 이해하기 어려움 개념, 예상되는 동작 등을 명확히 하는데 도움을 줄 수 있습니다.

### 계약(Contract) 중요성
계약은 사용자의 기대치와 개발자의 약속을 연결하는 매개체입니다. 
잘 정의된 계약이 있다면, 개발자는 클래스가 어떻게 사용되는지 걱정하지 않아도 되고, 사용자는 내부 작동 원리에 대해 걱정할 필요가 없습니다.

### 계약 정의
이름, 주석 및 문서화, 타입 등을 사용하여 계약을 명확히 정의할 수 있습니다. 
이러한 방법들은 사용자가 객체나 메서드의 동작을 이해하는 데 도움이 됩니다.

### 주석의 필요성
주석은 코드의 목적과 동작을 더 잘 이해할 수 있게 돕는 도구입니다. 
하지만, 항상 필요한 것은 아니며, 경우에 따라 주석 없이 코드를 이해하는 것이 더 적절할 수 있습니다. 
가독성이 높고 의미가 명확한 코드의 경우, 주석이 오히려 방해가 될 수 있습니다.

### Kdoc
함수를 주석으로 문서화 시 공식적인 형식을 Kdoc이라 하며 마크다운 형식으로 작성하고 있습니다.

Kdoc의 구조는 다음과 같습니다.
 
- 문서의 첫 번째 문단은 요소의 요약 설명
- 문서의 두 번째 부분은 요소의 상세 설명
- 그 후의 각 줄은 태그로 시작하며, 태그들은 요소를 설명하기 위해 사용

### 리스코프 치환 원칙(Liskov Susbstitution Principle)

OOP에서 중요 규칙 중 하나로, 하위 클래스는 상위 클래스의 계약을 이행해야 한다는 원칙입니다.
각 클래스는 상위 클래스로 사용될 수 있으며, 상위 클래스의 역할을 충실히 수행하지 못하면 예상치 못한 문제가 발생할 수 있습니다.

---

## Item 32 : 추상화된 계약 존중

계약(Contract)과 가시성(Visibility)은 개발자 간 일종의 합의를 나타냅니다.
이런 합의를 위반하는 것은 계약의 일부가 아닌 `private` 속성과 함수가 될 수 있습니다.
이들은 언제든지 변경될 수 있으므로 예측 불가능한 문제를 초래할 수 있습니다.

### 계약은 보증과 같음

계약을 위반하여 구현 시 코드가 작동하지 않게 되면 이는 API를 사용하는 개발자의 문제 입니다.

### 계약은 상속됨

클래스를 상속하거나 다른 라이브러리에서 인터페이스를 확장할 때는 계약을 존중해야 합니다.
이를 준수하지 않으면 확장된 객체가 올바르게 작동되지 않을 수 있습니다.