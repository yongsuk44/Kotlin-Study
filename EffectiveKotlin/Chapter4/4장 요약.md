# 목차

- [Item 26 : Single Level of Abstraction Principle](#item-26--single-level-of-abstraction-principle)
- [Item 27 : 추상화를 통한 코드 보호](#item-27--추상화를-통한-코드-보호)
- [Item 28 : API 안정성 명시](#item-28--api-안정성-명시)
- [Item 29 : 외부 API 래핑](#item-29--외부-api-사용시-래핑)
- [Item 30 : API 요소 가시성 최소화](#item-30--api-설계-시-요소-가시성-최소화)
- [Item 31 : 문서를 통한 Contract 정의](#item-31--문서를-통한-contract-정의)
- [Item 32 : 추상화된 계약 존중](#item-32--추상화된-계약-존중)

---

## Item 26 : Single Level of Abstraction Principle

### 단일 추상화 수준 원칙: 각 함수는 하나의 추상화 수준에서 작성되어야 한다

각 함수는 하나의 추상화 수준에서 작성되어야 하며, 이렇게 하면 각 함수의 전반적인 흐름을 명확하게 이해할 수 있습니다.
이 원칙을 따르면 함수는 작고 책임이 최소화되며, 복잡한 함수는 중간 추상화를 추가로 추출하여 간단하게 만들 수 있습니다.

### 추상화 레벨: 복잡성을 관리하는 방법

컴퓨터 과학에서는 복잡성을 관리하기 위해 여러 계층을 통해 추상화를 실시하였습니다.
더 높은 추상화 수준은 개발자가 처리해야 할 세부 사항을 줄이지만, 그에 따라 제어력이 상실될 수 있습니다.

### 추상화 계층과 프로그램 설계: 시스템의 전체 설계에서의 추상화 계층

추상화 계층의 개념은 함수 이상의 더 높은 수준, 즉 시스템의 전체 설계에도 적용됩니다.
이 과정에서는 하위 시스템의 세부 사항을 숨기고, 이를 통해 관심사의 분리를 실현하여 상호 운용성과 플랫폼 독립성을 증진합니다.
이를 위해 개발자들은 문제 도메인에 특화된 언어를 사용하여 고수준의 설계를 정의합니다.

---

## Item 27 : 추상화를 통한 코드 보호

추상화를 통해 함수나 클래스의 구현 시 세부 사항을 보호하고 나중에 자유롭게 코드를 변환하기 위해 필요합니다.

### 상수 활용 추상화

코드의 가독성을 높이고 관리를 용이하게 만드는 방법입니다.
예를 들어, 패스워드 유효성 검사에서 '7'이라는 최소 길이를 상수로 추출하면 코드의 이해가 더 쉬워지고 변경이 필요할 때도 유용합니다.

### 함수 활용 추상화

반복적인 작업을 간결하게 만들 수 있습니다.
예를 들어, 토스트 메시지를 반복해서 사용한다면, 이를 함수로 추출해 재사용할 수 있습니다.

### 클래스 활용 추상화

클래스는 상태를 유지할 수 있고, 여러 함수를 노출할 수 있기 때문에 강력한 추상화 방법입니다.
이를 통해 DI 프레임워크를 사용한 클래스 생성 위임, 클래스 모킹 등의 유연한 동작이 가능합니다.
하지만 클래스가 `final`로 선언된 경우 확장성에 제한이 있을 수 있습니다.

### 인터페이스 활용 추상화

객체를 인터페이스 뒤에 숨김으로써 실제 구현을 추상화하고, 추상화에만 의존하도록 강제함으로써 결합도를 낮춥니다.
인터페이스는 라이브러리 개발자들이 클래스의 가시성을 제한하고 해당 구현을 자유롭게 변경할 수 있는 유연성을 제공합니다.
인터페이스의 Fake class를 통한 테스트는 모킹보다 간단하며 모킹 라이브러리를 필요로 하지 않습니다.

### 추상화의 문제점과 균형

추상화는 새로운 개념의 도입이 필요하며 프로젝트를 이해하는 데에 추가적인 학습 요소가 될 수 있습니다.
이를 극복하기 위해서는 비용과 효과를 고려하여 적절한 균형을 찾아야 합니다.
추상화의 적절한 균형은 프로젝트의 복잡성, 팀의 규모와 경험, 프로젝트의 크기, 도메인 배경 지식 등 다양한 요소를 고려해야 합니다.

---

## Item 28 : API 안정성 명시

개발자들이 새로운 버전의 라이브러리 사용과 이로 인한 문제가 발생하지 않도록 API 안정성을 명시하는 것이 중요합니다.

### SemVer(Semantic Versioning)

SemVer은 API의 안정성을 명시하기 위한 표준화된 버전 관리 시스템입니다.
MAJOR.MINOR.PATCH 형식으로 구성되며, 각 부분은 API의 변화에 따라 증가합니다.

|  구성   |                             설명                             |
|:-----:|:----------------------------------------------------------:|
| MAJOR | - API 변화가 호환되지 않을때 증가 <br/> - 증가 시 `MINER`와 `PATCH` 0으로 설정 |
| MINOR |    - 호환 가능한 방식으로 기능 추가 시 증가 <br/> - 증가 시 `PATCH` 0으로 설정    |
| PATCH |                  -  호환 가능한 버그 수정이 있을 때 증가                  |

### 안정적인 API에 불안정한 요소 추가 시

안정적인 API에 아직 안정적이지 않은 새로운 요소를 도입하는 경우, `@Experimental`을 사용하여 경고하거나, `@Deprecated`를 사용하여 API를 변경하려는 사람들에게 차이점을 알려줄 수
있습니다.

이를 통해 API를 사용하는 개발자들이 적절한 조치를 취할 수 있도록 하며 변경사항에 대한 명확한 정보를 제공하고 안정적인 마이그레이션을 지원합니다.

---

## Item 29 : 외부 API 사용시 래핑

프로젝트에서 불안정한 API를 많이 사용하는 것은 큰 위험을 수반합니다.
API의 변경은 해당 API를 사용하는 코드 전체의 수정을 필요로 하기 때문입니다.
따라서 가능한 API 사용을 제한하고, 로직을 분리하여 이를 관리하는 것이 바람직합니다.

### 래핑을 통한 문제점 해결

그럼에도 API 사용이 필요한 경우 래핑하는 방법으로 문제를 완화 시킬 수 있습니다.
래핑을 통해 프로젝트 내에서 API를 제한적으로 사용하고, 필요에 따라 수정하거나 변경할 수 있습니다.
또한 라이브러리에 문제가 생긴 경우, 다른 라이브러리로 대체할 수도 있습니다.

### 래핑의 단점

래핑에 필요한 추가적인 코드가 필요하고, 래핑된 API를 사용하려면 개발자들이 해당 API의 작동 방식을 이해해야 합니다.
또한 래핑된 API에 대한 레퍼런스를 직접 작성해야 할 수도 있습니다.

### API 래핑 여부 결정

라이브러리의 안정성, 버전, 사용자 수 등을 검토하여 라이브러리의 신뢰성을 판단해야 하며,
특히 사용자 수가 많을수록 해당 라이브러리가 안정적일 가능성이 높습니다.

---

## Item 30 : API 설계 시 요소 가시성 최소화

API 설계 시 요소의 가시성을 최소화 하는 중요한 이유는 아래와 같습니다.

### 학습과 유지 관리

인터페이스가 작을수록 학습하고 유지 관리하기 쉽습니다. 클래스 내 기능이 적을수록 그 클래스를 이해하고 유지 관리하는 것이 더 쉽습니다.

### API 변경 용이성

API의 변경이 필요할 때, 기존 요소를 숨기는 것보다 새로운 것을 공개하는 것이 더 간단합니다. 이미 공개된 요소는 외부에서 사용되고 있을 가능성이 높아, 이를 변경하는 것은 복잡할 수 있습니다.

### 클래스 상태 책임

클래스 상태를 나타내는 속성들이 외부에서 변경될 경우, 클래스는 자신의 상태를 제대로 책임지지 못하게 됩니다. 이를 방지하기 위해 속성에 대한 접근자의 가시성을 적절히 제한하는 것이 필요합니다.

### 추적 용이성

가시성이 제한된 클래스는 상태 변화를 추적하기 더 쉽습니다. 이는 속성 상태를 이해하는 것을 도와주며, 특히 동시성 문제를 다루는 경우에 중요합니다.

### Visiblity Modifier

| modifier    | 설명                                                    |
|-------------|-------------------------------------------------------|
| `private`   | 선언된 클래스 내에서만 볼 수 있습니다.                                |
| `protected` | 선언된 클래스와 서브 클래스 내에서만 볼 수 있습니다. (최상위 선언에는 사용할 수 없습니다.) |
| `public`    | 모든 곳에서 볼 수 있습니다. 이는 기본으로 적용되는 수정자 입니다.                |
| `internal`  | 같은 모듈 내에서 볼 수 있습니다.                                   |

---

## Item 31 : 문서를 통한 Contract 정의

문서화 및 주석은 코드 가독성과 이해도를 높이는 중요한 도구 입니다.
특히, 코드의 작동 방식, 이해하기 어려움 개념, 예상되는 동작 등을 명확히 하는데 도움을 줄 수 있습니다.

### 계약(Contract) 중요성
계약은 사용자의 기대치와 개발자의 약속을 연결하는 매개체입니다. 
잘 정의된 계약이 있다면, 개발자는 클래스가 어떻게 사용되는지 걱정하지 않아도 되고, 사용자는 내부 작동 원리에 대해 걱정할 필요가 없습니다.

### 계약 정의
이름, 주석 및 문서화, 타입 등을 사용하여 계약을 명확히 정의할 수 있습니다. 
이러한 방법들은 사용자가 객체나 메서드의 동작을 이해하는 데 도움이 됩니다.

### 주석의 필요성
주석은 코드의 목적과 동작을 더 잘 이해할 수 있게 돕는 도구입니다. 
하지만, 항상 필요한 것은 아니며, 경우에 따라 주석 없이 코드를 이해하는 것이 더 적절할 수 있습니다. 
가독성이 높고 의미가 명확한 코드의 경우, 주석이 오히려 방해가 될 수 있습니다.

### Kdoc
함수를 주석으로 문서화 시 공식적인 형식을 Kdoc이라 하며 마크다운 형식으로 작성하고 있습니다.

Kdoc의 구조는 다음과 같습니다.
 
- 문서의 첫 번째 문단은 요소의 요약 설명
- 문서의 두 번째 부분은 요소의 상세 설명
- 그 후의 각 줄은 태그로 시작하며, 태그들은 요소를 설명하기 위해 사용

### 리스코프 치환 원칙(Liskov Susbstitution Principle)

OOP에서 중요 규칙 중 하나로, 하위 클래스는 상위 클래스의 계약을 이행해야 한다는 원칙입니다.
각 클래스는 상위 클래스로 사용될 수 있으며, 상위 클래스의 역할을 충실히 수행하지 못하면 예상치 못한 문제가 발생할 수 있습니다.

---

## Item 32 : 추상화된 계약 존중

계약(Contract)과 가시성(Visibility)은 개발자 간 일종의 합의를 나타냅니다.
이런 합의를 위반하는 것은 계약의 일부가 아닌 `private` 속성과 함수가 될 수 있습니다.
이들은 언제든지 변경될 수 있으므로 예측 불가능한 문제를 초래할 수 있습니다.

### 계약은 보증과 같음

계약을 위반하여 구현 시 코드가 작동하지 않게 되면 이는 API를 사용하는 개발자의 문제 입니다.

### 계약은 상속됨

클래스를 상속하거나 다른 라이브러리에서 인터페이스를 확장할 때는 계약을 존중해야 합니다.
이를 준수하지 않으면 확장된 객체가 올바르게 작동되지 않을 수 있습니다.