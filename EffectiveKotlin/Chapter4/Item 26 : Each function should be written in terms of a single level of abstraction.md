컴퓨터는 매우 복잡한 장치이지만, 그 복잡함을 다양한 요소로 나누어 여러 계층으로 구분함으로써 컴퓨터를 사용하고 이해할 수 있다.

프로그래머 입장에서 컴퓨터의 가장 기본적인 추상화 계층은 하드웨어에 해당된다.  
여기서 한 단계 올라가면, 주로 프로세서를 위한 코드를 작성하기 때문에 '프로세서 제어 명령어'가 다음 계층이 된다.  
'프로세서 제어 명령어'들은 가독성을 위해 간단한 언어로 표현되며, 이 언어를 '어셈블리'라고 부른다. 

어셈블리 언어는 프로세서 제어 명령어를 좀 더 이해하기 쉬운 형태로 제공하지만, 여전히 복잡하여 현대의 응용 프로그램을 개발하기에는 적합하지 않다. 
이를 위해 엔지니어들은 하나의 언어를 다른 언어(보통 더 낮은 수준의)로 변환하는 프로그램인 컴파일러를 개발하였다.   

초기 컴파일러는 어셈블리 언어로 작성되어 텍스트로 작성된 코드를 어셈블리 명령어로 변환했다.  
이 과정을 통해 첫 고급 언어가 탄생하였고, 이 언어들은 다시 더 발전된 언어들을 위한 컴파일러를 개발하는데 사용되었다.   
이로 인해 'C', 'C++'과 같은 고급 언어들이 등장하였고, 이 언어들은 다양한 프로그램과 응용 프로그램을 개발하는데 사용되었다.  

이 후, 컴퓨터 하드웨어의 복잡한 세부 사항을 숨기고 더 높은 수준에서 프로그램을 작성할 수 있도록 하는 '추상 머신'과,
런타임 시 인터프리터를 통해 한 줄씩 실행되는 프로그래밍 언어인 '해석 언어'의 개념이 도입되는 등의 발전이 있음에도 불구하고, 추상화 계층이라는 기본 아이디어는 여전히 핵심적인 원칙으로 남아 있다.

잘 분리된 계층 구조는 특정 계층에서 작업을 할 때, 하위 계층이 예상한 대로 동작할 것이라는 믿음을 바탕으로 모든 세부 사항을 깊게 이해하지 않아도 된다는 장점을 가진다.
이러한 장점은 어셈블리나 JVM 바이트코드에 대한 지식을 갖지 않아도 프로그래밍을 할 수 있다는 것을 의미한다.

같은 맥락에서, 어셈블리나 JVM 바이트코드에 대한 변경이 필요한 경우, 한 단계 위 계층의 조정만으로도 기존 응용 프로그램이 변경될 수 있다는 걱정을 하지 않아도 된다.

## Level of abstraction

컴퓨터 과학에서는 계층 위에 계층을 쌓아 올리면서, 어떤 기술이나 언어가 얼마나 '고수준(high-level)'인지를 구분하기 시작했다.
더 높은 수준일수록 물리적인 부분으로부터 멀어지며, 프로그래밍에서 '고수준'이라 함은 프로세서와의 거리가 멀어진다는 의미이다.

수준이 높아질수록 세부적인 부분에 대한 걱정을 하지 않아도 괜찮지만, 이는 동시에 제어력의 손실과 교환하는 것을 의미한다.
예를 들어, Java에서는 메모리 관리를 가비지 컬렉터가 자동으로 해주지만, 메모리 사용을 최적화하는 것이 더 어려워진다.

## Single Level of Abstraction Principle

컴퓨터 과학에서 문제를 다양한 계층으로 나누어 처리하는 것처럼, 코드 작성 시에도 추상화를 적용할 수 있으며, 이를 위한 가장 기본적인 방법은 함수를 사용하는 것이다. 
컴퓨터 시스템에서 하나의 추상화 수준에 집중하는 것과 같이, 프로그래밍에서도 동시에 하나의 추상화 수준에만 집중하는 것이 좋다.
이러한 접근 방식을 위해 프로그래밍 커뮤니티는 'SLAP'를 도입했으며, 이 원칙은 "각 함수는 한 가지 추상화 수준에서만 구현되어야 한다."를 의미한다.

예를 들어, 커피를 한 번에 한 잔씩 만들 수 있는 커피 머신 클래스를 만든다고 가정해보자.
커피를 만드는 과정은 여러 단계를 포함하기에, 이를 'makeCoffee'라는 단일 함수로 표현하여 여러 작업을 수행하게 할 수 있다.
이렇게 하면, 커피 제조 과정의 각 단계를 명확하게 구분하면서도, 전체 과정을 간결하게 표현할 수 있다.

```kotlin
class CoffeeMachine {
    
    fun makeCoffee() {
        // ...
    }
}
```

그러나, 위와 같은 함수는 오래된 프로그램에서 수백 줄에 달하는 코드로 구현되어 있는 경우를 종종 볼 수 있다.
이렇게 긴 함수는 읽을 수 없을 정도로 복잡하며, 전반적으로 어떤 동작을 하는지 파악하기가 어렵다.
또한, 세부 사항에 계속 집중하다 보면 전체적인 맥락을 이해하기 어려워지고, 특정 부분을 찾는 것도 쉽지않다.

예를 들어, 물의 온도를 약간 조정해야 하는 간단한 작업조차도, 전체 함수를 이해해야만 가능할 정도로 어려울 수 있다.
프로그래머의 기억력은 한계가 있으며, 불필요한 세부 정보에 시간을 낭비하는 것은 바람직하지 않다.
이러한 이유로, 고수준의 함수를 분리하여 별도로 작성하는 것이 좋다.

```kotlin
class CoffeeMachine {
    
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }
    
    private fun boilWater() { /* ... */ }
    private fun brewCoffee() { /* ... */ }
    private fun pourCoffee() { /* ... */ }
    private fun pourMilk() { /* ... */ }
}
```

위와 같이 전체 작업을 기준으로 고수준의 절차들(boilWater, brewCoffee, pourCoffee, pourMilk)을 추출함으로써, 처음 해야 할 작업과 각 단계의 절차들의 이해를 단순화 하였다.
또한 각각의 'private' 함수들을 책의 각 파트처럼, 전체적인 구조 속에서 특정 부분을 담당하는 것 처럼 보이게 한다.
이는 결과적으로, 코드를 더 읽기 쉽게 만들고, 누군가 각 절차의 세부적인 구현을 이해하고자 할 때, 해당 부분으로 간편하게 넘어가 확인할 수 있게 되었다.
이처럼, 간단한 추상화를 통해 각 절차를 분리함으로써 전체적인 가독성을 높일 수 있다.

'SLAP' 원칙에 따라 모든 새로운 함수들도 간단해야 한다.   
이는 기본적인 원칙으로, 가능한 함수는 작고 단일한 책임을 가져야 한다. 만약, 복잡한 함수가 있다면 추가적인 추상화를 도입해야 한다.  
이렇게 함으로써 작고 읽기 쉬운 다수의 함수들을 '하나의 추상화 레벨'에서 관리할 수 있게 된다.

고수준 ~ 저수준까지의 모든 추상화 레벨에서는 메서드와 클래스와 같은 추상적인 개념을 사용하며, 
해당 기능이나 데이터가 어떻게 구현되어 있는지 구체적으로 이해하려면 해당 정의로 직접들어가 확인할 수 있다.
이러한 방식으로 함수를 분리함으로써 가독성을 크게 향상 시킬 수 있다.

추가적으로, 함수를 분리함으로써 각 함수들을 재사용하거나 테스트하기 용이하다는 장점을 얻을 수 있다.
예를 들어, 우유가 포함되지 않은 에스프레소 커피를 만들기 위해 별도의 함수를 설정해야 한다면, 추출된 함수들을 재사용하여 다음과 같이 쉽게 사용할 수 있다.

```kotlin
fun makeEspressoCoffee() {
    boilWater()
    brewCoffee()
    pourCoffee()
}
```

이제 'makeCoffee', makeEspressoCoffee' 같은 복잡한 함수 대신, 'boilWater', 'brewCoffee'와 같은 더 작은 함수들을 개별적으로 단위 테스트할 수 있다.

## Abstraction levels in program architecture

추상화 계층의 개념은 함수보다 더 높은 수준에도 적용된다.  
추상화를 분리하여 하위 시스템의 세부 사항을 숨기고, 각 요소를 서로 원활하게 연동하고 다양한 플랫폼에서도 동작할 수 있도록 한다.   
이는 'problem-domain terms' 즉, 실제 세계의 문제를 해결하기 위한 용어와 개념을 사용하여 더 높은 수준을 정의하는 것을 의미한다.

<img src="program_abstract.png" width="300">

이러한 개념은 모듈식 시스템 설계에도 중요하며, 독립적으로 분리된 모듈은 특정 계층의 요소를 숨기는데 효과적인 방법을 제공한다.  
애플리케이션 개발 시, 일반적으로 화면을 출력하거나 백엔드의 HTTP 요청 처리 등을 담당하는 모듈은 하위 계층 모듈로 간주되며, 
반대로 'UseCase', '비즈니스 로직'을 다루는 모듈은 보다 상위 계층 모듈로 간주된다. 

이처럼, 잘 분리된 계층 구조를 가진 프로젝트를 'well-stratified project'라고 부른다.  
이런 프로젝트에서는 시스템의 어느 한 부분을 살펴보더라도 전체 구조와 그 부분의 역할, 기능, 연결성을 쉽게 이해할 수 있다.  

예를 들어, 소프트웨어 개발에서 'DB 설계', 'UI 개발', 'API 개발' 등 잘 분리된 계층 구조를 가질 때, 
'API 개발'을 살펴 보면 그것이 **어떻게 데이터 베이스와 연결되고, UI에 어떤 데이터를 제공하는지 쉽게 이해**할 수 있다.

이러한 이점으로 인해 프로그램 개발 시, 'well-stratified project'를 선호한다. 