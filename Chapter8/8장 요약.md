# 목차

- [Item 49 : Iterable 대비 Sequence 장점](#item-49--iterable-대비-sequence-장점)
- [Item 50 : 연산의 수를 제한](#item-50--연산의-수를-제한)
- [Item 51 : 성능 중심 최적화 시 원시 타입 고려](#item-51--성능-중심-최적화-시-원시-타입-고려)
- [Item 52 : 가변 컬렉션 사용 시기](#item-52--가변-컬렉션-사용-시기)


## Item 49 : Iterable 대비 Sequence 장점

Kotlin에서는 큰 데이터 컬렉션을 효과적으로 처리하기 위해 `Sequnece`를 제공합니다. 
`Sequnece`는 표준 컬렉션 처리와는 달리 모든 처리 단계에서 새로운 컬렉션을 생성하지 않으므로, 이를 통해 메모리 효율성을 크게 향상시킬 수 있습니다.

## Sequence 이해

`Sequnece`와 `Iterable`의 차이로 둘 모두 데이터 컬렉션을 처리하지만, `Sequnece`는 'lazy' 반복자로, 연산이 즉시 실행되지 않고 필요할 때까지 지연됩니다.
이를 통해 최소한의 연산만 수행하여 결과를 생성할 수 있습니다. 

또한, 중간 연산 시 `Sequnece`는 새로운 `Sequnece`를 반환하며, `Iterable`은 컬렉션을 반환합니다. 
이러한 특성 덕분에 `Sequnece`는 메모리 효율성이 높아집니다.

그리고 `Sequnece`는 무한한 크기의 데이터 처리도 가능합니다. 
이를 활용하면 무한한 크기의 `Sequnece`를 생성한 뒤, 요소의 수를 제한하거나, 모든 요소를 필요로 하지 않는 터미널 연산을 사용해 처리할 수 있습니다. 
다만, 이때 무한 루프에 빠지지 않도록 주의가 필요합니다.

## 메모리 효율성 향상

`Sequnece`의 가장 큰 장점은 모든 처리 단계에서 새로운 컬렉션을 생성하지 않는다는 점입니다. 
이로 인해 표준 컬렉션 처리와는 달리, `Sequnece`는 각 처리 단계에서 발생하는 비용을 크게 줄일 수 있습니다. 
이 장점은 특히 큰 크기의 데이터 파일을 처리할 때 두드러집니다.

## Sequence 처리가 더 느린 경우 

`Sequnece`가 항상 빠르다고는 할 수 없습니다. 
몇몇 연산들은 전체 컬렉션에 대한 작업을 수행해야 하므로, `Sequnece`를 사용하더라도 이익을 볼 수 없는 경우가 있습니다. 

대표적인 예로 `sorted` 연산이 있습니다. 이 연산은 `Sequnece`를 리스트로 누적 한 다음 Java 표준 라이브러리인 `sort`를 사용하여 구현합니다. 
이 과정에서 추가적인 시간이 소요되지만, 이러한 상황을 고려하여 적절히 `Sequnece`와 `Iterable`을 선택하여 사용하면 좋습니다.

## Sequence vs Java Stream

Java 8에서도 컬렉션 처리를 위해 `Stream`이라는 개념이 도입되었습니다. 이는 Kotlin의 `Sequnece`와 유사하게 동작합니다.   
하지만, `Sequnece`와 `Stream` 사이에는 몇 가지 차이점이 있습니다.

- `Sequnece`는 더 많은 연산을 가지고 있어 사용하기 쉽습니다. 
- `Stream`은 병렬 함수를 사용하여 병렬 모드에서 시작할 수 있습니다. 이는 여러 CPU 코어를 가진 기계에서 사용하면 엄청난 성능 향상을 끌어낼 수 있습니다. 
- `Sequnece`는 Kotlin의 다양한 모듈에서 사용할 수 있습니다. 반면에 `Stream`은 Kotlin/JVM 버전 8 이상에서만 사용할 수 있습니다.

따라서 병렬 처리가 필요한 경우에만 `Stream`을 사용하고, 일반적으로는 다양한 플랫폼에서 호환성을 가진 `Sequnece`를 사용하는 것이 좋습니다.

---

## Item 50 : 연산의 수를 제한

컬렉션 연산 시 비용이 발생하게 되며 이는 `Sequence`도 동일하게 비용이 발생됩니다.
따라서 연산의 수를 줄여 성능을 향상시킬 수 있습니다.

컬렉션에 대한 연산의 수를 줄이는 방법으로는 복합 연산을 사용하여 줄일 수 있습니다. 

---

## Item 51 : 성능 중심 최적화 시 원시 타입 고려

코드 성능 중심 최적화에서 원시 타입과 원시 타입 배열을 사용 시 
원시 타입은 객체에 비해 가볍고 빠르기 때문에, 많은 양의 데이터 처리 시 사용하면 메모리 효율과 성능을 향상시킬 수 있습니다.   
하지만 대부분의 경우에는 리스트가 더 직관적이고 자주 사용되기에 리스트를 사용합니다.

성능 중심 부분을 최적화해야 하는 경우에만 이러한 방법을 사용하여 최적화 할 수 있음을 기억해야 합니다.

---

## Item 52 : 가변 컬렉션 사용 시기

불변 컬렉션에 요소를 추가 시 새로운 컬렉션을 생성하여 이전 요소들을 모두 옮기는 과정에서 비용이 발생하게 됩니다.
이러한 상황에서는 가변 컬렉션을 사용하는 것이 성능적으로 유리합니다.

불변 컬렉션을 사용하는 것이 동기화, 캡슐화 등의 안전성 측면에서 유리하지만, 로컬 변수 등과 같이 사용될 때에는 위 상황에 해당되지 않기에 가변 컬렉션을 사용하는 것이 좋습니다.