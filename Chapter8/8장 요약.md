# 목차

- [Item 49 : Iterable 대비 Sequence 장점](#item-49--iterable-대비-sequence-장점)


## Item 49 : Iterable 대비 Sequence 장점

Kotlin에서는 큰 데이터 컬렉션을 효과적으로 처리하기 위해 `Sequnece`를 제공합니다. 
`Sequnece`는 표준 컬렉션 처리와는 달리 모든 처리 단계에서 새로운 컬렉션을 생성하지 않으므로, 이를 통해 메모리 효율성을 크게 향상시킬 수 있습니다.

## Sequence 이해

`Sequnece`와 `Iterable`의 차이로 둘 모두 데이터 컬렉션을 처리하지만, `Sequnece`는 'lazy' 반복자로, 연산이 즉시 실행되지 않고 필요할 때까지 지연됩니다.
이를 통해 최소한의 연산만 수행하여 결과를 생성할 수 있습니다. 

또한, 중간 연산 시 `Sequnece`는 새로운 `Sequnece`를 반환하며, `Iterable`은 컬렉션을 반환합니다. 
이러한 특성 덕분에 `Sequnece`는 메모리 효율성이 높아집니다.

그리고 `Sequnece`는 무한한 크기의 데이터 처리도 가능합니다. 
이를 활용하면 무한한 크기의 `Sequnece`를 생성한 뒤, 요소의 수를 제한하거나, 모든 요소를 필요로 하지 않는 터미널 연산을 사용해 처리할 수 있습니다. 
다만, 이때 무한 루프에 빠지지 않도록 주의가 필요합니다.

## 메모리 효율성 향상

`Sequnece`의 가장 큰 장점은 모든 처리 단계에서 새로운 컬렉션을 생성하지 않는다는 점입니다. 
이로 인해 표준 컬렉션 처리와는 달리, `Sequnece`는 각 처리 단계에서 발생하는 비용을 크게 줄일 수 있습니다. 
이 장점은 특히 큰 크기의 데이터 파일을 처리할 때 두드러집니다.

## Sequence 처리가 더 느린 경우 

`Sequnece`가 항상 빠르다고는 할 수 없습니다. 
몇몇 연산들은 전체 컬렉션에 대한 작업을 수행해야 하므로, `Sequnece`를 사용하더라도 이익을 볼 수 없는 경우가 있습니다. 

대표적인 예로 `sorted` 연산이 있습니다. 이 연산은 `Sequnece`를 리스트로 누적 한 다음 Java 표준 라이브러리인 `sort`를 사용하여 구현합니다. 
이 과정에서 추가적인 시간이 소요되지만, 이러한 상황을 고려하여 적절히 `Sequnece`와 `Iterable`을 선택하여 사용하면 좋습니다.

## Sequence vs Java Stream

Java 8에서도 컬렉션 처리를 위해 `Stream`이라는 개념이 도입되었습니다. 이는 Kotlin의 `Sequnece`와 유사하게 동작합니다.   
하지만, `Sequnece`와 `Stream` 사이에는 몇 가지 차이점이 있습니다.

- `Sequnece`는 더 많은 연산을 가지고 있어 사용하기 쉽습니다. 
- `Stream`은 병렬 함수를 사용하여 병렬 모드에서 시작할 수 있습니다. 이는 여러 CPU 코어를 가진 기계에서 사용하면 엄청난 성능 향상을 끌어낼 수 있습니다. 
- `Sequnece`는 Kotlin의 다양한 모듈에서 사용할 수 있습니다. 반면에 `Stream`은 Kotlin/JVM 버전 8 이상에서만 사용할 수 있습니다.

따라서 병렬 처리가 필요한 경우에만 `Stream`을 사용하고, 일반적으로는 다양한 플랫폼에서 호환성을 가진 `Sequnece`를 사용하는 것이 좋습니다.
