이펙트 핸들러를 다루기 전에, 사이드 이펙트(side effect)가 무엇인지 다시 한 번 살펴보는 것이 좋습니다.  
사이드 이펙트를 이해하면, 왜 컴포저블 트리에서 사이드 이펙트를 제어하는 것이 중요한지에 대한 맥락을 이해할 수 있습니다.

## Introducing side effects

사이드 이펙트는 Chapter 1에서 컴포저블의 속성을 배울 때 다루었습니다.  
사이드 이펙트는 함수의 비결정성(non-deterministic)을 초래하여, 개발자 코드를 이해하고 추론하기 어렵게 만드는 것을 배웠습니다.

본질적으로 사이드 이펙트는 함수의 제어 및 스코프를 벗어나는 모든 것을 의미합니다.  
두 숫자를 더하는 함수를 예로 들어보겠습니다:

```kotlin
// Add.kt
fun add(a: Int, b: Int): Int = a + b
```

위 함수는 입력값만을 사용해 결과를 계산하기에 "순수" 함수라고도 불립니다.  
이 함수는 입력값이 동일하면 항상 같은 결과를 반환하므로, 결정론적(determinisitic)이라고 할 수 있으며, 쉽게 이해할 수 있습니다.

이제, 여기에 부수적인 동작을 추가해 보겠습니다:

```kotlin
// AddWithSideEffect.kt
fun addWithSideEffect(a: Int, b: Int): Int =
    calculateionsCache.get(a, b)
        ?: (a + b).also { calculationsCache.store(a, b, it) }
```

위 코드를 보면, '계산 캐시'를 추가하여 이미 계산된 결과가 있을 경우 계산 시간을 절약합니다.  
그러나, 이 캐시는 함수의 제어를 벗어나므로, 마지막 실행 이후 값이 변경되지 않았을 거라는 보장이 없습니다.

만약, 다른 스레드에서 캐시가 동시에 업데이트 된다면, 동일한 입력 값으로 `get(a, b)`를 두 번 연속 호출했을 때, 서로 다른 결과가 반횐될 수 있습니다:

```kotlin
// AddWithSideEffect2.kt
fun main() {
    add(1, 2) // 3
    // Another thread calls: cache.store(1, 2, res = 4)
    add(1, 2) // 4
}
```

`add` 함수가 동일한 입력값에 대해 서로 다른 값을 반환하기에, 더 이상 결정론적이지 않습니다.  
이와 마찬가지로, 캐시가 메모리가 아닌 데이터베이스에 의존한다고 가정해보겠습니다.  
데이터베이스 연결이 끊겼다면, `get` 및 `store` 호출에서 예외가 발생할 수 있으며, 이런 예상치 못한 시나리오는 `add` 호출도 실패할 수 있습니다.

요약하자면 사이드 이펙트는 함수 호출자가 기대하는 것과 다른 예상치 못한 동작을 의미하며, 이로 인해 함수의 동작이 변경될 수 있습니다.  
사이드 이펙트는 개발자가 코드를 추론하기 어렵게 만들며, 테스트 가능성을 제거하여 불안정성을 초래할 수 있습니다.

사이드 이펙트는 다음과 같은 다양한 예시들이 있습니다.

- 전역 변수를 읽고 쓰는 것
- 메모리 캐시에 접근하는 것
- 데이터베이스를 사용하는 것
- 네트워크 요청을 보내는 것
- 화면에 무언가를 출력하는 것
- 파일에서 데이터를 읽는 것

## Side effects in Compose

컴포저블 내에서 사이드 이펙트가 실행되면, 동일한 문제가 발생할 수 있다는 점을 배웠습니다.  
이렇게 되면, 사이드 이펙트가 컴포저블의 라이프사이클에서 벗어나게 되어, 제어와 제약을 잃게 됩니다.

또한, 모든 컴포저블이 여러 번 리컴포지션될 수 있다는 점도 배웠습니다. 그렇기에, 컴포저블 내에서 직접적으로 사이드 이펙트를 실행하는 것은 권장되지 않습니다.
이 내용은 Chapter 1에서 컴포저블은 재시작 가능(restartable)하다고 언급했습니다.

컴포저블 내부에서 사이드 이펙트를 실행하는 것은 코드의 무결성과 애플리케이션 상태를 손상시킬 수 있기에 위험합니다.  
Chapter 1에서 언급한, 네트워크에서 상태를 로드하는 컴포저블 예시를 다시 살펴보겠습니다:

```kotlin
@Composable
fun EventsFeed(
    networkService: EventsNetworkService
) {
    val events = networkService.loadAllEvents() // Side effect
    
    LazyColumn {
        items(events) { event ->
            Text(text = event.name)
        }
    }
}
```

이 예시에서 매번 리컴포지션될 때마다 사이드 이펙트가 실행되며, 이는 의도한 동작과는 다를 가능성이 높습니다.  
런타임은 짧은 시간 안에 이 컴포저블을 여러 번 리컴포지션 할 수 있는데, 그 결과로 많은 사이드 이펙트가 동시다발적으로 실행되면서, 서로 조율되지 않는 문제가 발생할 수 있습니다.
의도한 동작은 첫 번째 컴포지션에서만 사이드 이펙트를 실행하고, 이후 컴포저블 라이프사이클 동안 상태를 유지하는 것이었을 것입니다.

사용 사례를 Android UI라고 가정하면, `compose-ui`를 사용하여 컴포저블 트리를 빌드하며, 모든 Android 애플리케이션에는 사이드 이펙트가 존재합니다.  
외부 상태를 업데이트하는 사이드 이펙트의 예시를 살펴보겠습니다.

```kotlin
@Composable
fun MyScreen(
    drawerTouchHandler: TouchHandler
) {
    val drawerState = rememberDrawerState(DrawerValue.Closed)
    drawerTouchHandler.enabled = drawerState.isOpen
    
    // ...
}
```

이 컴포저블은 '터치 핸들링을 지원하는 드로어'가 포함된 화면을 나타냅니다.  
드로어 상태는 `Closed`로 초기화되지만, 시간이 지남에 따라 `Open`으로 변경될 수 있습니다.  
컴포지션 및 리컴포지션이 발생할 때마다, 컴포저블은 현재 드로어 상태를 `TouchHandler`에 알려, 드로어가 `Open` 상태일 때만 터치 핸들링이 활성화되도록 합니다.

`drawerTouchHandler.enabled = drawerState.isOpen` 라인은 사이드 이펙트입니다.  
이는 **컴포지션의 사이드 이펙트**로 외부 객체인 `TouchHandler`에 콜백 참조를 할당하고 있습니다.

이미 설명했듯이, 컴포저블 본문에서 사이드 이펙트는 언제 실행할 지 제어할 수 없다는 문제가 있습니다.  
그 결과, 사이드 이펙트는 컴포지션 및 리컴포지션할 때마다 실행되고, 또한 **절대 폐기되지 않아** 잠재적인 메모리 누수가 발생할 수 있습니다.

네트워크 요청을 트리거하는 컴포저블 예시로 다시 돌아가 보겠습니다.  
만약, 사이드 이펙트로 네트워크 요청을 실행한 컴포저블이, 완료되기 전에 컴포지션에서 떠난다면 어떤 일이 발생할까요?  
아마 개발자들은 그 시점에서 작업을 취소하는 것이 더 적절할 수 있습니다.

사이드 이펙트는 상태를 가지는 프로그램에서 필수적이기 떄문에, Compose는 라이프사이클을 고려한 방식으로 사이드 이펙트를 실행할 수 있는 메커니즘을 제공합니다.
이를 통해 작업을 리컴포지션 동안 유지하거나, 컴포저블이 컴포지션에서 벗어날 때 자동으로 작업을 취소되도록 할 수 있습니다. 
이러한 메커니즘을 **이펙트 핸들러**(effect handler)라고 합니다.