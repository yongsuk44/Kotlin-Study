이펙트 핸들러를 다루기 전에, 사이드 이펙트(side effect)가 무엇인지 다시 한 번 살펴보는 것이 좋습니다.  
사이드 이펙트를 이해하면, 왜 컴포저블 트리에서 사이드 이펙트를 제어하는 것이 중요한지에 대한 맥락을 이해할 수 있습니다.

## Introducing side effects

사이드 이펙트는 Chapter 1에서 컴포저블의 속성을 배울 때 다루었습니다.  
사이드 이펙트는 함수의 비결정성(non-deterministic)을 초래하여, 개발자 코드를 이해하고 추론하기 어렵게 만드는 것을 배웠습니다.

본질적으로 사이드 이펙트는 함수의 제어 및 스코프를 벗어나는 모든 것을 의미합니다.  
두 숫자를 더하는 함수를 예로 들어보겠습니다:

```kotlin
// Add.kt
fun add(a: Int, b: Int): Int = a + b
```

위 함수는 입력값만을 사용해 결과를 계산하기에 "순수" 함수라고도 불립니다.  
이 함수는 입력값이 동일하면 항상 같은 결과를 반환하므로, 결정론적(determinisitic)이라고 할 수 있으며, 쉽게 이해할 수 있습니다.

이제, 여기에 부수적인 동작을 추가해 보겠습니다:

```kotlin
// AddWithSideEffect.kt
fun addWithSideEffect(a: Int, b: Int): Int =
    calculateionsCache.get(a, b)
        ?: (a + b).also { calculationsCache.store(a, b, it) }
```

위 코드를 보면, '계산 캐시'를 추가하여 이미 계산된 결과가 있을 경우 계산 시간을 절약합니다.  
그러나, 이 캐시는 함수의 제어를 벗어나므로, 마지막 실행 이후 값이 변경되지 않았을 거라는 보장이 없습니다.

만약, 다른 스레드에서 캐시가 동시에 업데이트 된다면, 동일한 입력 값으로 `get(a, b)`를 두 번 연속 호출했을 때, 서로 다른 결과가 반횐될 수 있습니다:

```kotlin
// AddWithSideEffect2.kt
fun main() {
    add(1, 2) // 3
    // Another thread calls: cache.store(1, 2, res = 4)
    add(1, 2) // 4
}
```

`add` 함수가 동일한 입력값에 대해 서로 다른 값을 반환하기에, 더 이상 결정론적이지 않습니다.  
이와 마찬가지로, 캐시가 메모리가 아닌 데이터베이스에 의존한다고 가정해보겠습니다.  
데이터베이스 연결이 끊겼다면, `get` 및 `store` 호출에서 예외가 발생할 수 있으며, 이런 예상치 못한 시나리오는 `add` 호출도 실패할 수 있습니다.

요약하자면 사이드 이펙트는 함수 호출자가 기대하는 것과 다른 예상치 못한 동작을 의미하며, 이로 인해 함수의 동작이 변경될 수 있습니다.  
사이드 이펙트는 개발자가 코드를 추론하기 어렵게 만들며, 테스트 가능성을 제거하여 불안정성을 초래할 수 있습니다.

사이드 이펙트는 다음과 같은 다양한 예시들이 있습니다.

- 전역 변수를 읽고 쓰는 것
- 메모리 캐시에 접근하는 것
- 데이터베이스를 사용하는 것
- 네트워크 요청을 보내는 것
- 화면에 무언가를 출력하는 것
- 파일에서 데이터를 읽는 것