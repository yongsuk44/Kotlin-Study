Jetpack Compose는 상태 스냅샷 시스템이라는 특별한 방식으로 상태를 표현하고 상태 변경을 전파하여, 최종적으로 리액티브 경험을 제공합니다.  
이 리액티브 모델은 컴포넌트가 입력에 따라 자동으로 리컴포즈되도록 하여, 코드를 더 강력하고 간결해지도록 도와줍니다.  
이를 통해, 과거 Android View 시스템에서 수동으로 변경 사항을 알리면서 발생했던 불필요한 보일러플레이트 코드를 피할 수 있습니다. 

이 챕터에서는 먼저 "스냅샷 상태"라는 용어를 소개하겠습니다.

## What snapshot state is

스냅샷 상태는 **변경 사항을 기억하고 관찰할 수 있는 격리된 상태**를 의미합니다. 
이는 `mutableStateOf`, `mutableStateListOf`, `mutableStateMapOf`, `derivedStateOf`, `produceState`, `collectAsState`와 같은 함수를 호출할 때 얻을 수 있는 상태를 의미합니다. 
이 함수들은 모두 특정 타입의 `State`를 반환하며, 개발자들은 이를 스냅샷 상태라고 부릅니다.

스냅샷 상태는 Compose 런타임에서 정의된 상태 스냅샷 시스템의 일부이기 때문에 이렇게 명명되었습니다.  
상태 스냅샷 시스템은 상태 변경 및 변경 사항 전파를 모델링하고 조정합니다.   
또한, 이 시스템은 독립적으로 설계되어 있어, 이론적으로는 관찰 가능한 상태를 필요로 하는 다른 라이브러리에서도 사용할 수 있습니다. 

변경 사항 전파와 관련하여, Compose 컴파일러는 모든 컴포저블 선언과 표현식을 래핑하여, **컴포저블 본문 내에서 자동으로 스냅샷 상태를 읽는 작업을 추적**합니다.
이를 통해 스냅샷 상태가 (자동으로) 관찰됩니다.
목표는 컴포저블이 참조하는 상태가 변경될 때마다, 런타임이 해당 컴포저블의 `RecomposeScope`를 무효화하여, 다음 리컴포지션에서 다시 실행되도록 하는 것입니다.

위 내용은 Compose에서 제공하는 인프라 코드로, 클라이언트 코드베이스에 필요하지 않습니다.  
Compose UI와 같은 런타임의 클라이언트는 무효화 및 상태 전파 방법, 리컴포지션 트리거 방법에 대해 전혀 알 필요가 없으며, 오직 상태와 함께 작동하는 빌딩 블록, 즉 컴포저블 함수 제공에만 집중하면 됩니다.

그러나 스냅샷 상태는 단순히 변경 사항을 자동으로 감지하여 리컴포지션을 트리거하는 것만을 의미하지 않습니다.  
"스냅샷"이라는 이름이 붙은 중요한 이유는 바로 **상태 격리** 때문입니다. 이는 동시성 관련 컨텍스트에서 적용되는 격리 수준을 의미합니다.

스레드 간에 가변 상태를 처리하는 것은 매우 복잡해질 수 있으며, 상태 무결성을 보장하기 위해서는 엄격한 조정과 동기화가 필요합니다.  
그렇지 않으면, 여러 스레드에서 동시에 상태를 읽거나 수정할 때 충돌, 발견하기 어려운 버그, 레이스 컨디션이 발생할 수 있습니다.

전통적으로, 프로그래밍 언어들은 동시성 문제를 해결하기 위해 다양한 방법을 사용해왔으며, 그 중 하나가 불변성입니다. 
불변 데이터는 생성된 후 수정할 수 없기에, 동시성 시나리오에서 안전합니다. 
또 다른 접근 방식으로는 액터 시스템(actor system)이 있으며, 이 시스템은 스레드 간 상태를 격리하여 관리합니다.
액터는 자신의 상태를 복사본으로 유지하며, 메시지를 통해 통신과 조정을 수행합니다. 
가변 상태일 경우, 프로그램의 전역 상태를 일관되게 유지하기 위해 어떤 조정이 필요합니다.
Compose 스냅샷 시스템은 액터 시스템을 기반으로 하지는 않지만, 이 접근 방식과 유사한 면이 있습니다.

Compose는 가변 상태를 활용하여 컴포저블이 상태 업데이트에 자동으로 반응할 수 있도록 합니다. 
따라서 불변 상태만으로는 이 라이브러리가 의미가 없을 것입니다. 
그러나 가변 상태를 활용하려면 여러 스레드에서 컴포지션이 가능하기에, 동시성 시나리오에서 공유 상태의 문제를 해결해야 합니다.
이를 위해 Compose는 상태 스냅샷 시스템을 도입하여 이 문제를 해결하며, 이 시스템은 상태를 격리하고 이후에 변경 사항을 전파하여 **스레드 간에 안전하게 가변 상태를 다룰 수 있도록** 합니다.

스냅샷 상태 시스템은 스레드 간 상태를 안전하게 조정하기 위해, 동시성 제어 시스템을 사용하여 모델링되었습니다.  
동시성 환경에서 공유 가변 상태를 다루는 것은 쉽지 않으며, 이는 라이브러리의 실제 사용 사례와는 무관한 일반적인 문제입니다.  
다음 섹션에서는 동시성 제어 시스템에 대해 자세히 살펴보고, Compose가 이를 어떻게 활용하는지 알아보겠습니다.

소개를 끝내기 전에, 스냅샷 상태 객체가 구현하는 `State` 인터페이스를 살펴보는 것이 유용할 수 있습니다.  
아래는 코드에서 어떻게 보이는지에 대한 예시입니다:

```kotlin
// SnapshotState.kt
@Stable
interface State<T> {
    val value: T
}
```

Jetpack Compose는 설계상 안정적인 구현만을 사용하기 때문에, 이 계약은 `@Stable`로 표시됩니다.  
다시 말해, 이 인터페이스를 구현하는 모든 클래스는 다음 사항을 **반드시** 준수해야 합니다:

- 동일한 두 `State` 인스턴스를 비교할 때, `equals` 메서드는 항상 일관된 결과를 반환해야 합니다.
- `value`와 같은 공용 프로퍼티가 변경될 때마다, 컴포지션은 반드시 이 변경 사항을 통지받아야 합니다.
- `value`와 같은 모든 공용 프로퍼티 타입은 안정적이어야 합니다.

이 프로퍼티들은 스냅샷 상태의 본질을 잘 나타냅니다.  
이후 섹션에서 스냅샷 상태 객체가 쓰여질 때마다, 컴포지션에 어떻게 알림이 전달되는지 자세히 살펴보겠습니다.  
이는 위에서 언급한 규칙 중 하나로 요구되는 사항입니다.

다음 섹션에서는 동시성 제어 시스템에 대해 알아보면서, Compose의 상태 스냅샷 시스템이 왜 이런 방식으로 모델링되었는지 쉽게 이해할 수 있을 것입니다.