Jetpack Compose는 상태 스냅샷 시스템이라는 특별한 방식으로 상태를 표현하고 상태 변경을 전파하여, 최종적으로 리액티브 경험을 제공합니다.  
이 리액티브 모델은 컴포넌트가 입력에 따라 자동으로 리컴포즈되도록 하여, 코드를 더 강력하고 간결해지도록 도와줍니다.  
이를 통해, 과거 Android View 시스템에서 수동으로 변경 사항을 알리면서 발생했던 불필요한 보일러플레이트 코드를 피할 수 있습니다. 

이 챕터에서는 먼저 "스냅샷 상태"라는 용어를 소개하겠습니다.

## What snapshot state is

스냅샷 상태는 **변경 사항을 기억하고 관찰할 수 있는 격리된 상태**를 의미합니다. 
이는 `mutableStateOf`, `mutableStateListOf`, `mutableStateMapOf`, `derivedStateOf`, `produceState`, `collectAsState`와 같은 함수를 호출할 때 얻을 수 있는 상태를 의미합니다. 
이 함수들은 모두 특정 타입의 `State`를 반환하며, 개발자들은 이를 스냅샷 상태라고 부릅니다.

스냅샷 상태는 Compose 런타임에서 정의된 상태 스냅샷 시스템의 일부이기 때문에 이렇게 명명되었습니다.  
상태 스냅샷 시스템은 상태 변경 및 변경 사항 전파를 모델링하고 조정합니다.   
또한, 이 시스템은 독립적으로 설계되어 있어, 이론적으로는 관찰 가능한 상태를 필요로 하는 다른 라이브러리에서도 사용할 수 있습니다. 

변경 사항 전파와 관련하여, Compose 컴파일러는 모든 컴포저블 선언과 표현식을 래핑하여, **컴포저블 본문 내에서 자동으로 스냅샷 상태를 읽는 작업을 추적**합니다.
이를 통해 스냅샷 상태가 (자동으로) 관찰됩니다.
목표는 컴포저블이 참조하는 상태가 변경될 때마다, 런타임이 해당 컴포저블의 `RecomposeScope`를 무효화하여, 다음 리컴포지션에서 다시 실행되도록 하는 것입니다.

위 내용은 Compose에서 제공하는 인프라 코드로, 클라이언트 코드베이스에 필요하지 않습니다.  
Compose UI와 같은 런타임의 클라이언트는 무효화 및 상태 전파 방법, 리컴포지션 트리거 방법에 대해 전혀 알 필요가 없으며, 오직 상태와 함께 작동하는 빌딩 블록, 즉 컴포저블 함수 제공에만 집중하면 됩니다.

그러나 스냅샷 상태는 단순히 변경 사항을 자동으로 감지하여 리컴포지션을 트리거하는 것만을 의미하지 않습니다.  
"스냅샷"이라는 이름이 붙은 중요한 이유는 바로 **상태 격리** 때문입니다. 이는 동시성 관련 컨텍스트에서 적용되는 격리 수준을 의미합니다.

스레드 간에 가변 상태를 처리하는 것은 매우 복잡해질 수 있으며, 상태 무결성을 보장하기 위해서는 엄격한 조정과 동기화가 필요합니다.  
그렇지 않으면, 여러 스레드에서 동시에 상태를 읽거나 수정할 때 충돌, 발견하기 어려운 버그, 레이스 컨디션이 발생할 수 있습니다.

전통적으로, 프로그래밍 언어들은 동시성 문제를 해결하기 위해 다양한 방법을 사용해왔으며, 그 중 하나가 불변성입니다. 
불변 데이터는 생성된 후 수정할 수 없기에, 동시성 시나리오에서 안전합니다. 
또 다른 접근 방식으로는 액터 시스템(actor system)이 있으며, 이 시스템은 스레드 간 상태를 격리하여 관리합니다.
액터는 자신의 상태를 복사본으로 유지하며, 메시지를 통해 통신과 조정을 수행합니다. 
가변 상태일 경우, 프로그램의 전역 상태를 일관되게 유지하기 위해 어떤 조정이 필요합니다.
Compose 스냅샷 시스템은 액터 시스템을 기반으로 하지는 않지만, 이 접근 방식과 유사한 면이 있습니다.

Compose는 가변 상태를 활용하여 컴포저블이 상태 업데이트에 자동으로 반응할 수 있도록 합니다. 
따라서 불변 상태만으로는 이 라이브러리가 의미가 없을 것입니다. 
그러나 가변 상태를 활용하려면 여러 스레드에서 컴포지션이 가능하기에, 동시성 시나리오에서 공유 상태의 문제를 해결해야 합니다.
이를 위해 Compose는 상태 스냅샷 시스템을 도입하여 이 문제를 해결하며, 이 시스템은 상태를 격리하고 이후에 변경 사항을 전파하여 **스레드 간에 안전하게 가변 상태를 다룰 수 있도록** 합니다.

스냅샷 상태 시스템은 스레드 간 상태를 안전하게 조정하기 위해, 동시성 제어 시스템을 사용하여 모델링되었습니다.  
동시성 환경에서 공유 가변 상태를 다루는 것은 쉽지 않으며, 이는 라이브러리의 실제 사용 사례와는 무관한 일반적인 문제입니다.  
다음 섹션에서는 동시성 제어 시스템에 대해 자세히 살펴보고, Compose가 이를 어떻게 활용하는지 알아보겠습니다.

소개를 끝내기 전에, 스냅샷 상태 객체가 구현하는 `State` 인터페이스를 살펴보는 것이 유용할 수 있습니다.  
아래는 코드에서 어떻게 보이는지에 대한 예시입니다:

```kotlin
// SnapshotState.kt
@Stable
interface State<T> {
    val value: T
}
```

Jetpack Compose는 설계상 안정적인 구현만을 사용하기 때문에, 이 계약은 `@Stable`로 표시됩니다.  
다시 말해, 이 인터페이스를 구현하는 모든 클래스는 다음 사항을 **반드시** 준수해야 합니다:

- 동일한 두 `State` 인스턴스를 비교할 때, `equals` 메서드는 항상 일관된 결과를 반환해야 합니다.
- `value`와 같은 공용 프로퍼티가 변경될 때마다, 컴포지션은 반드시 이 변경 사항을 통지받아야 합니다.
- `value`와 같은 모든 공용 프로퍼티 타입은 안정적이어야 합니다.

이 프로퍼티들은 스냅샷 상태의 본질을 잘 나타냅니다.  
이후 섹션에서 스냅샷 상태 객체가 쓰여질 때마다, 컴포지션에 어떻게 알림이 전달되는지 자세히 살펴보겠습니다.  
이는 위에서 언급한 규칙 중 하나로 요구되는 사항입니다.

다음 섹션에서는 동시성 제어 시스템에 대해 알아보면서, Compose의 상태 스냅샷 시스템이 왜 이런 방식으로 모델링되었는지 쉽게 이해할 수 있을 것입니다.

## Concurrency control systems

상태 스냅샷 시스템은 동시성 제어 시스템을 기반으로 구현되었으므로, 먼저 이 개념을 알아보겠습니다.

컴퓨터 사이언스에서 "동시성 제어"는 동시에 실행되는 연산들의 올바른 결과를 보장하기 위해, 조정과 동기화를 수행함을 의미합니다.  
동시성 제어는 시스템 정확성을 보장하는 일련의 규칙으로 구성되지만, 이러한 조정은 성능에 영향을 미칠 수 있습니다.
따라서 주요 과제는 성능 저하 없이 가능한 한 효율적인 동시성 제어 방법을 설계하는 것입니다.

대부분의 DBMS에서 사용하는 트랜잭션 시스템은 동시성 제어의 대표적인 예시입니다.  
이 컨텍스트에서 동시성 제어는 동시에 실행되는 환경에서도 데이터베이스 트랜잭션이 안전하게 수행되고, 데이터 무결성이 유지되도록 보장하는 것을 목표로 합니다.
여기서 "안정성"이란 트랜잭션이 아토믹하게 수행되고, 안전하게 롤백될 수 있으며, 커밋된 트랜잭션의 효과가 손실되지 않고, 중단된 트랜잭션의 효과가 데이터베이스에 남지 않도록 보장하는 것을 의미합니다.
이러한 문제를 해결하는 것은 매우 복잡할 수 있습니다.

동시성 제어는 DBMS뿐만 아니라 프로그래밍 언어에서도 자주 사용되며, 트랜잭셔널 메모리를 구현하는데 활용됩니다.  
실제로, Compose의 상태 스냅샷 시스템도 이 개념을 따릅니다.

트랜잭셔널 메모리는 로드 및 스토어의 연산 그룹을 아토믹하게 실행할 수 있게 하여 동시성 프로그래밍을 간소화합니다.  
상태 스냅샷 시스템에서도 스냅샷 간의 상태 변경이 전파될 때, 단일 아토믹 연산으로 상태 쓰기를 처리합니다.  
이러한 방식으로 연산을 그룹화하면, 병렬 시스템/프로세스에서 공유 데이터를 동시에 읽고 쓰는 과정을 더 쉽게 조정할 수 있으며, 아토믹한 변경 사항을 쉽게 중단하거나, 되돌리거나, 재현할 수 있습니다.
즉, 프로그램 상태의 모든 버전을 재현할 수 있는 변경 사항의 이력을 보유할 수 있습니다.

동시성 제어 시스템은 다음과 같은 여러 카테고리로 나뉩니다:

### Optimistic

옵티미스틱 방식은 읽기와 쓰기를 차단하지 않고, 이들이 안전하다고 가정합니다.  
그러나, 트랜잭션이 커밋될 때 요구되는 규칙을 위반할 가능성이 있다면 트랜잭션을 중단하고, 중단된 트랜잭션은 즉시 재실행됩니다.  
이 과정에서 오버헤드가 발생할 수 있지만, 중단된 트랜잭션의 수가 많지 않은 경우에는 효과적인 전략이 될 수 있습니다.

### Pessimistic 

페시미스틱 방식은 트랜잭션이 규칙을 위반할 가능성이 있는 경우, 그 가능성이 사라질 때까지 해당 트랜잭션을 차단합니다.


### Semi-optimistic

세미 옵티미스틱 방식은 다른 두 방식의 혼합한 하이브리드 솔루션입니다.  
일부 상황에서는 작업을 차단하고, 다른 상황에서는 옵티미스틱하게 처리하되, 커밋 시 충돌이 발생하면 중단합니다.

---

각 카테고리의 성능은 평균 트랜잭션 완료율(처리량), 요구되는 병렬성 수준, 데드락 발생 가능성 등 다양한 요인에 따라 달라질 수 있습니다.  
특히, 옵티미스틱이 아닌 카테고리는 데드락에 걸릴 가능성이 높으며, 
이 문제는 보통 진행이 멈춘(stalled) 트랜잭션을 중단하고, 다른 트랜잭션을 진행시킨 후, 중단된 트랜잭션을 가능한 빨리 재시작함으로써 해결됩니다.

Compose는 동시성 제어 시스템으로 옵티미스틱 방식을 사용합니다.   
상태 업데이트 충돌은 변경 사항이 전파될 때만 보고되며, 이 충돌은 자동으로 병합되거나, 병합이 불가능한 경우에는 변경 사항이 취소됩니다. 
(이에 대한 자세한 내용은 이후에 다룰 예정입니다.)

Compose의 동시성 제어 시스템은 DBMS에서 사용되는 것보다 간단하며, 시스템의 정확성을 유지하는데 중점을 두고 있습니다.  
데이터베이스 트랜잭션에서 흔히 볼 수 있는 복구 가능성, 내구성, 분산성, 복제성 같은 기능은 Compose 상태 스냅샷 시스템에서는 지원되지 않습니다. ("ACID"의 "D"는 포함되지 않습니다.)  
그러나, Compose 스냅샷은 메모리 내에서, 그리고 프로세스 내에서만 동작하며, 아토믹하고, 일관되며, 격리된 상태를 유지합니다.

앞서 언급한 다양한 동시성 제어 카테고리(옵티미스틱, 페시미스틱, 세미-옵티미스틱)와 함께, 추가적으로 사용할 수 있는 타입들이 있습니다.   
그 중 하나가 다중 버전 동시성 제어(MVCC)이며, Compose는 상태 스냅샷 시스템을 구현하기 위해 MVCC 방식을 사용합니다.  
이 시스템은 데이터베이스 객체가 수정될 때마다 새로운 버전을 생성하여 동시성과 성능을 향상시킵니다. 
또한, 객체의 다양한 최신 버전을 읽을 수 있게 해줍니다.

이제 MVCC 시스템에 대해 자세히 설명하고, 이 시스템의 목적에 대해 알아보겠습니다.

## Multiversion concurrency control (MCC or MVCC)

Compose의 전역 상태는 여러 컴포지션에서 공유되며, 이는 곧 **스레드**에서도 공유된다는 것을 의미합니다.  
컴포저블은 병렬로 실행될 수 있어야 하며, 이로 인해 스냅샷 상태를 동시에 읽거나 수정할 수 있어야 합니다.  
즉, 병렬로 리컴포지션이 가능하기에 상태 격리가 필요합니다.

동시성 제어의 주요 속성 중 하나는 **격리성**입니다. 이 속성은 데이터를 동시에 접근하는 시나리오에서 정확성을 보장합니다.  
격리성을 달성하는 가장 간단한 방법은 쓰기 작업이 완료될 때까지 모든 읽기 작업을 차단하는 것이지만, 이는 성능 면에서 매우 좋지 않을 수 있습니다.
MVCC(그리고 Compose)는 이러한 문제를 더 효과적으로 해결합니다.

격리성을 달성하기 위해, MVCC는 데이터 **여러 복사본**(스냅샷)을 유지합니다.  
이를 통해 각 스레드는 특정 시점에서 격리된 상태의 스냅샷을 사용할 수 있으며, 이는 상태의 다양한 **버전**("다중 버전)으로 이해할 수 있습니다.
한 스레드에서 수행된 수정 사항은 해당 스레드의 변경 작업이 모두 완료되고, 이 변경 사항이 다른 스레드로 전파될 때까지, 다른 스레드에서는 알 수 없습니다.

> 동시성 제어 시스템에서는 이 기술을 "스냅샷 격리"라고 하며, 각 "트랜잭션"(이 경우 스냅샷)이 어떤 버전을 볼 수 있는지를 결정하는 '격리 레벨'로 정의됩니다.

MVCC는 불변성을 활용하여, 데이터를 수정할 때마다 원본을 변경하는 대신 새로운 데이터 복사본을 생성합니다.  
이로 인해, 메모리에는 **동일한 데이터의 여러 버전**이 저장되며, 이는 객체의 모든 변경 사항에 대한 이력을 제공하는 것과 같습니다.  
Compose에서는 이러한 복사본을 "상태 기록(state records)"라고 하며, 이후 섹션에서 자세히 다루겠습니다.

MVCC의 또 다른 특징은 **특정 시점의 일관된 뷰**를 생성한다는 점입니다. 이 뷰는 특정 시점의 백업 파일처럼, 모든 객체 참조를 일관성 있게 유지합니다.
MVCC에서는 주로 트랜잭션 ID를 통해 이 일관성을 보장하며, 모든 읽기 작업은 참조할 ID를 결정하여 어떤 버전의 상태를 사용할지 결정합니다.
Compose에서도 이와 같은 방식으로 동작합니다. **각 스냅샷에는 고유한 ID가 할당**되며, 이 ID는 단조롭게 증가하는 값으로, 스냅샷이 자연스럽게 순서대로 정렬됩니다.
ID로 스냅샷을 구분하기에, 읽기와 쓰기 작업이 잠금 없이도 서로 격리될 수 있습니다.

동시성 제어 시스템의 필요성과 '다중 버전 동시성 제어'의 작동 방식을 이해한 지금, 상태 스냅샷 시스템의 내부 구조를 살펴볼 시점이 되었습니다.

## The Snapshot

스냅샷은 언제든지 특정 시점에 찍을 수 있으며, 찍힌 시점의 프로그램 상태(모든 스내샷 상태 객체)를 반영합니다.  
여러 개의 스냅샷을 찍을 수 있으며, 각 스냅샷은 **자신만의 격리된 프로그램 상태 복사본**을 받습니다.  
즉, 찍힌 시점에서 모든 스냅샷 상태 객체의 현재 상태를 복사한 것입니다. (`State` 인터페이스를 구현하는 객체들)

스냅샷은 서로 격리되어 있기 떄문에, 하나의 스냅샷에서 상태 객체를 수정해도 다른 스냅샷의 상태 복사본에는 영향을 주지 않습니다.
이러한 접근 방식은 상태를 안전하게 수정할 수 있도록 합니다.
또한, 여러 스레드가 동시에 실행되는 시나리오에서는 각 스레드가 서로 다른 스냅샷을 가리키게 되므로, 각각 다른 상태 복사본을 사용하게 됩니다.

Compose 런타임은 프로그램의 현재 상태를 모델링하기 위해 `Snapshot` 클래스를 제공합니다.  
스냅샷을 찍고 싶다면, `Snapshot.takeSnapshot()` 정적 메서드를 호출하여, 모든 상태 객체의 현재 값을 스냅샷으로 저장할 수 있습니다.
저장된 스냅샷은 `snapshot.dispose()`가 호출될 때까지 유지되며, 이 호출은 스냅샷의 수명을 결정합니다.

스냅샷은 생성된 시점부터 해제(disposed)될 때까지 액티브 상태로 간주되며, 이처럼 스냅샷은 라이프사이클을 가집니다. 
스냅샷 사용이 끝나면 반드시 `snapshot.dispose()`를 호출하여 해제해야 하며, 해제되지 않은 스냅샷은 상태와 리소스가 유지되므로, 메모리 누수가 발생합니다.

스냅샷이 찍히면 ID가 부여되어, 다른 스냅샷이 유지하는 동일한 상태의 다른 버전들과 쉽게 구분할 수 있습니다. 
이로 인해 프로그램 상태를 **버전화**할 수 있으며, 프로그램 상태를 **특정 버전에 따라 일관되게 유지**하는 다중 버전 동시성 제어를 가능하게 합니다.

스냅샷의 작동 방식을 이해하는 가장 좋은 방법은 코드를 통해 확인하는 것입니다:

```kotlin
fun main() {
    val dog = Dog()
    dog.name.value = "Rex"
    val snapshot = Snapshot.takeSnapshot()
    dog.name.value = "Fido"
    
    println(dog.name.value)                     // Prints "Fido"
    snapshot.enter { println(dog.name.value) }  // Prints "Rex"
    println(dog.name.value)                     // Prints "Fido"
}
```

`enter` 함수는 "스냅샷에 진입한다."라고 불리며, **스냅샷의 컨텍스테에서 람다를 실행**하여, 스냅샷이 해당 상태에 대한 리소스의 출처(source of truth)가 되도록 합니다. 
즉, 람다 내에서 읽히는 모든 상태 값은 스냅샷에서 가져오게 됩니다. 이 메커니즘은 Compose와 기타 클라이언트 라이브러리들이 특정 스냅샷의 컨텍스트에서 상태를 다루는 로직을 실행할 수 있도록 합니다.
이 작업은 로컬 스레드에서만 이루어지고, `enter` 호출이 반환될 때까지 지속됩니다. 다른 스레드에는 전혀 영향을 주지 않습니다. 

위 예시에서 볼 수 있듯이, Dog의 이름은 업데이트 후 "Fido"가 되지만, 스냅샷의 컨텍스트에서 읽으면 "Rex"가 반환됩니다.  
이는 **스냅샷이 찍힌 시점에 가졌던 값**을 반환하기 때문입니다.

> `enter` 내부에서는 스냅샷 타입에 따라 상태를 읽고 쓸 수 있습니다.  
> 스냅샷 타입으로는 '읽기 전용 스냅샷'과 '가변 스냅샷'이 있으며, 가변 스냅샷은 이후에 자세히 다룰 예정입니다.

`Snapshot.takeSnapshot()`으로 생성된 스냅샷은 읽기 전용이므로, 해당 스냅샷이 보유한 상태는 수정할 수 없습니다.  
만약 스냅샷 내의 상태 객체에 쓰기 작업을 시도하면, 예외가 발생합니다.

그러나, 상태를 읽는 것뿐만 아니라, 상태를 업데이트(쓰기)해야 할 수도 있습니다.  
Compose에서는 이 시나리오를 대비하여, `Snapshot` 계약의 특정 구현체인 `MutableSnapshot`을 제공합니다.  
또한, 이 외에도 다양한 스냅샷 구현체들이 존재하며, 아래는 다양한 스냅샷 타입을 요약한 코드입니다:

```kotlin
// Snapshot.kt
sealed class Snapshot(...) {
    open class MutableSnapshot(...) : Snapshot() {...}
    class ReadonlySnapshot(...) : Snapshot() {...}
    class NestedReadonlySnapshot(...) : Snapshot() {...}
    class NestedMutableSnapshot(...) : MutableSnapshot() {...}
    class GlobalSnapshot(...) : MutableSnapshot() {...}
    class TransparentObserverMutableSnapshot(...) : MutableSnapshot() {...}
}
```

다양한 스냅샷 타입을 간단히 살펴보겠습니다:

- `ReadonlySnapshot` : 이 스냅샷이 보유한 상태 객체는 읽기만 가능하며, 수정할 수 없습니다.
- `MutableSnapshot` : 이 스냅샷이 보유한 상태 객체는 읽기와 수정이 모두 가능합니다.
- `NestedReadonlySnapshot` 및 `NestedMutableSnapshot` : 스냅샷은 트리 구조를 형성하므로, 하나의 스냅샷은 여러 개의 중첩된 읽기 전용 및 가변 스냅샷을 자식으로 가질 수 있습니다. 이는 이후에 자세히 다루겠습니다.
- `GlobalSnapshot` : 전역(공유) 프로그램 상태를 보유하는 가변 스냅샷으로, 모든 스냅샷의 최종적인 루트 역할을 합니다.
- `TransparentObserverMutableSnapshot` : 이 스냅샷은 특별한 경우로, 상태 격리를 적용하지 않으며, 상태 객체가 읽히거나 쓰일 때마다 읽기 및 쓰기 관찰자에게 알리기 위해 존재합니다.
이 스냅샷의 모든 상태 기록은 자동으로 무효화되어 다른 스냅샷에서 볼 수 없거나 읽을 수 없습니다.
또한, 이 스냅샷의 ID는 항상 부모 스냅샷의 ID와 동일하며, 생성된 모든 기록은 부모 스냅과 연관됩니다.
마지막으로, 이 스냅샷에서 수행된 모든 작업은 부모 스냅샷에서 수행된 것처럼 작동하므로 "투명(transparent)"하다고 불립니다.
  
## The snapshot tree

스냅샷은 **트리 구조를 형성**하며, 이 구조에서 `NestedReadonlySnapshot` 및 `NestedMutableSnapshot` 같은 중첩된 스냅샷 타입이 존재합니다.
하나의 스냅샷은 여러 개의 중첩된 스냅샷을 포함할 수 있으며, 트리의 루트는 전역 상태를 보유하는 `GlobalSnapshot`이 담당합니다.

<img alt="img.png" src="snapshot_tree.png" width="70%"/>

중첩된 스냅샷은 **부모 스냅샷을 액티브 상태로 유지하면서 독립적으로 해제**할 수 있는 스냅샷의 독립적인 복사본과 같습니다.  
이 중첩된 스냅샷은 **서브 컴포지션**을 다룰 때, Compose에서 자주 사용됩니다.

> 챕터 2에서 언급했듯이, 서브 컴포지션은 **독립적인 무효화**를 지원하기 위해, 부모 컴포지션 내에서 인라인으로 생성된 컴포지션이라고 설명했습니다.  
> 컴포지션과 서브 컴포지션은 트리 구조로 연결되어 있습니다.

중첩된 스냅샷이 생성되는 서브 컴포지션의 예로는, LazyList 아이템이나 `BoxWithConstraints`가 컴포즈될 때를 들 수 있습니다.  
또한, `SubcomposeLayout`이나 `VectorPainter`에서도 서브 컴포지션을 찾을 수 있습니다.

서브 컴포지션이 필요할 때, 상태를 저장하고 격리하기 위해 중첩된 스냅샷이 생성됩니다.  
이렇게 하면, 서브 컴포지션이 사라질 때 해당 스냅샷을 해제할 수 있으며, 부모 컴포지션과 부모 스냅샷은 그대로 유지됩니다.  
중첩된 스냅샷에 변경 사항이 발생하면, 이 변경 사항은 부모 스냅샷으로 전파됩니다.

모든 스냅샷 타입은 중첩된 스냅샷을 생성하여, 부모 스냅샷과 연결할 수 있는 기능을 제공합니다.  
예를 들어, `Snapshot#takeNestedSnapshot()` 또는 `MutableSnapshot#takeNestedMutableSnapshot()` 같은 함수가 있습니다.

읽기 전용 자식 스냅샷은 모든 스냅샷 타입에서 생성될 수 있지만, 가변 스냅샷은 또 다른 가변 스냅샷에서만 생성될 수 있습니다.  
또한, 전역 스냅샷은 가변 스냅샷으로 간주될 수 있기에, 전역 스냅샷에서도 가변 스냅샷을 생성할 수 있습니다.

## Snapshots and threading

스냅샷은 특정 스레드에 종속되지 않고, 스레드의 범위를 벗어나 존재하는 독립적인 구조로 생각하는 것이 중요합니다.  
스레드는 현재 스냅샷을 가질 수 있지만, 스냅샷은 **반드시 스레드에 연결되는 것은 아닙니다.**  
스레드는 임의로 스냅샷에 진입하거나 빠져나올 수 있으며, 자식 스냅샷은 다른 스레드에서 진입할 수 있습니다.  
실제로, 병렬 작업은 스냅샷의 주요 사용 사례 중 하나로, 여러 자식 스레드는 각자 자신만의 스냅샷을 가질 수 있습니다.

가변 스냅샷을 정의하면, 자식 스냅샷이 부모 스냅샷과의 일관성을 유지하기 위해 변경 사항을 알리는 방법을 배우게 됩니다.  
모든 스레드의 변경 사항은 서로 격리되며, 서로 다른 스레드 간의 충돌 업데이트는 감지되고 처리됩니다. (자세한 내용은 이후에 다룹니다.)  
중첩된 스냅샷은 이러한 작업을 재귀적으로 분할할 수 있게 하며, 이를 통해 병렬 컴포지션과 같은 기능을 활성화할 수 있습니다.

스레드의 현재 스냅샷은 `Snapshot.current`를 통해 언제든지 가져올 수 있습니다.  
이 함수는 현재 스레드에 스냅샷이 존재하면 해당 스냅샷을 반환하고, 그렇지 않은 경우 전역 상태를 보유한 전역 스냅샷을 반환합니다.