Compose를 생각할 때, Composable이 실제 UI를 생성하지 않고, Composer를 통해 런타임(Slot table)이 관리하는 메모리 내 구조에 변경 사항을 "방출"한다는 점을 기억해야 합니다.
이러한 표현은 나중에 이를 통해 UI를 "구체화"하는 것으로 해석되어야 합니다.

Chpater 3는 Compose 런타임에 중점을 두고 있지만, Compose의 다양한 부분이 어떻게 소통하고 협력하는지에 대한 매핑을 중점으로 볼 것입니다.

위 표현은 Composable 함수가 컴포지션에 변경 사항을 방출하여, 모든 관련 정보로 컴포지션을 업데이트할 수 있도록 하고, 컴파일러 덕분에 주입된 $composer 인스턴스를 통해 이루어진다는 것을 설명했습니다.(Chapter 2에서) 
현재 Composer 인스턴스를 얻기 위한 호출과 컴포지션 자체는 Compose 런타임의 일부입니다.

지금까지는 런타임이 메모리에 유지하는 상태를 "컴포지션"이라고 참조했습니다. 이는 의도적으로는 표면적인 개념입니다.
컴포지션 상태를 저장하고 업데이트하는데 사용되는 데이터 구조에 대해 시작하겠습니다.

## The slot table and the list of changes

슬롯 테이블(slot table)은 런타임이 컴포지션의 현재 상태를 저장하는데 사용하는 최적화된 메모리 내 구조 입니다.  
초기 컴포지션 동안 데이터로 채워지며, 재구성이 이루어질 때마다 업데이트됩니다.
슬롯 테이블은 모든 Composable 함수 호출의 흔적을 포함하고 있습니다. 여기에는 소스 코드 내의 위치, 파라미터, remember 값, CompositionLocal 등이 포함됩니다. 

컴포지션 동안 발생한 모든 정보가 슬롯 테이블에 기록됩니다.   
이 모든 정보는 Composer가 다음 변경 목록(list of changes)을 생성하는데 사용됩니다.  
이는 트리에 대한 모든 변경 사항이 항상 컴포지션의 현재 상태에 따라 달라지기 때문입니다.

반면, 변경 목록은 노드 트리에 실제 변경을 가하는 역할을 합니다.
이는 일종의 패치 파일로 이해할 수 있으며, 패치 파일이 적용되면 트리가 업데이트되는 것과 마찬가지로, 변경 목록도 적용되면 트리가 변경됩니다.
필요한 모든 변경 사항을 기록하고 이를 나중에 적용해야 합니다. 이 변경 사항을 적용하는 것은 Applier의 역할입니다.
Applier는 런타임이 트리를 최종적으로 구체화하는데 사용하는 추상화된 개념입니다.

마지막으로, Recomposer는 언제, 어떤 스레드에서 재구성을 할지, 그리고 언제, 어떤 스레드에서 변경 사항을 적용할지를 결정하는 역할을 합니다.
Recomposer는 모든 작업을 조정하는 중요한 역할을 합니다.

## The slot table in depth

컴포지션의 상태가 저장되는 방법을 알아보겠습니다. 
슬롯 테이블은 빠른 선형 접근을 위해 최적화된 데이터 구조입니다.
이는 텍스트 편집기에서 매우 흔한 "gap buffer" 개념을 기반으로 합니다. 

슬롯 테이블은 두 개의 데이터를 선형 배열에 저장합니다.   
하나의 배열은 컴포지션에 있는 그룹에 대한 정보를 저장하고, 다른 하나는 각 그룹에 속하는 슬롯(slot)을 저장합니다.

```kotlin
var groups = IntArray(0)
    private set

var slots = Array<Any?>(0) { null }
    private set
```

> Chapter2에서 컴파일러가 Composable 함수 본문을 감싸서 그룹을 방출하게 하는 방법에 대해 배웠습니다.
> 이러한 그룹은 메모리에 저장되면 Composable에 대한 고유 키를 제공하여 나중에 식별할 수 있게 합니다. 
> 그룹은 Composable 호출과 그 자식 호출에 대한 모든 관련 정보를 포함하며, Composable을 그룹으로 취급하는 방법에 대한 정보를 제공합니다.
> 그룹은 Composable 본문 내에서 찾은 제어 흐름 패턴에 따라 다른 유형을 가질 수 있습니다: Restartable 그룹, moveable 그룹, replaceable 그룹, reusable 그룹 등...

그룹 배열은 "그룹 필드"만 저장하므로 `Int` 값을 사용합니다.  
그룹 필드는 그룹에 대한 메타데이터를 나타내며, 부모 그룹과 자식 그룹은 그룹 필드 형태로 저장됩니다.  
선형 데이터 구조이기에 부모 그룹의 그룹 필드는 항상 먼저 오고, 자식 그룹의 모든 그룹 필드는 그 뒤를 따릅니다.
이는 그룹 트리를 선형 방식으로 모델링하는 방법이며, 자식을 선형으로 스캔하는데 유리합니다.
무작위 접근은 그룹 앵커를 통해 이루어지지 않는 한 비용이 많이 듭니다. 앵커(`Anchors`)는 이 목적을 위해 존재하는 포인터와 같습니다.

다른 한편, 슬롯 배열은 각 그룹에 대한 관련 데이터를 저장합니다.
모든 타입의 값을 저장할 수 있도록 `Any?` 타입을 사용합니다. 실제 컴포지션 데이터는 여기에 저장됩니다.
그룹은 항상 슬롯 범위와 연결되어 있기 때문에 `groups`에 저장된 각 그룹은 `slots`에서 슬롯을 찾고 해석하는 방법을 설명합니다.

슬롯 테이블은 읽기 및 쓰기를 위해 갭을 사용합니다. 이를 테이블의 범위로 생각해보세요.
이 갭은 데이터를 읽거나 쓸 때 배열로부터 읽어들이는 위치를 결정합니다. 
갭은 쓰기를 시작할 위치를 나타내는 포인터를 가지고 있으며, 시작 및 끝 위치를 이동시킬 수 있으므로 테이블의 데이터도 덮어쓸 수 있습니다.

![gap.png](gap.png)

다음 조건부 로직을 생각해보세요:

```kotlin
@Composable
@NonRestartableComposable
fun ConditionalText() {
    if (a) {
        Text(a)
    } else {
        Text(b)
    }
}
```

이 Composable이 non-restartable로 플래그가 지정되었기 때문에, restartable 그룹 대신 replaceable 그룹이 삽입됩니다.
이 그룹은 현재 "active" 자식에 대한 데이터를 테이블에 저장합니다. `a`가 `true`인 경우 `Text(a)`가 됩니다. 
조건이 변경되면 갭은 그룹의 시작 위치로 돌아가서 거기서부터 쓰기를 시작하여 `Text(b)`에 대한 데이터로 모든 슬롯을 덮어씁니다.

테이블에서 읽고 쓰기 위해 `SlotReader`와 `SlotWriter`가 있습니다. 
슬롯 테이블은 여러 active reader를 가질 수 있지만, active writer는 하나만 가질 수 있습니다.
각 읽기 또는 쓰기 작업 후 해당 reader 또는 writer는 닫힙니다.
원하는 만큼 많은 reader를 열 수 있지만, 안전을 위해 테이블이 작성 중일 때는 읽을 수 없습니다.
active writer가 닫히기 전까지 `SlotTable`은 무효 상태로 남아 있습니다. 왜냐하면 그룹과 슬롯을 직접 수정하기 때문에 동시에 읽으려고 하면 경쟁 조건(race condition)이 발생할 수 있기 때문입니다.

reader는 방문자처럼 동작합니다. 현재 그룹을 읽기 위해 그룹 배열에서 읽는 위치, 시작 및 끝 위치, 부모(바로 전에 저장된) 그룹, 현재 그룹에서 읽는 현재 슬롯, 그룹이 가진 슬롯 수 등을 추적합니다.
reader는 다시 위치를 지정하거나, 그룹을 건너뛰거나, 현재 슬롯에서 값을 읽거나, 특정 인덱스에서 값을 읽는 등의 작업을 수행할 수 있습니다. 
즉, 배열에서 그룹 및 슬롯에 대한 정보를 읽기 위해 사용됩니다.

반면, writer는 그룹과 슬롯을 배열에 쓰기 위해 사용됩니다.  
`SlotWriter`는 위에서 언급한 그룹과 슬롯의 갭을 사용하여 배열 내에서 어디에 쓸지를 결정합니다.

갭을 슬라이드하고 크기를 조정할 수 있는 선형 배열의 범위로 생각해보세요.  
writer는 시작 및 끝 위치, 각 갭의 길이를 추적합니다. 시작 및 끝 위치를 업데이트하여 갭을 이동시킬 수 있습니다.

writer는 그룹 및 슬롯을 추가, 교체, 이동 및 제거할 수 있습니다.  
예를 들어, 트리에 새 Composable 노드를 추가하거나 조건이 변경될 때 교체해야 하는 조건부 로직의 Composable을 추가할 수 있습니다.

writer는 그룹과 슬롯을 건너뛰고, 일정 위치만큼 전진하고, 앵커에 의해 결정된 위치로 이동하거나, 다른 유사한 작업을 수행할 수 있습니다.

writer는 테이블을 통해 빠르게 접근할 수 있도록 특정 인덱스를 가리키는 앵커 목록을 추적합니다.  
각 그룹의 위치(그룹 인덱스)는 앵커를 통해 추적됩니다. 앵커는 그룹이 이동, 교체, 삽입 또는 앵커가 가리키는 위치 앞에서 제거될 때 업데이트됩니다.

슬롯 테이블은 컴포지션 그룹의 반복자(iterator)로도 작동하므로, 툴이 컴포지션을 검사하고 표시할 수 있도록 컴포지션 그룹에 대한 정보를 제공할 수 있습니다.