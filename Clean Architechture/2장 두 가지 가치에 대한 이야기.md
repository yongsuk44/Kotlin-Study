## 개요

모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치인, **행위(behavior)와 구조(structure)를 제공** 함

소프트웨어 개발자는 반드시 이 '두 가지 가치'를 모두 '높게 유지'해야 하는 책임을 가지고 있음  
그러나 대부분의 개발자들은 한 가지 가치에만 집중하고 나머지 가치를 배제하곤 함,   
더 나아가, 개발자는 대체로 둘 중 덜 중요한 가치에 집중하여 결국에는 소프트웨어 시스템이 무너지게 되는 상황이 발생할 수 있음

### 행위 (Behavior)

프로그래머의 고용 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서 임.  
이를 위해 프로그래머는 이해관계자가 '기능 명세서'나 '요구사항 문서'를 '구체화' 할 수 있도록 돕고, 
이해관계자의 기계가 이러한 '요구사항'을 '만족'하도록 '코드를 작성'함

기계가 요구사항을 위반하면, 프로그래머는 디버그를 통해 문제를 해결해야 함.  
많은 프로그래머가 요구사항을 기계에 구현하고 버그를 수정하는 일이 '자신의 직업이라고 믿음'. 

하지만, 이는 **잘못된 생각**임

### 아키텍처 (Architecture)

소프트웨어는 '부드러움을 지니도록' 만들어 졌음. 즉, '기계의 행위'를 '쉽게 변경'할 수 있도록 하기 위해서 임  
만약 기계의 행위를 바꾸는 일을 어렵게 만들고자 했으면, 우리는 소프트웨어가 아닌 하드웨어라고 불렀을 것임

소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 **변경하기 쉬워야 함**.  
예를 들어, 이해관계자가 기능에 대한 생각을 바꾸면, 이런 변경사항을 간단하고 쉽게 적용할 수 있어야 함.  
여기서 변경사항을 적용하는데 드는 어려움은 '변경되는 범위'에 비례하고, '변경사항의 형태'와 관련이 없어야 함

**소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 바로 이 '변경사항의 범위'와 '형태의 차이'에 있음**

이해관계자는 계속해서 '비슷한 변경사항 범위'를 제시하지만,   
개발자 입장에서는 복잡도가 지속적으로 증가하는 퍼즐 판 위에서 계속해서 퍼즐 조각을 맞추라는 지시를 하는 것처럼 느껴짐  
즉, 새로운 요청사항은 이전의 변경사항을 적용하는 것보다 더 힘들어지는 데, 이는 **'시스템의 형태'와 '요구사항의 형태'가 서로 맞지 않기 때문임.**

이러한 이유로 개발자 입장에서의 개발 비용은 요청된 '변경사항의 크기'에 '비례'하게 됨.  
또한, 개발 비용은 시간이 지남에 따라 '증가'하게 됨 (e.g `개발 첫 시작 한 해 < 그 다음 해 < 그 다음 해 < ...`)

문제는 당연하게도 **시스템 아키텍처**로, 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어짐.  
따라서 아키텍처는 '형태에 독립적'이어야 하고, 그럴수록 더 '실용적'이게 됨.

### 더 높은 가치

그렇다면, 다음과 같은 고민이 생길 수 있음

- 기능과 아키텍처 중 어느 것의 가치가 더 높은지? 
- 소프트웨어 시스템이 동작하도록 만드는 것과 소프트웨어 시스템을 더 쉽게 변경 할 수 있는 것 중 어느 것이 더 중요한 지?

업무 관리자에게 묻는다면 대다수는 소프트웨어 시스템이 동작하는 것이 더 중요다고 답할 것임.  
이어서 개발자에게 묻는다면 업무 관리자의 의견에 대체로 동조하는 스탠스를 취하게 됨.   

하지만 이는 **잘못된 태도 임**

1. 완벽하게 동작하지만 수정이 아예 불가능한 프로그램을 받는 경우, 이 프로그램은 요구사항이 변경될 때 동작하지 않게되고, 결국에는 폐기될 것임.
2. 동작은 하지 않지만, 변경이 쉬운 프로그램을 받는 경우, 이 프로그램을 돌아가도록 만들 수 있고, 변경사항이 발생하더라도 쉽게 유지보수 할 수 있을 것임.

물론 이러한 주장이 현실적이지 않지만, **변경사항을 적용하는 비용이 창출되는 이익을 초과하는 경우, 현실적으로 수정이 불가능할 수 있음.**  
이는 기능 또는 설정 측면에서 많은 시스템이 현실적으로 겪고 있는 상황이며 문제임.

다시 한 번, 업무 관리자에게 변경 가능한 시스템을 원하는지 묻는다면, 당연히 그렇다고 할 것이며 추가적으로 "현재 기능의 동작 여부가 미래의 유연성보다 더 중요하다." 라는 첨언을 할 것임.
하지만, 추후 업무 관리자의 변경 요청에 "비용이 너무 커서 현실적으로 적용할 수 없다."라고 대답하면, "실질적으로 변경이 불가능한 상태에 처할 때까지 시스템을 방치했다."며 비난할 것임.

### 중요성과 긴급성

소프트웨어의 첫 번째 가치인 '행위'는 긴급하지만 매번 높은 중요도를 가지지 않음.  
소프트웨어의 두 번째 가치인 '아키텍처'는 긴급하지 않지만, 높은 중요도를 가짐.

물론 어떤 일은 긴급하면서 중요할 수 있지만, 긴급하지 않고 중요하지 조차 않은 일도 있음.  
이에 따라 이들을 다음과 같은 우선순위를 매길 수 있게 됨.

1. 긴급하고 중요한 일
2. 긴급하지 않지만 중요한 일
3. 긴급하지만 중요하지 않은 일
4. 긴급하지도 중요하지도 않은 일

'아키텍처'는 해당 우선순위에서 두 번째에 해당되는 반면, '행위'는 첫 번째와 세 번째에 해당됨.

여기서 업무 관리자와 개발자가 흔히 범하는 실수는 세 번째에 위치한 항목을 첫 번째로 격상시켜 버리는 일임.  
다시 말해, '긴급하지만 중요하지 않은 일'과 진짜로 '긴급하고 중요한 일'을 구분하지 못하는 것임.  
이러한 실수로 인해 시스템에서 중요도가 높은 '아키텍처'를 무시한 채 중요도가 떨어지는 '행위'를 선택하게 될 수 있음

업무 관리자는 보통 아키텍처의 중요성을 평가할 만한 능력을 겸비하지 못하기에 개발자는 '딜레마'에 빠지게 됨.  
소프트웨어 개발자를 고용하는 이유는 바로 이 '딜레마'를 해결하기 위해서 임.  
따라서 **'행위'의 긴급성이 아닌 '아키텍처'의 중요성을 업무 관리자에게 설명하는 것이 개발자의 책임임.**

> '아키텍처'가 후순위가 되면 시스템을 개발하는 비용이 더 많이 발생되고, 일부 또는 전체 시스템에 변경 하는 일이 현실적으로 불가능해 진다.  
> 이러한 상황이 발생하도록 용납했다면, 이는 소프트웨어 개발팀이 스스로 '행위'의 긴급성을 높이는 것이며, '딜레마'를 해결하지 못했음을 말함.