## 증명 (proof)

데익스트라는 아주 작은 세부사항이라도 간과하면, 프로그램이 동작하는 것처럼 보여도 결국엔 예상외의 방식으로 실패했음.

이러한 문제를 수학적 원리인 '증명'을 적용하여 해결하려 했고, 
그는 ['유클리드 계층구조'](#유클리드-계층구조)를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었음.  
즉, 프로그래머는 입증된 구조를 이용하고, 이 구조를 코드와 결합시켜, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식임.  

여기서 데익스트라는 재귀적으로 모듈을 더 작은 단위로 분해하는 과정에서 'goto 문장'이 방해가 되는 경우가 있다는 사실을 발견함.  
만약 모듈을 분해할 수 없다면, 합리적인 증명 기법인 '분할 정복 접근법'을 사용할 수 없음.  
반면, 'goto 문장'을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 '좋은 goto 문장'의 사용 방식은 
`if/then/else`와 `do/while/until`과 같은 분기와 반복이라는 '**단순한 제어 구조**'에 해당한다는 사실을 발견함.  
즉, 이는 **모듈이 단순한 제어 구조만을 사용한다면 '증명 가능한 단위'로까지 '모듈'을 '재귀적으로 세분화'하는 것이 '가능'하다는 것을 발견**함.  

뵘과 야코피니는 '**단순한 제어 구조**'를 통해 모든 프로그램을 **'순차, 분기, 반복' 세 가지 구조로 표현**할 수 있다는 것을 '증명'함.  
이를 통해, **모듈을 증명 가능하게 하는 '단순한 제어 구조'가 모든 프로그램을 만들 수 있는 '단순한 제어 구조'의 최소 집합과 동일하다는 사실을 발견하며 구조적 프로그래밍이 탄생하게 됨.**

### 기능적 분해

구조적 프로그래밍을 통해 재귀적으로 모듈을 증명 가능한 더 작은 단위로 분해할 수 있게 되었고, 이는 결국 **모듈을 기능적으로 분해할 수 있음**을 뜻함.
즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능으로 분해 후 각 기능을 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있음.

이처럼 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화가 가능해짐.

### 테스트

데익스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수 없다." 라고 말함.  
즉, **프로그램이 잘못되었음을 테스트를 통해 증명할 수 있지만, 프로그램이 맞다고 증명할 수 없음.**  
테스트에 충분한 노력을 들이면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 '참'이라는 것을 보여줄 수 있을 뿐임.

이와같은 사실은 소프트웨어 개발에서 수학적인 구조를 다루는 듯 보이더라도, 사실은 **과학적인 방법을 따르고 있음**을 보여줌.  
과학은 서술된 내용이 사실임을 증명하는 방식이 아닌, 서술이 틀렸음을 증명하는 방식으로 동작함.  
즉, 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있음.  
이는 최선을 다하더라도 올바르지 않음을 증명하는데 실패함으로써, 올바름을 보여주기 때문에 과학적인 방법을 따름.

이런 **부정확함에 대한 '증명'은 입증 가능한 프로그램에만 적용**할 수 있음.  
예를 들어 제약 없는 'goto 문'을 사용하는 등의 이유로 입증이 불가능한 프로그램은 테스트를 아무리 수행하더라도 올바르다는 것을 증명할 수 없음.

구조적 프로그래밍은 **프로그램을 '증명 가능한 세부 기능 집합'으로 재귀적으로 분해할 것을 강요**함.  
그 후, 테스트를 통해 '증명 가능한 세부 기능'들이 거짓인지를 증명하려고 시도함.  
거짓임을 증명하는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 됨.

## 결론

구조적 프로그래밍이 오늘날 까지 가치 있는 이유는 프로그래밍에서 **반증 가능한 단위를 만들어 낼 수 있는 능력** 때문임.  
또한 흔히 현대적 언어가 아무런 제약 없는 'goto 문장'을 지원하지 않는 이유이기도 함.  
뿐만 아니라, **아키텍처 관점에서는 기능적 분해를 최고의 실천법** 중 하나로 여기는 이유이기도 함.

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 '모든 수준에서 소프트웨어는 과학과 같고', 따라서 **반증 가능성에 의해 주도됨**.  
소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 **쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 노력**해야 함.

---

#### 유클리드 계층구조

- 공리(axiom) : 증명 없이 참으로 받아들이는 명제
  - 유클리드 기하학에서 "두 점이 주어졌을 때, 두 점을 지나는 직선이 단 하나 존재한다."는 명제 역시 증명할 수 없기에 '공리'라 함.
- 정리(theorem) : 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제
- 보조정리(lemma) : '정리'를 증명하는데 필요한 '정리'
- 따름정리(corollary) : '정리'를 통해 자연스럽게 도출되는 '정리'