`Flow`는 기본적으로 Back pressure를 지원하며 생산자와 소비자 사이의 데이터 흐름을 자연스럽게 조절할 수 있습니다.

`Flow`는 소비자가 준비되지 않았을 경우 자동으로 일시 중지됩니다.  
이는 `collect()`가 호출되기 전까지 `Flow`가 실제로 데이터를 방출하지 않았다는 것을 의미 합니다.  
따라서 소비자가 준비되면 `Flow`는 자동으로 재개됩니다.

---

추가로 더 세밀한 Back pressure 관리를 하기위해 다음 연산자들을 지원합니다.

### Buffering

`buffer` 연산자를 사용하여 `Flow`의 버퍼 크기를 조절할 수 있습니다.  
생산자가 소비자보다 빠르게 데이터 생성 시 일정량의 데이터를 버퍼에 저장할 수 있습니다.

```kotlin
flow {
    // ...
}.buffer(16) // 버퍼 크기를 16으로 설정
```

### Throttling

`debounce` 연산자를 통해 빠르게 변경되는 데이터의 흐름을 제어할 수 있습니다.

```kotlin
flow { 
    // ...
}.debounce(100) 100ms 이내에 새로운 데이터가 들어오면 이전 데이터 무시
```

### Conflation

`conflate` 연산자는 소비자가 처리할 수 없을 만큼 데이터가 빠르게 생성될 때 최신의 데이터만 유지하고 이전 데이터는 무시합니다.

```kotlin
flow {
    // ...
}.conflate() // 최신 데이터만 유지
```

---

### Back Pressure

- Back Pressure는 데이터 스트림에서 생산자와 소비자 간의 처리 능력 차이를 관리하는 메커니즘입니다.
- 소비 보다 생성이 더 빠른 경우, 소비자의 오버 플로우나 메모리 부족 등 문제를 해결하기 위해 Back Pressure를 사용합니다.

#### 필요한 이유

1. 소비자가 처리할 수 있는 데이터 보다 더 많은 데이터가 들어오면 메모리가 금방 차기에 메모리 부족 현상이 일어 날 수 있기에
2. 소비자가 처리 능력을 초과하는 데이터를 받는 경우 시스템 전체 성능이 저하 될 수 있기에