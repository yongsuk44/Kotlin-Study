## Coroutine builders

suspend 함수는 서로 `continuation`을 전달해야 합니다. 
suspend 함수에서 일반 함수를 호출하는데 문제가 없지만, 일반 함수는 suspend 함수를 호출할 수 없습니다.

```kotlin
suspend fun suspendingFunction() {
    // ...
    normalFun()
}

fun normalFun() {
    // ...
    suspendingFunction() // Error : suspend function should be called only from a coroutine or another suspend function
}
```

모든 suspend 함수는 다른 suspend 함수에 의해 호출되어야 하며, 이들은 코루틴 빌더로 시작되어야 합니다.

kotlinx.coroutines 라이브러리에서 제공하는 코루틴 빌더들 입니다.
1. launch
2. runBlocking
3. async

각각에는 고유한 사용 사례가 있습니다.


### launch Builder

코루틴의 `launch` 빌더는 독립적으로 실행되는 새로운 프로세스를 시작하는 데 사용되며, 이는 새로운 스레드를 시작하는 것과 유사한 작동 방식을 가집니다.

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    
    println("Hello,")
    Thread.sleep(2000L)
}
/// Hello,
// (1s delay)
// World!
// World!
// World!
```

`launch`는 Kotlin의 `CoroutineScope` 인터페이스 확장 함수로, 부모 코루틴과 자식 코루틴 간의 연결을 가능하게 하는 구조화된 동시성의 중요한 부분입니다. 
실제 프로젝트에서는 `GlobalScope`를 드물게 사용하는 것이 권장되며, 잘못 사용할 경우 문제가 발생할 수 있습니다.

`delay` 함수는 코루틴을 일시 중단시키지만 스레드를 차단하지 않습니다. 
따라서 메인 스레드를 차단하지 않으면 `main()` 함수가 즉시 종료되어 코루틴이 작동하지 않게 됩니다. 
이를 해결하기 위해 `Thread.sleep`을 사용할 수 있습니다.

데몬 스레드와 `launch`는 비슷한 방식으로 작동하나 중요한 차이점이 있습니다. 
데몬 스레드는 차단된 스레드를 유지하는 데 비용이 많이 들지만, 일시 중단된 코루틴을 유지하는 것은 거의 비용이 들지 않습니다.
이로 인해 `launch`는 데몬 스레드보다 훨씬 효율적인 방법을 제공합니다.

결국, 둘 다 독립적인 프로세스를 시작하며 완료되기 전에 프로그램이 끝나는 것을 방지할 수 있는 로직(예: `Thread.sleep(2000L)`)이 필요합니다. 

```kotlin
fun main() {
    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }
    
    println("Hello,")
    Thread.sleep(2000L)
}
```