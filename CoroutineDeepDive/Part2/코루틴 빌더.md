## Coroutine builders

suspend 함수는 서로 `continuation`을 전달해야 합니다.
suspend 함수에서 일반 함수를 호출하는데 문제가 없지만, 일반 함수는 suspend 함수를 호출할 수 없습니다.

```kotlin
suspend fun suspendingFunction() {
    // ...
    normalFun()
}

fun normalFun() {
    // ...
    suspendingFunction() // Error : suspend function should be called only from a coroutine or another suspend function
}
```

모든 suspend 함수는 다른 suspend 함수에 의해 호출되어야 하며, 이들은 코루틴 빌더로 시작되어야 합니다.

kotlinx.coroutines 라이브러리에서 제공하는 코루틴 빌더들 입니다.

1. launch
2. runBlocking
3. async

각각에는 고유한 사용 사례가 있습니다.

### launch Builder

코루틴의 `launch` 빌더는 독립적으로 실행되는 새로운 프로세스를 시작하는 데 사용되며, 이는 새로운 스레드를 시작하는 것과 유사한 작동 방식을 가집니다.

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    println("Hello,")
    Thread.sleep(2000L)
}
/// Hello,
// (1s delay)
// World!
// World!
// World!
```

`launch`는 Kotlin의 `CoroutineScope` 인터페이스 확장 함수로, 부모 코루틴과 자식 코루틴 간의 연결을 가능하게 하는 구조화된 동시성의 중요한 부분입니다.
실제 프로젝트에서는 `GlobalScope`를 드물게 사용하는 것이 권장되며, 잘못 사용할 경우 문제가 발생할 수 있습니다.

`delay` 함수는 코루틴을 일시 중단시키지만 스레드를 차단하지 않습니다.
따라서 메인 스레드를 차단하지 않으면 `main()` 함수가 즉시 종료되어 코루틴이 작동하지 않게 됩니다.
이를 해결하기 위해 `Thread.sleep`을 사용할 수 있습니다.

데몬 스레드와 `launch`는 비슷한 방식으로 작동하나 중요한 차이점이 있습니다.
데몬 스레드는 차단된 스레드를 유지하는 데 비용이 많이 들지만, 일시 중단된 코루틴을 유지하는 것은 거의 비용이 들지 않습니다.
이로 인해 `launch`는 데몬 스레드보다 훨씬 효율적인 방법을 제공합니다.

결국, 둘 다 독립적인 프로세스를 시작하며 완료되기 전에 프로그램이 끝나는 것을 방지할 수 있는 로직(예: `Thread.sleep(2000L)`)이 필요합니다.

```kotlin
fun main() {
    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    println("Hello,")
    Thread.sleep(2000L)
}
```

---

## runBlocking builder

일반적인 규칙은 코루틴은 스레드를 차단해서는 안되며, 스레드를 일시 중단해야 합니다.
반면에 `main()`이 차단 되지않는 경우 프로그램이 너무 일찍 종료되어 스레드의 차단이 필요한 경우가 있습니다.
이런 경우에는 `runBlocking`을 사용할 수 있습니다.

### runBlocking 정의

`runBlocking`은 매우 특이한 빌더로, 코루틴이 중단될 때 시작된 스레드를 차단합니다.
즉, runBlocking 내의 `delay(1000L)`은 `Thread.sleep(1000L)`과 유사하게 작동합니다.

`runBlocking`빌더가 시작된 스레드는 코루틴이 완료될 때까지 중단됩니다.   
`Dispatcher`를 사용하면 다른 스레드에서 `runBlocking`을 실행하게 할 수 있지만, 이 빌더가 시작된 스레드는 코루틴이 끝날 때까지 차단됩니다.

```kotlin
fun main() {
    runBlocking {
        delay(1000L)
        println("World!")
    }

    runBlocking {
        delay(1000L)
        println("World!")
    }

    runBlocking {
        delay(1000L)
        println("World!")
    }

    println("Hello,")
}

// 1s delay
// World!
// 1s delay
// World!
// 1s delay
// World!
// Hello,

fun main() {
    Thread.sleep(1000L)
    println("World!")
    Thread.sleep(1000L)
    println("World!")
    Thread.sleep(1000L)
    println("World!")
    println("Hello,")
}
// 1s delay
// World!
// 1s delay
// World!
// 1s delay
// World!
// Hello,
```

### runBlocking 사용 사례

`runBlocking`은 몇 가지 특별한 사용 사례가 있습니다.

- 메인 함수에서 프로그램이 종료되지 않도록 스레드를 차단하는 상황
- Unit Test에서 스레드를 차단해야 하는 상황

```kotlin
fun main() = runBlocking {
    // ...
}

class MyTests {
    @Test
    fun `a Test`() = runBlocking {

    }
}
```

또한 `runBlocking`을 활용하여 `Thread.sleep(2000L)`을 `delay(2000)`으로 대체할 수 있습니다.  
이는 추후에 구조화된 동시성을 도입하면 더욱 유용하다는 것을 알 수 있습니다.

```kotlin
fun main() = runBlocking {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    delay(2000L) // still needed
}

// Hello,
// 1s delay
// World!
// World!
// World!
```

`runBlocking`은 중요한 빌더였지만, 최근에는 드물게 사용됩니다.

UnitTest에서는 가상 시간에서 코루틴을 작동시키는 `runTest`를 대신 사용하는 경우가 많으며, 메인 함수의 경우 suspend 함수로 만들어 사용합니다.

```kotlin
suspend fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    delay(2000L)
}

// Hello,
// 1s delay
// World!
// World!
// World!
```

---

## async builder

`async` 코루틴 빌더는 `launch`와 유사합니다. 이 값은 람다 표현식에 의해 반환되어야 합니다.

`async` 함수는 생성된 값의 타입이 `T`인 `Deferred<T>` 객체를 반환합니다.
`Deferred`는 값이 준비되면 반환하는 중단 메소드 `await`를 가지고 있습니다.

아래 예제에서 생성된 값은 42이고 타입은 `Int`이므로 `Deferred<Int>`를 반환하고 `await`는 `Int`타입의 `42`를 반환합니다.

```kotlin
fun main() = runBlocking {
    val resultDeferred: Deferred<Int> = GlobalScope.async {
        delay(1000L)
        42
    }
    // do other stuff...
    val result: Int = resultDeferred.await() // (1 sec) 
    println(result) // 42
    // or just
    println(resultDeferred.await()) // 42
}
```

`launch` 빌더와 마찬가지로, `async` 빌더는 코루틴을 즉시 시작합니다.  
따라서 몇 개의 프로세스를 한 번에 시작한 다음 그 결과를 모두 기다리는 방법입니다.

반환된 `Deferred`는 생성된 값이 준비되면 내부에 값을 저장하므로 준비되면 즉시 `await`을 통해 반환됩니다.   
그러나 값이 생성되기 전에 `await`를 호출하면 값이 준비될 때까지 중단됩니다.

```kotlin
fun main() = runBlocking {
    val res1 = GlobalScope.async {
        delay(1000L)
        "Text 1"
    }

    val res2 = GlobalScope.async {
        delay(1000L)
        "Text 2"
    }

    val res3 = GlobalScope.async {
        delay(1000L)
        "Text 3"
    }

    println(res1.await())
    println(res2.await())
    println(res3.await())
}

// 1s delay
// Text 1
// 2s delay
// Text 2
// Text 3
```

`async` 빌더의 동작은 `launch`와 매우 유사하지만, 추가적으로 값을 반환하는 것을 지원합니다.  
모든 `launch` 함수가 `async`로 대체된다면 코드에 문제가 없겠지만, 그렇게 하면 안됩니다.  
`async`는 값을 생성하는 것에 대해 중점을 두고 있으므로, 값이 필요하지 않은 경우 `launch`를 사용해야 합니다.

```kotlin
fun main() = runBlocking {
    // Don't do that
    // this is misleading to use async as launch
    GlobalScope.async {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    delay(2000L)
}
// Hello,
// 1s delay
// World!
```

`async` 빌더는 종종 2개의 프로세스를 병렬화하도록 사용됩니다.  
아래처럼 서로 다른 API를 호출하여 조합하는 예시입니다.

```kotlin
scope.launch {
    val news = async { newsRepo.getNews().sortedByDescending { it.date } }
    val newsSummary = newsRepo.getNewsSummary()

    // we could wrap it with async as well,
    // but it would be redundant
    view.showNews(
        newsSummary,
        news.await()
    )
}
```
