## Coroutine builders

suspend 함수는 서로 `continuation`을 전달해야 합니다. 
suspend 함수에서 일반 함수를 호출하는데 문제가 없지만, 일반 함수는 suspend 함수를 호출할 수 없습니다.

```kotlin
suspend fun suspendingFunction() {
    // ...
    normalFun()
}

fun normalFun() {
    // ...
    suspendingFunction() // Error : suspend function should be called only from a coroutine or another suspend function
}
```

모든 suspend 함수는 다른 suspend 함수에 의해 호출되어야 하며, 이들은 코루틴 빌더로 시작되어야 합니다.

kotlinx.coroutines 라이브러리에서 제공하는 코루틴 빌더들 입니다.
1. launch
2. runBlocking
3. async

각각에는 고유한 사용 사례가 있습니다.


### launch Builder

코루틴의 `launch` 빌더는 독립적으로 실행되는 새로운 프로세스를 시작하는 데 사용되며, 이는 새로운 스레드를 시작하는 것과 유사한 작동 방식을 가집니다.

```kotlin
fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }

    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    
    println("Hello,")
    Thread.sleep(2000L)
}
/// Hello,
// (1s delay)
// World!
// World!
// World!
```

`launch`는 Kotlin의 `CoroutineScope` 인터페이스 확장 함수로, 부모 코루틴과 자식 코루틴 간의 연결을 가능하게 하는 구조화된 동시성의 중요한 부분입니다. 
실제 프로젝트에서는 `GlobalScope`를 드물게 사용하는 것이 권장되며, 잘못 사용할 경우 문제가 발생할 수 있습니다.

`delay` 함수는 코루틴을 일시 중단시키지만 스레드를 차단하지 않습니다. 
따라서 메인 스레드를 차단하지 않으면 `main()` 함수가 즉시 종료되어 코루틴이 작동하지 않게 됩니다. 
이를 해결하기 위해 `Thread.sleep`을 사용할 수 있습니다.

데몬 스레드와 `launch`는 비슷한 방식으로 작동하나 중요한 차이점이 있습니다. 
데몬 스레드는 차단된 스레드를 유지하는 데 비용이 많이 들지만, 일시 중단된 코루틴을 유지하는 것은 거의 비용이 들지 않습니다.
이로 인해 `launch`는 데몬 스레드보다 훨씬 효율적인 방법을 제공합니다.

결국, 둘 다 독립적인 프로세스를 시작하며 완료되기 전에 프로그램이 끝나는 것을 방지할 수 있는 로직(예: `Thread.sleep(2000L)`)이 필요합니다. 

```kotlin
fun main() {
    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }

    thread(isDaemon = true) {
        Thread.sleep(1000L)
        println("World!")
    }
    
    println("Hello,")
    Thread.sleep(2000L)
}
```

---

## runBlocking builder

일반적인 규칙은 코루틴은 스레드를 차단해서는 안되며, 스레드를 일시 중단해야 합니다.
반면에 `main()`이 차단 되지않는 경우 프로그램이 너무 일찍 종료되어 스레드의 차단이 필요한 경우가 있습니다.
이런 경우에는 `runBlocking`을 사용할 수 있습니다.

### runBlocking 정의

`runBlocking`은 매우 특이한 빌더로, 코루틴이 중단될 때 시작된 스레드를 차단합니다.
즉, runBlocking 내의 `delay(1000L)`은 `Thread.sleep(1000L)`과 유사하게 작동합니다.

`runBlocking`빌더가 시작된 스레드는 코루틴이 완료될 때까지 중단됩니다.   
`Dispatcher`를 사용하면 다른 스레드에서 `runBlocking`을 실행하게 할 수 있지만, 이 빌더가 시작된 스레드는 코루틴이 끝날 때까지 차단됩니다.

```kotlin
fun main() {
    runBlocking {
        delay(1000L)
        println("World!")
    }

    runBlocking {
        delay(1000L)
        println("World!")
    }

    runBlocking {
        delay(1000L)
        println("World!")
    }
    
    println("Hello,")
}

// 1s delay
// World!
// 1s delay
// World!
// 1s delay
// World!
// Hello,

fun main() {
    Thread.sleep(1000L)
    println("World!")
    Thread.sleep(1000L)
    println("World!")
    Thread.sleep(1000L)
    println("World!")
    println("Hello,")
}
// 1s delay
// World!
// 1s delay
// World!
// 1s delay
// World!
// Hello,
```

### runBlocking 사용 사례

`runBlocking`은 몇 가지 특별한 사용 사례가 있습니다.

- 메인 함수에서 프로그램이 종료되지 않도록 스레드를 차단하는 상황
- Unit Test에서 스레드를 차단해야 하는 상황

```kotlin
fun main() = runBlocking { 
    // ...
}

class MyTests {
    @Test
    fun `a Test`() = runBlocking {
        
    }
}
```

또한 `runBlocking`을 활용하여 `Thread.sleep(2000L)`을 `delay(2000)`으로 대체할 수 있습니다.  
이는 추후에 구조화된 동시성을 도입하면 더욱 유용하다는 것을 알 수 있습니다.

```kotlin
fun main() = runBlocking {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    delay(2000L) // still needed
}

// Hello,
// 1s delay
// World!
// World!
// World!
```

`runBlocking`은 중요한 빌더였지만, 최근에는 드물게 사용됩니다.

UnitTest에서는 가상 시간에서 코루틴을 작동시키는 `runTest`를 대신 사용하는 경우가 많으며, 메인 함수의 경우 suspend 함수로 만들어 사용합니다.

```kotlin
suspend fun main() {
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    GlobalScope.launch {
        delay(1000L)
        println("World!")
    }
    println("Hello,")
    delay(2000L) 
}

// Hello,
// 1s delay
// World!
// World!
// World!
```