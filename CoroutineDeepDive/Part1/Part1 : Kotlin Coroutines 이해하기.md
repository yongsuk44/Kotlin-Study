# Part 1: Kotlin Coroutines 이해하기

Rxjava, Reactor와 같이 잘 정리된 기존 JVM 라이브러리들이 있습니다. 또한 Java 자체도 멀티스레딩을 지원하며, 많은 개발자들이 단순한 콜백을 사용하기도 합니다.
이처럼 명백하게 비동기 작업을 위한 여러가지 옵션들이 있습니다.

그러나 코루틴은 그 이상을 제공합니다.
코루틴은 멀티플랫폼으로 모든 Kotlin 플랫폼(JVM, JS, IOS, 공통 모듈 등)에서 사용될 수 있습니다.
또한 코드 구조를 크게 바꾸지 않습니다. 대부분의 코루틴 기능은 간단하게 사용할 수 있습니다.

## [Part 1.1 : Why Kotlin Coroutines](왜%20코루틴%20인가%3F.md)

클라이언트 로직 구현 시 빈번하게 처리하는 작업 순서로는 다음과 같을 수 있습니다.

1. 하나 or 여러 데이터 소스(API, Database, Preference, 다른 앱 등)에서 데이터를 얻어옴
2. 데이터 처리 (파싱, 추출, 병합 등)
3. 처리된 데이터를 통해 View Update, DB Update, API 요청 등 작업 수행

그러나 Android 플랫폼에서는 View Update 시 메인 스레드에서만 가능하고, 메인 스레드에서 블로킹 작업을 피해야 합니다.  
따라서 비동기 작업을 하는 경우에는 별도의 스레드를 통해 처리해야 하는것이 일반적이었습니다.

이에 따라 여러 방법이 제시되었고 여러 방법들과 코루틴을 비교 해보겠습니다.

|         | Thread Switching | Callbacks            | RxJava(및 기타 반응형 스트림)                | Kotlin Coroutines                                         |
|---------|------------------|----------------------|-------------------------------------|-----------------------------------------------------------|
| 스레드 전환  | 수동으로 처리하고 관리해야 함 | 콜백 안에서 수동으로 처리해야 함   | `.subscribeOn()`, `.observeOn()` 사용 | `Dispatchers`를 사용하여 관리                                    |
| 메모리 관리  | 직접 관리해야 함        | 메모리 누수 위험 있음         | `Disposable`을 사용하여 자동 관리            | 자동으로 관리되며, scope에 따라 제한됨                                  |
| 복잡성     | 낮음               | 중간 (콜백 지옥 위험)        | 높음 (학습 곡선이 가파름)                     | 중간                                                        |
| 동시성     | 직접 관리 및 조절해야 함   | 제한적                  | `.zip()`, `.flatMap()` 등을 사용하여 지원   | `suspendCoroutine`, `launch`, `withContext`, `async` 등 사용 |
| 취소 메커니즘 | 직접 구현해야 함        | 일반적으로 지원 안 됨         | `Disposable`을 사용하여 지원               | `cancel()` 및 `isActive` 사용                                |
| 오류 처리   | 예외 처리 구현 필요      | 콜백 내에서 처리 필요         | `onError()`를 사용하여 중앙 집중 처리          | `try-catch` 또는 `CoroutineExceptionHandler` 사용             |
| 응답성     | 직접 관리 및 조절해야 함   | 대기 시간 및 대기열 문제 발생 가능 | 스트림에 대한 반응형 처리 지원                   | 중단 및 재개 기능으로 높은 응답성 제공                                    |

## [Part 1.2 : Sequence builder](시퀀스%20빌더.md)

시퀀스 빌더는 제네레이터와 유사한 기능을 제공하며, 필요에 따라 시퀀스 항목을 제공하는 구조입니다.

요소가 요청될 떄만 계산되며, 미리 모든 요소를 생성하지 않기에 메모리 효율적입니다.  
또한 계속해서 값을 생성하는 것이 가능하여 무한한 시퀀스를 생성할 수 있습니다.

시퀀스 정의 시 `sequnece` 함수와 내부의 `yield` 함수를 사용하며, 시퀀스를 호출할 때 마다 `yield` 이후의 코드를 실행하여 다음 값을 제공합니다.  
즉, 만약 중간에서 함수가 중단되는 경우, 다음 호출 시 `yield` 이후의 코드부터 다시 실행됩니다.  
이렇게 중간에 중단되고 다시 시작하는 특성은 코루틴의 일시 정지 및 재개 메커니즘 덕분에 가능합니다.  

주의할 점으로 시퀀스 빌더 내에서는 `yield` 외의 다른 일시 정지 함수를 사용할 수 없습니다.  
만약 비동기 데이터를 가져와야 하는 경우, 코루틴의 `Flow`를 사용하는 것이 더 적합합니다.

## [Part 1.3 : How does suspendsion work?](코루틴에서%20일시정지는%20어떻게%20동작될까%3F.md)

코루틴의 일시 정지와 재개는 게임의 일시 정지와 이어하기와 비슷한 맥락을 가집니다.  
**게임 일시 정지 시 현재 상태를 저장**하고 잠시 멈춘 뒤 나중에 **게임을 다시 시작할 때 다시 그 지점에서 이어서** 플레이 할 수 있습니다.

### Continuation

코루틴에서 일시 정지 함수 호출 시 코루틴이 멈추게 되며, 이 때 `Continuation`이 반환 됩니다.  
`Continuation`은 현재 코루틴의 상태를 나타내는 객체로 이를 통해 나중에 코루틴을 다시 재개할 수 있습니다.

스레드와 코루틴의 차이점으로 스레드는 차단된 경우 자원을 계속 소모하는 반면, 코루틴은 일시 정지 시 자원을 소모하지 않습니다.  
또한 코루틴의 `Continuation`은 다른 스레드에서도 재개될 수 있습니다.

### Resume with value or Exception

코루틴은 중단 후 재개될 때 새로운 데이터를 반환할 수 있으며,
이를 통해 API와 같은 비동기 작업에서 데이터를 기다리는 동안 다른 작업을 수행할 수 있어 효율적입니다.

`suspendCoroutine`을 통해 코루틴을 일시 정지할 수 있고 `Continuation`의 `resume()`을 통해 다시 재개할 수 있습니다.  
이때 `resume()`에 전달되는 값은 `suspendCoroutine`의 반환 타입과 일치해야 합니다.  
`resume`을 통해서 예외 처리 시 `resumeWithException`을 통해 예외를 전달하여 가능합니다.

### suspend 함수를 중단하는 것이 아닌, 코루틴을 중단

suspend 함수에서 일시 정지가 된 상황에서는 suspend 함수가 정지된 것이 아닌, 코루틴이 정지되었다는 점을 알고 있어야 합니다.  
이때 코루틴을 외부에서 재개하는 것은 좋은 방법이 아니며, 이러한 방식으로 재개할 경우 메모리 누수와 같은 여러 문제를 일으킬 수 있습니다.


## [Part 1.4 : Coroutines under the hood](코루틴%20내부%20동작.md)

## [Part 1.5 : Coroutine: Built-in support vs library](코루틴의%20구조%20지원%20vs%20라이브러리.md)