# 목차

- [Item 36 : 상속 보단 구성 사용](#item-36--상속-보단-구성-사용)
- [Item 37 : 데이터 번들 표현 시 데이터 클래스 사용](#item-37--데이터-번들-표현-시-데이터-클래스-사용)
- [Item 38 : 연산 및 이벤트 전달 시 인터페이스 대신 함수 타입 권장](#item-38--연산-및-이벤트-전달-시-인터페이스-대신-함수-타입-권장)
- [Item 39 : 태그 클래스 대신 클래스 계층 선호](#item-39--태그-클래스-대신-클래스-계층-선호)
- [Item 40 : Equals 계약 준수](#item-40--equals-계약-준수)
- [Item 41 : HashCode 계약 준수](#item-41--hashcode-계약-준수)

## Item 36 : 상속 보단 구성 사용

상속은 객체를 계층화하는데 있어 강력하지만 항상 적절한 해결책으로 제시될 수 없습니다.
특히 코드의 일부를 재사용하고 싶을 때나 명확한 `is-a` 관계가 아닌 경우에는 상속보다는 클래스의 구성(Composition)이 적합합니다.

### 구성은 선택적 재사용 가능

구성은 객체를 필드나 속성으로 포함시키고 해당 기능의 재사용을 의미 합니다.
이를 통해 필요한 동작만 선택적으로 재사용할 수 있습니다.

상속 사용 시 상위 클래스의 모든 메서드와 필드를 물려받게 되어 필요하지 않는 기능까지 상속받는 문제가 발생될 수 있습니다.

### 상속은 단일 상속만 가능

Kotlin은 Java와 다르게 다중 상속을 지원하지 않기에 한 클래스는 한개의 상위 클래스만 상속 받을 수 있습니다.
하지만 구성을 사용하면 N개의 클래스 기능을 조합하여 사용할 수 있습니다.

### 상속은 강한 결합을 만듬

상속 사용 시 하위 클래스는 상위 클래스의 내부 동작에 강하게 결합되어 상위 클래스의 변화에 취약해집니다.
하지만 구성 사용 시 이런 결합을 최소화할 수 있습니다.

### 상속은 캡슐화를 꺠뜨릴 수 있음

상속 사용 시 상위 클래스의 내부 동작을 하위 클래스가 알게 되므로 캡슐화를 깨뜨릴 수 있습니다.
이는 캡슐화 원칙을 뷔안하여 시스템 보안성이 약화 될 수 있습니다.

구성과 위임(Delegation) 패턴은 상속의 이런 문제점을 해결하는데 도움이 되며,
구성은 클래스 간 관계를 느슨하게 만들고 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.
또한 위임 패턴 사용 시 구성을 사용하면서도 다형성을 보장 받기에 다형성이 중요한 경우 구성과 같이 사용하는 것이 좋습니다.

### 메서드 오버라이딩 제한

설계 되지 않은 클래스 확장 방지 시 클래스를 `final`로 선언할 수 있으며 기본적으로 모든 메서드는 `final` 형태 입니다.

상속을 통해 메서드 오버라이드 허용하게 하려면 `open`으로 설정하면 됩니다.
이런 방식을 적절하게 활용하여 상속을 위해 설계된 메서드만 오버라이드 가능하게 할 수 있습니다.

---

## Item 37 : 데이터 번들 표현 시 데이터 클래스 사용

Kotlin의 데이터 클래스는 데이터 번들을 표현하고 전달하는데 유용한 도구입니다.  
`toString`, `equals`, `hashCode`, `copy`, `componentN` 등과 같은 다양한 메서드와 데이터 수정자를 제공하여 코드의 간결성과 가독성을 높여줍니다.

### 데이터 클래스를 비구조화 할당 시 주의점

Kotlin의 비구조화 할당 기능은 데이터 클래스의 속성을 변수에 쉽게 할당할 수 있게 해주지만, 주의해야 할 점들이 있습니다.

데이터 클래스의 속성 순서 변경, 잘못된 비구조화 등의 문제를 예방하기 위해 비구조화 할당을 잘 이해하고 사용해야 합니다.

### 튜플보다 데이터 클래스를 선호하라

튜플(`Pair`, `Triple`)은 간결한 데이터 구조를 표현하는데 유용하지만, Kotlin에서는 데이터 클래스를 통해 더 명확하고 가독성 높은 코드를 작성할 수 있습니다.

특히, 데이터 클래스는 이름이 있는 속성을 가지므로, 이는 코드를 더 이해하기 쉽게 만듭니다. 따라서 가능한 한 튜플 대신 데이터 클래스를 사용하는 것이 좋습니다.

---

## Item 38 : 연산 및 이벤트 전달 시 인터페이스 대신 함수 타입 권장

함수 타입 사용 시 `람다 표현식`, `함수 참조`, `함수 타입 구현 객체` 등 다양한 방식으로 함수에 값을 전달할 수 있습니다.
이는 코드의 유연성을 높이며, 더 많은 사용 사례를 커버할 수 있습니다.

### SAM(Single Abstract Method)의 한계

SAM은 값 전달 방식이 제한적이며 코드의 가독성이 떨어질 수 있습니다.
특히 여러 리스너를 설정하는 경우, 모든 리스너를 하나의 인터페이스에 묶어 놓는 것은 관리와 사용에 불편함이 있을 수 있습니다.

### 함수 타입에서 typealias 활용

SAM과 비교했을 때의 함수 타입의 단점(파라미터 값과 반환 값 명시)을 `typealias`를 활용하여 극복할 수 있습니다.
이는 코드의 가독성을 높이며, IDE가 기본적으로 제안할 수 있도록 도와줍니다.

### Java와의 호환성

Kotlin 이외의 언어에서 사용될 때는 SAM의 사용이 더 합리적일 수 있습니다.  
이는 Java 클라이언트가 typealias나 IDE의 제안을 볼 수 없으며, 함수가 명시적으로 Unit을 반환하도록 요구하기 때문입니다.

따라서 Java에서 사용되도록 API를 설계할 때는 이 점을 고려해야 합니다.

---

## Item 39 : 태그 클래스 대신 클래스 계층 선호

### 태그 클래스의 단점과 클래스 계층 구조의 장점

태그 클래스는 하나의 클래스에 여러 모드를 두어 클래스의 동작을 정의합니다. 이로 인해 클래스는 여러 책임을 가지게 되며, 복잡도가 증가하고 유지 관리가 어려워집니다.
이에 반해, 클래스 계층 구조는 각 모드를 별도의 클래스로 분리하여 다형성을 허용함으로써 코드의 가독성을 향상시키고 유지 관리를 쉽게 할 수 있습니다.

### sealed 클래스 활용하여 클래스 계층 구조 제한

Kotlin에서는 `sealed` 클래스를 사용하여 한정된 하위 클래스 집합을 제한할 수 있습니다.
이를 통해 `when` 표현식을 사용할 때 새로운 기능을 쉽게 추가하고 `when` 표현식에서 빠트린 처리가 없음을 확인하는데 유용합니다.

### Sealed 클래스와 Abstract 클래스의 선택

`sealed` 클래스는 모든 하위 클래스를 한정할 수 있어 `when` 표현식에서의 안전성을 보장하지만,
`abstract` 클래스는 새로운 하위 클래스를 추가할 수 있기에 이를 사용할 때에는 함수를 `abstract`로 선언하고 각 하위 클래스에서 해당 함수를 오버라이드하는 것이 좋습니다.

### 태그 클래스와 상태 패턴의 구분

태그 클래스와 상태 패턴은 동일하지 않습니다.
상태 패턴은 객체 내부 상태가 변경될 때 그 행동을 변경하게 하는 행동적인 소프트웨어 디자인 패턴입니다.
이를 통해 동일한 객체의 상태 변화에 따른 다양한 동작을 관리할 수 있습니다.
이를 위해 상태 패턴은 각 상태를 별도의 클래스로 표현하며 각 상태를 `sealed` 클래스로 관리합니다.

---

## Item 40 : Equals 계약 준수

Kotlin의 모든 객체는 `Any`라는 최상위 클래스를 상속받습니다.
`Any`는 `equals`, `hashCode`, `toString` 등의 기본 메서드를 포함하고 있으며, 이들 메서드는 특정 계약에 기반을 두고 있습니다.
이러한 계약을 어길 경우, 일부 객체나 함수가 제대로 작동하지 않을 위험이 있습니다.

### 동등성에 대한 이해

| 동등성 타입  | 연산자           | 설명                        |
|---------|---------------|---------------------------|
| 구조적 동등성 | `==` `equals` | 객체의 내용이 같은지를 판단           |
| 참조 동등성  | `===`         | 두 객체가 동일한 인스턴스를 가리키는지를 판단 |

### equals 필요성

기본적으로 `Any`로부터 상속받은 `equals` 메서드는 참조 동등성을 확인합니다. 
이는 각 객체가 고유하다는 것을 의미하며, 이는 특히 데이터베이스 연결이나 스레드와 같이 활성화된 요소에 유용합니다.

그러나, 데이터에 의해 정의되는 클래스에서는 객체의 내용이 같은지를 비교하는 '구조적 동등성'이 필요한 경우도 있습니다. 
예를 들어, 모든 기본 생성자 속성이 같은지 확인하는 데이터 클래스가 이에 해당합니다.

### equals 재정의

`equals` 메서드의 기본 동등성과 데이터 클래스의 동등성 이외에도, 직접 `equals`를 구현해야하는 경우가 있습니다.

- 동등성 판단 로직이 기본적인 것과 다르게 필요한 경우
- 속성 중 일부만 비교하고 싶을 때
- 객체가 데이터 클래스가 되기를 원하지 않거나 비교해야 하는 속성들이 기본 생성자에 없는 경우

### 객체 동등성(Equals) 구현 요구 사항

| 요구사항 | 설명 |
|---------|-----|
| 반사성 (Reflexive) | 모든 null이 아닌 값 x에 대해, `x.equals(x)`는 항상 `true`를 반환해야 합니다. 이것은 객체 자체와의 동일성을 보장합니다. |
| 대칭성 (Symmetric) | 모든 null이 아닌 값 x와 y에 대해, `x.equals(y)`가 `true`일 때만 `y.equals(x)`도 반드시 `true`를 반환해야 합니다. 즉, 양방향 동등성을 보장해야 합니다. |
| 전이성 (Transitive) | 모든 null이 아닌 값 x, y, z에 대해, `x.equals(y)`가 `true`를 반환하고 `y.equals(z)`가 `true`를 반환하는 경우, `x.equals(z)`도 반드시 `true`를 반환해야 합니다. 즉, 연쇄적인 동등성을 보장해야 합니다. |
| 일관성 (Consistent) | 모든 null이 아닌 값 x와 y에 대해, `equals` 비교에 사용되는 객체 정보가 수정되지 않는 한 `x.equals(y)`를 여러 번 호출하더라도 항상 일관성있게 `true`나 `false`를 반환해야 합니다. 객체 정보가 변경되지 않는 한 결과가 변하지 않는 일관성을 보장합니다. |
| null과 절대 동일하지 않음 | 모든 null이 아닌 값 x에 대해, `x.equals(null)`은 항상 `false`를 반환해야 합니다. null은 고유하며, 어떤 객체도 null과 동등하다고 볼 수 없기 때문입니다. |

`equals`, `toString`, `hashCode` 메서드는 빠르게 동작해야 합니다. 두 객체를 비교하는데 오랜 시간이 걸리면 사용성이 저하될 수 있습니다.

---

## Item 41 : HashCode 계약 준수

해시 테이블은 빠르게 요소를 추가하고 검색할 수 있는 컬렉션을 제공하기 위해 사용되는 자료구조입니다. 
이러한 해시 테이블은 해시 함수를 사용하여 요소를 다른 버킷으로 분류하고 각 요소에 대해 고유한 번호를 할당합니다.

### 해시 함수

해시 함수는 빠른 동작, 동등한 요소에 대해 동일한 해시 코드 반환, 서로 다른 요소에 대해 다른 해시 코드를 반환하거나 충돌을 최소화해야 하는 특징이 있습니다.
해시 함수는 해시 테이블의 성능에 직접적인 영향을 미치므로 빠른 동작과 충돌 최소화를 고려하여 구현해야 합니다.

그러나 가변 요소는 해시 기반의 자료구조에서 문제가 될 수 있기에 가변 객체는 해시 기반의 자료구조나 다른 자료구조에서 사욛되지 않아야 합니다.

### hashCode 규약

동일 객체에 대한 `hashcode` 메서드가 여러 번 호출될 경우, 객체의 `equals` 메서드에 사용되는 정보가 변경되지 않는 이상 항상 같은 정수를 반환해야 합니다.
또한 두 객체가 `equals` 메서드를 통해 같다고 판단되면, 두 객체의 `hashCode` 메서드는 항상 같은 결과를 반환해야 합니다.

만약 위 규약을 지키지 않으면, 해시 테이블 컬렉션에서 요소가 사라지는 문제가 발생할 수 있습니다.

### hashCode 구현

구현은 `equals()`가 재정의되었다면 함께 `hashCode()`도 오버라이드하는 것이 좋습니다. 
주요 속성들의 동일성을 확인하는 일반적인 `equals()` 구현 시, 이들 속성들의 해시 코드를 기반으로 하는 일반적인 `hashCode()`를 구현해야 합니다. 

일반적으로는 해시 코드들을 모두 누적하면서 값을 31로 곱하는 방법을 사용합니다.